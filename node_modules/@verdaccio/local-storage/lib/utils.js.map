{"version":3,"sources":["../src/utils.ts"],"names":["getFileStats","packagePath","Promise","resolve","reject","fs","stat","err","stats","_","isNil","readDirectory","readdir","scopedPackages","hasScope","file","match","findPackages","storagePath","validationHandler","listPackages","scopePath","path","storageDirs","directory","scopeDirectory","scopedDirName","push","name","error"],"mappings":";;;;;;;;;AAAA;;AACA;;AAEA;;;;AAEO,SAASA,YAAT,CAAsBC,WAAtB,EAA8D;AACnE,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAA2B;AAC5CC,gBAAGC,IAAH,CAAQL,WAAR,EAAqB,CAACM,GAAD,EAAMC,KAAN,KAAgB;AACnC,UAAIC,gBAAEC,KAAF,CAAQH,GAAR,MAAiB,KAArB,EAA4B;AAC1B,eAAOH,MAAM,CAACG,GAAD,CAAb;AACD;;AACDJ,MAAAA,OAAO,CAACK,KAAD,CAAP;AACD,KALD;AAMD,GAPM,CAAP;AAQD;;AAEM,SAASG,aAAT,CAAuBV,WAAvB,EAA+D;AACpE,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAA2B;AAC5CC,gBAAGO,OAAH,CAAWX,WAAX,EAAwB,CAACM,GAAD,EAAMM,cAAN,KAAyB;AAC/C,UAAIJ,gBAAEC,KAAF,CAAQH,GAAR,MAAiB,KAArB,EAA4B;AAC1B,eAAOH,MAAM,CAACG,GAAD,CAAb;AACD;;AAEDJ,MAAAA,OAAO,CAACU,cAAD,CAAP;AACD,KAND;AAOD,GARM,CAAP;AASD;;AAED,SAASC,QAAT,CAAkBC,IAAlB,EAAyC;AACvC,SAAOA,IAAI,CAACC,KAAL,CAAW,IAAX,MAAqB,IAA5B;AACD;AAED;;;AACO,eAAeC,YAAf,CACLC,WADK,EAELC,iBAFK,EAGsC;AAC3C,QAAMC,YAA8C,GAAG,EAAvD;AACA,SAAO,IAAIlB,OAAJ,CAAY,OAAOC,OAAP,EAAgBC,MAAhB,KAA2B;AAC5C,QAAI;AACF,YAAMiB,SAAS,GAAGC,cAAKnB,OAAL,CAAae,WAAb,CAAlB;;AACA,YAAMK,WAAW,GAAG,MAAMZ,aAAa,CAACU,SAAD,CAAvC;;AACA,WAAK,MAAMG,SAAX,IAAwBD,WAAxB,EAAqC;AACnC;AACA,YAAIT,QAAQ,CAACU,SAAD,CAAZ,EAAyB;AACvB;AACA,gBAAMC,cAAc,GAAGH,cAAKnB,OAAL,CAAae,WAAb,EAA0BM,SAA1B,CAAvB;;AACA,gBAAMX,cAAc,GAAG,MAAMF,aAAa,CAACc,cAAD,CAA1C;;AACA,eAAK,MAAMC,aAAX,IAA4Bb,cAA5B,EAA4C;AAC1C,gBAAIM,iBAAiB,CAACO,aAAD,CAArB,EAAsC;AACpC;AACA,oBAAML,SAAS,GAAGC,cAAKnB,OAAL,CAAae,WAAb,EAA0BM,SAA1B,EAAqCE,aAArC,CAAlB,CAFoC,CAGpC;;;AACAN,cAAAA,YAAY,CAACO,IAAb,CAAkB;AAChBC,gBAAAA,IAAI,EAAG,GAAEJ,SAAU,IAAGE,aAAc,EADpB;AAEhBJ,gBAAAA,IAAI,EAAED;AAFU,eAAlB;AAID;AACF;AACF,SAfD,MAeO;AACL;AACA,cAAIF,iBAAiB,CAACK,SAAD,CAArB,EAAkC;AAChC,kBAAMH,SAAS,GAAGC,cAAKnB,OAAL,CAAae,WAAb,EAA0BM,SAA1B,CAAlB;;AACAJ,YAAAA,YAAY,CAACO,IAAb,CAAkB;AAChBC,cAAAA,IAAI,EAAEJ,SADU;AAEhBF,cAAAA,IAAI,EAAED;AAFU,aAAlB;AAID;AACF;AACF;AACF,KA/BD,CA+BE,OAAOQ,KAAP,EAAc;AACdzB,MAAAA,MAAM,CAACyB,KAAD,CAAN;AACD;;AAED1B,IAAAA,OAAO,CAACiB,YAAD,CAAP;AACD,GArCM,CAAP;AAsCD;AACD","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nimport _ from 'lodash';\n\nexport function getFileStats(packagePath: string): Promise<fs.Stats> {\n  return new Promise((resolve, reject): void => {\n    fs.stat(packagePath, (err, stats) => {\n      if (_.isNil(err) === false) {\n        return reject(err);\n      }\n      resolve(stats);\n    });\n  });\n}\n\nexport function readDirectory(packagePath: string): Promise<string[]> {\n  return new Promise((resolve, reject): void => {\n    fs.readdir(packagePath, (err, scopedPackages) => {\n      if (_.isNil(err) === false) {\n        return reject(err);\n      }\n\n      resolve(scopedPackages);\n    });\n  });\n}\n\nfunction hasScope(file: string): boolean {\n  return file.match(/^@/) !== null;\n}\n\n/* eslint-disable no-async-promise-executor */\nexport async function findPackages(\n  storagePath: string,\n  validationHandler: Function\n): Promise<{ name: string; path: string }[]> {\n  const listPackages: { name: string; path: string }[] = [];\n  return new Promise(async (resolve, reject) => {\n    try {\n      const scopePath = path.resolve(storagePath);\n      const storageDirs = await readDirectory(scopePath);\n      for (const directory of storageDirs) {\n        // we check whether has 2nd level\n        if (hasScope(directory)) {\n          // we read directory multiple\n          const scopeDirectory = path.resolve(storagePath, directory);\n          const scopedPackages = await readDirectory(scopeDirectory);\n          for (const scopedDirName of scopedPackages) {\n            if (validationHandler(scopedDirName)) {\n              // we build the complete scope path\n              const scopePath = path.resolve(storagePath, directory, scopedDirName);\n              // list content of such directory\n              listPackages.push({\n                name: `${directory}/${scopedDirName}`,\n                path: scopePath,\n              });\n            }\n          }\n        } else {\n          // otherwise we read as single level\n          if (validationHandler(directory)) {\n            const scopePath = path.resolve(storagePath, directory);\n            listPackages.push({\n              name: directory,\n              path: scopePath,\n            });\n          }\n        }\n      }\n    } catch (error) {\n      reject(error);\n    }\n\n    resolve(listPackages);\n  });\n}\n/* eslint-enable no-async-promise-executor */\n"],"file":"utils.js"}