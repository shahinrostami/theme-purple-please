"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _url = _interopRequireDefault(require("url"));

var _debug = _interopRequireDefault(require("debug"));

var _lodash = _interopRequireDefault(require("lodash"));

var _localStorage = _interopRequireDefault(require("@verdaccio/local-storage"));

var _streams = require("@verdaccio/streams");

var _pluginLoader = _interopRequireDefault(require("../lib/plugin-loader"));

var _utils = require("./utils");

var _storageUtils = require("./storage-utils");

var _constants = require("./constants");

var _cryptoUtils = require("./crypto-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('verdaccio:local-storage');
/**
 * Implements Storage interface (same for storage.js, local-storage.js, up-storage.js).
 */

class LocalStorage {
  constructor(config, logger) {
    _defineProperty(this, "config", void 0);

    _defineProperty(this, "storagePlugin", void 0);

    _defineProperty(this, "logger", void 0);

    this.logger = logger;
    this.config = config;
    this.storagePlugin = this._loadStorage(config, logger);
  }

  addPackage(name, pkg, callback) {
    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return callback(_utils.ErrorCode.getNotFound('this package cannot be added'));
    }

    storage.createPackage(name, (0, _storageUtils.generatePackageTemplate)(name), err => {
      // FIXME: it will be fixed here https://github.com/verdaccio/verdaccio/pull/1360
      // @ts-ignore
      if (_lodash.default.isNull(err) === false && (err.code === _constants.STORAGE.FILE_EXIST_ERROR || err.code === _constants.HTTP_STATUS.CONFLICT)) {
        return callback(_utils.ErrorCode.getConflict());
      }

      const latest = (0, _utils.getLatestVersion)(pkg);

      if (_lodash.default.isNil(latest) === false && pkg.versions[latest]) {
        return callback(null, pkg.versions[latest]);
      }

      return callback();
    });
  }
  /**
   * Remove package.
   * @param {*} name
   * @param {*} callback
   * @return {Function}
   */


  removePackage(name, callback) {
    const storage = this._getLocalStorage(name);

    debug('[storage] removing package %o', name);

    if (_lodash.default.isNil(storage)) {
      return callback(_utils.ErrorCode.getNotFound());
    }

    storage.readPackage(name, (err, data) => {
      if (_lodash.default.isNil(err) === false) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          return callback(_utils.ErrorCode.getNotFound());
        }

        return callback(err);
      }

      data = (0, _storageUtils.normalizePackage)(data);
      this.storagePlugin.remove(name, removeFailed => {
        if (removeFailed) {
          // This will happen when database is locked
          this.logger.error({
            name
          }, `[storage/removePackage] the database is locked, removed has failed for @{name}`);
          return callback(_utils.ErrorCode.getBadData(removeFailed.message));
        }

        storage.deletePackage(_constants.STORAGE.PACKAGE_FILE_NAME, err => {
          if (err) {
            return callback(err);
          }

          const attachments = Object.keys(data._attachments);

          this._deleteAttachments(storage, attachments, callback);
        });
      });
    });
  }
  /**
   * Synchronize remote package info with the local one
   * @param {*} name
   * @param {*} packageInfo
   * @param {*} callback
   */


  updateVersions(name, packageInfo, callback) {
    this._readCreatePackage(name, (err, packageLocalJson) => {
      if (err) {
        return callback(err);
      }

      let change = false; // updating readme

      packageLocalJson.readme = (0, _storageUtils.getLatestReadme)(packageInfo);

      if (packageInfo.readme !== packageLocalJson.readme) {
        change = true;
      }

      for (const versionId in packageInfo.versions) {
        if (_lodash.default.isNil(packageLocalJson.versions[versionId])) {
          let version = packageInfo.versions[versionId]; // we don't keep readme for package versions,
          // only one readme per package

          version = (0, _storageUtils.cleanUpReadme)(version);
          version.contributors = (0, _storageUtils.normalizeContributors)(version.contributors);
          change = true;
          packageLocalJson.versions[versionId] = version;

          if (version.dist && version.dist.tarball) {
            const urlObject = _url.default.parse(version.dist.tarball);

            const filename = urlObject.pathname.replace(/^.*\//, ''); // we do NOT overwrite any existing records

            if (_lodash.default.isNil(packageLocalJson._distfiles[filename])) {
              const hash = packageLocalJson._distfiles[filename] = {
                url: version.dist.tarball,
                sha: version.dist.shasum
              };
              /* eslint spaced-comment: 0 */
              // $FlowFixMe

              const upLink = version[Symbol.for('__verdaccio_uplink')];

              if (_lodash.default.isNil(upLink) === false) {
                this._updateUplinkToRemoteProtocol(hash, upLink);
              }
            }
          }
        }
      }

      for (const tag in packageInfo[_constants.DIST_TAGS]) {
        if (!packageLocalJson[_constants.DIST_TAGS][tag] || packageLocalJson[_constants.DIST_TAGS][tag] !== packageInfo[_constants.DIST_TAGS][tag]) {
          change = true;
          packageLocalJson[_constants.DIST_TAGS][tag] = packageInfo[_constants.DIST_TAGS][tag];
        }
      }

      for (const up in packageInfo._uplinks) {
        if (Object.prototype.hasOwnProperty.call(packageInfo._uplinks, up)) {
          const need_change = !(0, _utils.isObject)(packageLocalJson._uplinks[up]) || packageInfo._uplinks[up].etag !== packageLocalJson._uplinks[up].etag || packageInfo._uplinks[up].fetched !== packageLocalJson._uplinks[up].fetched;

          if (need_change) {
            change = true;
            packageLocalJson._uplinks[up] = packageInfo._uplinks[up];
          }
        }
      }

      if ('time' in packageInfo && !_lodash.default.isEqual(packageLocalJson.time, packageInfo.time)) {
        packageLocalJson.time = packageInfo.time;
        change = true;
      }

      if (change) {
        debug('updating package %o info', name);

        this._writePackage(name, packageLocalJson, function (err) {
          callback(err, packageLocalJson);
        });
      } else {
        callback(null, packageLocalJson);
      }
    });
  }
  /**
   * Add a new version to a previous local package.
   * @param {*} name
   * @param {*} version
   * @param {*} metadata
   * @param {*} tag
   * @param {*} callback
   */


  addVersion(name, version, metadata, tag, callback) {
    this._updatePackage(name, (data, cb) => {
      // keep only one readme per package
      data.readme = metadata.readme; // TODO: lodash remove

      metadata = (0, _storageUtils.cleanUpReadme)(metadata);
      metadata.contributors = (0, _storageUtils.normalizeContributors)(metadata.contributors);
      const hasVersion = data.versions[version] != null;

      if (hasVersion) {
        return cb(_utils.ErrorCode.getConflict());
      } // if uploaded tarball has a different shasum, it's very likely that we have some kind of error


      if ((0, _utils.isObject)(metadata.dist) && _lodash.default.isString(metadata.dist.tarball)) {
        const tarball = metadata.dist.tarball.replace(/.*\//, '');

        if ((0, _utils.isObject)(data._attachments[tarball])) {
          if (_lodash.default.isNil(data._attachments[tarball].shasum) === false && _lodash.default.isNil(metadata.dist.shasum) === false) {
            if (data._attachments[tarball].shasum != metadata.dist.shasum) {
              const errorMessage = `shasum error, ${data._attachments[tarball].shasum} != ${metadata.dist.shasum}`;
              return cb(_utils.ErrorCode.getBadRequest(errorMessage));
            }
          }

          const currentDate = new Date().toISOString(); // some old storage do not have this field #740

          if (_lodash.default.isNil(data.time)) {
            data.time = {};
          }

          data.time['modified'] = currentDate;

          if ('created' in data.time === false) {
            data.time.created = currentDate;
          }

          data.time[version] = currentDate;
          data._attachments[tarball].version = version;
        }
      }

      data.versions[version] = metadata;
      (0, _utils.tagVersion)(data, version, tag);
      this.storagePlugin.add(name, addFailed => {
        if (addFailed) {
          return cb(_utils.ErrorCode.getBadData(addFailed.message));
        }

        cb();
      });
    }, callback);
  }
  /**
   * Merge a new list of tags for a local packages with the existing one.
   * @param {*} pkgName
   * @param {*} tags
   * @param {*} callback
   */


  mergeTags(pkgName, tags, callback) {
    this._updatePackage(pkgName, (data, cb) => {
      /* eslint guard-for-in: 0 */
      for (const tag in tags) {
        // this handle dist-tag rm command
        if (_lodash.default.isNull(tags[tag])) {
          delete data[_constants.DIST_TAGS][tag];
          continue;
        }

        if (_lodash.default.isNil(data.versions[tags[tag]])) {
          return cb(this._getVersionNotFound());
        }

        const version = tags[tag];
        (0, _utils.tagVersion)(data, version, tag);
      }

      cb(null);
    }, callback);
  }
  /**
   * Return version not found
   * @return {String}
   * @private
   */


  _getVersionNotFound() {
    return _utils.ErrorCode.getNotFound(_constants.API_ERROR.VERSION_NOT_EXIST);
  }
  /**
   * Return file no available
   * @return {String}
   * @private
   */


  _getFileNotAvailable() {
    return _utils.ErrorCode.getNotFound('no such file available');
  }
  /**
   * Update the package metadata, tags and attachments (tarballs).
   * Note: Currently supports unpublishing and deprecation.
   * @param {*} name
   * @param {*} incomingPkg
   * @param {*} revision
   * @param {*} callback
   * @return {Function}
   */


  changePackage(name, incomingPkg, revision, callback) {
    if (!(0, _utils.isObject)(incomingPkg.versions) || !(0, _utils.isObject)(incomingPkg[_constants.DIST_TAGS])) {
      this.logger.error({
        name
      }, `changePackage bad data for @{name}`);
      return callback(_utils.ErrorCode.getBadData());
    }

    debug('changePackage udapting package for %o', name);

    this._updatePackage(name, (localData, cb) => {
      for (const version in localData.versions) {
        const incomingVersion = incomingPkg.versions[version];

        if (_lodash.default.isNil(incomingVersion)) {
          this.logger.info({
            name: name,
            version: version
          }, 'unpublishing @{name}@@{version}'); // FIXME: I prefer return a new object rather mutate the metadata

          delete localData.versions[version];
          delete localData.time[version];

          for (const file in localData._attachments) {
            if (localData._attachments[file].version === version) {
              delete localData._attachments[file].version;
            }
          }
        } else if (Object.prototype.hasOwnProperty.call(incomingVersion, 'deprecated')) {
          const incomingDeprecated = incomingVersion.deprecated;

          if (incomingDeprecated != localData.versions[version].deprecated) {
            if (!incomingDeprecated) {
              this.logger.info({
                name: name,
                version: version
              }, 'undeprecating @{name}@@{version}');
              delete localData.versions[version].deprecated;
            } else {
              this.logger.info({
                name: name,
                version: version
              }, 'deprecating @{name}@@{version}');
              localData.versions[version].deprecated = incomingDeprecated;
            }

            localData.time.modified = new Date().toISOString();
          }
        }
      }

      localData[_constants.USERS] = incomingPkg[_constants.USERS];
      localData[_constants.DIST_TAGS] = incomingPkg[_constants.DIST_TAGS];
      cb(null);
    }, function (err) {
      if (err) {
        return callback(err);
      }

      callback();
    });
  }
  /**
   * Remove a tarball.
   * @param {*} name
   * @param {*} filename
   * @param {*} revision
   * @param {*} callback
   */


  removeTarball(name, filename, revision, callback) {
    (0, _assert.default)((0, _utils.validateName)(filename));

    this._updatePackage(name, (data, cb) => {
      if (data._attachments[filename]) {
        delete data._attachments[filename];
        cb(null);
      } else {
        cb(this._getFileNotAvailable());
      }
    }, err => {
      if (err) {
        return callback(err);
      }

      const storage = this._getLocalStorage(name);

      if (storage) {
        storage.deletePackage(filename, callback);
      }
    });
  }
  /**
   * Add a tarball.
   * @param {String} name
   * @param {String} filename
   * @return {Stream}
   */


  addTarball(name, filename) {
    (0, _assert.default)((0, _utils.validateName)(filename));
    let length = 0;
    const shaOneHash = (0, _cryptoUtils.createTarballHash)();
    const uploadStream = new _streams.UploadTarball({});
    const _transform = uploadStream._transform;

    const storage = this._getLocalStorage(name);

    uploadStream.abort = function () {};

    uploadStream.done = function () {};

    uploadStream._transform = function (data, ...args) {
      shaOneHash.update(data); // measure the length for validation reasons

      length += data.length;
      const appliedData = [data, ...args]; // FIXME: not sure about this approach, tsc complains
      // @ts-ignore

      _transform.apply(uploadStream, appliedData);
    };

    if (name === '__proto__') {
      process.nextTick(() => {
        uploadStream.emit('error', _utils.ErrorCode.getForbidden());
      });
      return uploadStream;
    }

    if (!storage) {
      process.nextTick(() => {
        uploadStream.emit('error', "can't upload this package");
      });
      return uploadStream;
    }

    const writeStream = storage.writeTarball(filename);
    writeStream.on('error', err => {
      // @ts-ignore
      if (err.code === _constants.STORAGE.FILE_EXIST_ERROR || err.code === _constants.HTTP_STATUS.CONFLICT) {
        uploadStream.emit('error', _utils.ErrorCode.getConflict());
        uploadStream.abort(); // @ts-ignore
      } else if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
        // check if package exists to throw an appropriate message
        this.getPackageMetadata(name, function (_err, _res) {
          if (_err) {
            uploadStream.emit('error', _err);
          } else {
            uploadStream.emit('error', err);
          }
        });
      } else {
        uploadStream.emit('error', err);
      }
    });
    writeStream.on('open', function () {
      // re-emitting open because it's handled in storage.js
      uploadStream.emit('open');
    });
    writeStream.on('success', () => {
      this._updatePackage(name, function updater(data, cb) {
        data._attachments[filename] = {
          shasum: shaOneHash.digest('hex')
        };
        cb(null);
      }, function (err) {
        if (err) {
          uploadStream.emit('error', err);
        } else {
          uploadStream.emit('success');
        }
      });
    });

    uploadStream.abort = function () {
      writeStream.abort();
    };

    uploadStream.done = function () {
      if (!length) {
        uploadStream.emit('error', _utils.ErrorCode.getBadData('refusing to accept zero-length file'));
        writeStream.abort();
      } else {
        writeStream.done();
      }
    };

    uploadStream.pipe(writeStream);
    return uploadStream;
  }
  /**
   * Get a tarball.
   * @param {*} name
   * @param {*} filename
   * @return {ReadTarball}
   */


  getTarball(name, filename) {
    (0, _assert.default)((0, _utils.validateName)(filename));

    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return this._createFailureStreamResponse();
    }

    return this._streamSuccessReadTarBall(storage, filename);
  }
  /**
   * Return a stream that emits a read failure.
   * @private
   * @return {ReadTarball}
   */


  _createFailureStreamResponse() {
    const stream = new _streams.ReadTarball({});
    process.nextTick(() => {
      stream.emit('error', this._getFileNotAvailable());
    });
    return stream;
  }
  /**
   * Return a stream that emits the tarball data
   * @param {Object} storage
   * @param {String} filename
   * @private
   * @return {ReadTarball}
   */


  _streamSuccessReadTarBall(storage, filename) {
    const stream = new _streams.ReadTarball({});
    const readTarballStream = storage.readTarball(filename);
    const e404 = _utils.ErrorCode.getNotFound;

    stream.abort = function () {
      if (_lodash.default.isNil(readTarballStream) === false) {
        readTarballStream.abort();
      }
    };

    readTarballStream.on('error', function (err) {
      // @ts-ignore
      if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
        stream.emit('error', e404('no such file available'));
      } else {
        stream.emit('error', err);
      }
    });
    readTarballStream.on('content-length', function (content) {
      stream.emit('content-length', content);
    });
    readTarballStream.on('open', function () {
      // re-emitting open because it's handled in storage.js
      stream.emit('open');
      readTarballStream.pipe(stream);
    });
    return stream;
  }
  /**
   * Retrieve a package by name.
   * @param {*} name
   * @param {*} callback
   * @return {Function}
   */


  getPackageMetadata(name, callback = () => {}) {
    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return callback(_utils.ErrorCode.getNotFound());
    }

    this._readPackage(name, storage, callback);
  }
  /**
   * Search a local package.
   * @param {*} startKey
   * @param {*} options
   * @return {Function}
   */


  search(startKey, options) {
    const stream = new _streams.ReadTarball({
      objectMode: true
    });

    this._searchEachPackage((item, cb) => {
      // @ts-ignore
      if (item.time > parseInt(startKey, 10)) {
        this.getPackageMetadata(item.name, (err, data) => {
          if (err) {
            return cb(err);
          } // @ts-ignore


          const time = new Date(item.time).toISOString();
          const result = (0, _storageUtils.prepareSearchPackage)(data, time);

          if (_lodash.default.isNil(result) === false) {
            stream.push(result);
          }

          cb(null);
        });
      } else {
        cb(null);
      }
    }, function onEnd(err) {
      if (err) {
        stream.emit('error', err);
        return;
      }

      stream.end();
    });

    return stream;
  }
  /**
   * Retrieve a wrapper that provide access to the package location.
   * @param {Object} pkgName package name.
   * @return {Object}
   */


  _getLocalStorage(pkgName) {
    return this.storagePlugin.getPackageStorage(pkgName);
  }
  /**
   * Read a json file from storage.
   * @param {Object} storage
   * @param {Function} callback
   */


  _readPackage(name, storage, callback) {
    storage.readPackage(name, (err, result) => {
      if (err) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          return callback(_utils.ErrorCode.getNotFound());
        }

        return callback(this._internalError(err, _constants.STORAGE.PACKAGE_FILE_NAME, 'error reading'));
      }

      callback(err, (0, _storageUtils.normalizePackage)(result));
    });
  }
  /**
   * Walks through each package and calls `on_package` on them.
   * @param {*} onPackage
   * @param {*} onEnd
   */


  _searchEachPackage(onPackage, onEnd) {
    // save wait whether plugin still do not support search functionality
    if (_lodash.default.isNil(this.storagePlugin.search)) {
      this.logger.warn('plugin search not implemented yet');
      onEnd();
    } else {
      this.storagePlugin.search(onPackage, onEnd, _utils.validateName);
    }
  }
  /**
   * Retrieve either a previous created local package or a boilerplate.
   * @param {*} pkgName
   * @param {*} callback
   * @return {Function}
   */


  _readCreatePackage(pkgName, callback) {
    const storage = this._getLocalStorage(pkgName);

    if (_lodash.default.isNil(storage)) {
      this._createNewPackage(pkgName, callback);

      return;
    }

    storage.readPackage(pkgName, (err, data) => {
      // TODO: race condition
      if (_lodash.default.isNil(err) === false) {
        if (err.code === _constants.STORAGE.NO_SUCH_FILE_ERROR || err.code === _constants.HTTP_STATUS.NOT_FOUND) {
          data = (0, _storageUtils.generatePackageTemplate)(pkgName);
        } else {
          return callback(this._internalError(err, _constants.STORAGE.PACKAGE_FILE_NAME, 'error reading'));
        }
      }

      callback(null, (0, _storageUtils.normalizePackage)(data));
    });
  }

  _createNewPackage(name, callback) {
    return callback(null, (0, _storageUtils.normalizePackage)((0, _storageUtils.generatePackageTemplate)(name)));
  }
  /**
   * Handle internal error
   * @param {*} err
   * @param {*} file
   * @param {*} message
   * @return {Object} Error instance
   */


  _internalError(err, file, message) {
    this.logger.error({
      err: err,
      file: file
    }, `${message}  @{file}: @{!err.message}`);
    return _utils.ErrorCode.getInternalError();
  }
  /**
   * @param {*} name package name
   * @param {*} updateHandler function(package, cb) - update function
   * @param {*} callback callback that gets invoked after it's all updated
   * @return {Function}
   */


  _updatePackage(name, updateHandler, callback) {
    const storage = this._getLocalStorage(name);

    if (!storage) {
      return callback(_utils.ErrorCode.getNotFound());
    }

    storage.updatePackage(name, updateHandler, this._writePackage.bind(this), _storageUtils.normalizePackage, callback);
  }
  /**
   * Update the revision (_rev) string for a package.
   * @param {*} name
   * @param {*} json
   * @param {*} callback
   * @return {Function}
   */


  _writePackage(name, json, callback) {
    const storage = this._getLocalStorage(name);

    if (_lodash.default.isNil(storage)) {
      return callback();
    }

    storage.savePackage(name, this._setDefaultRevision(json), callback);
  }

  _setDefaultRevision(json) {
    // calculate revision from couch db
    if (_lodash.default.isString(json._rev) === false) {
      json._rev = _constants.STORAGE.DEFAULT_REVISION;
    } // this is intended in debug mode we do not want modify the store revision


    if (_lodash.default.isNil(this.config._debug)) {
      json._rev = (0, _storageUtils.generateRevision)(json._rev);
    }

    return json;
  }

  _deleteAttachments(storage, attachments, callback) {
    debug('[storage/_deleteAttachments] delete attachments total: %o', attachments === null || attachments === void 0 ? void 0 : attachments.length);

    const unlinkNext = function (cb) {
      if (_lodash.default.isEmpty(attachments)) {
        return cb();
      }

      const attachment = attachments.shift();
      storage.deletePackage(attachment, function () {
        unlinkNext(cb);
      });
    };

    unlinkNext(function () {
      // try to unlink the directory, but ignore errors because it can fail
      storage.removePackage(function (err) {
        callback(err);
      });
    });
  }
  /**
   * Ensure the dist file remains as the same protocol
   * @param {Object} hash metadata
   * @param {String} upLinkKey registry key
   * @private
   */


  _updateUplinkToRemoteProtocol(hash, upLinkKey) {
    // if we got this information from a known registry,
    // use the same protocol for the tarball
    //
    // see https://github.com/rlidwka/sinopia/issues/166
    const tarballUrl = _url.default.parse(hash.url);

    const uplinkUrl = _url.default.parse(this.config.uplinks[upLinkKey].url);

    if (uplinkUrl.host === tarballUrl.host) {
      tarballUrl.protocol = uplinkUrl.protocol;
      hash.registry = upLinkKey;
      hash.url = _url.default.format(tarballUrl);
    }
  }

  async getSecret(config) {
    const secretKey = await this.storagePlugin.getSecret();
    return this.storagePlugin.setSecret(config.checkSecretKey(secretKey));
  }

  _loadStorage(config, logger) {
    const Storage = this._loadStorePlugin();

    if (_lodash.default.isNil(Storage)) {
      (0, _assert.default)(this.config.storage, 'CONFIG: storage path not defined');
      return new _localStorage.default(this.config, logger);
    }

    return Storage;
  }

  _loadStorePlugin() {
    const plugin_params = {
      config: this.config,
      logger: this.logger
    }; // eslint-disable-next-line max-len

    const plugins = (0, _pluginLoader.default)(this.config, this.config.store, plugin_params, plugin => {
      return plugin.getPackageStorage;
    });
    return _lodash.default.head(plugins);
  }

  saveToken(token) {
    if (_lodash.default.isFunction(this.storagePlugin.saveToken) === false) {
      return Promise.reject(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }

    return this.storagePlugin.saveToken(token);
  }

  deleteToken(user, tokenKey) {
    if (_lodash.default.isFunction(this.storagePlugin.deleteToken) === false) {
      return Promise.reject(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }

    return this.storagePlugin.deleteToken(user, tokenKey);
  }

  readTokens(filter) {
    if (_lodash.default.isFunction(this.storagePlugin.readTokens) === false) {
      return Promise.reject(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.SERVICE_UNAVAILABLE, _constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }

    return this.storagePlugin.readTokens(filter);
  }

}

var _default = LocalStorage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbG9jYWwtc3RvcmFnZS50cyJdLCJuYW1lcyI6WyJkZWJ1ZyIsIkxvY2FsU3RvcmFnZSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwibG9nZ2VyIiwic3RvcmFnZVBsdWdpbiIsIl9sb2FkU3RvcmFnZSIsImFkZFBhY2thZ2UiLCJuYW1lIiwicGtnIiwiY2FsbGJhY2siLCJzdG9yYWdlIiwiX2dldExvY2FsU3RvcmFnZSIsIl8iLCJpc05pbCIsIkVycm9yQ29kZSIsImdldE5vdEZvdW5kIiwiY3JlYXRlUGFja2FnZSIsImVyciIsImlzTnVsbCIsImNvZGUiLCJTVE9SQUdFIiwiRklMRV9FWElTVF9FUlJPUiIsIkhUVFBfU1RBVFVTIiwiQ09ORkxJQ1QiLCJnZXRDb25mbGljdCIsImxhdGVzdCIsInZlcnNpb25zIiwicmVtb3ZlUGFja2FnZSIsInJlYWRQYWNrYWdlIiwiZGF0YSIsIk5PX1NVQ0hfRklMRV9FUlJPUiIsIk5PVF9GT1VORCIsInJlbW92ZSIsInJlbW92ZUZhaWxlZCIsImVycm9yIiwiZ2V0QmFkRGF0YSIsIm1lc3NhZ2UiLCJkZWxldGVQYWNrYWdlIiwiUEFDS0FHRV9GSUxFX05BTUUiLCJhdHRhY2htZW50cyIsIk9iamVjdCIsImtleXMiLCJfYXR0YWNobWVudHMiLCJfZGVsZXRlQXR0YWNobWVudHMiLCJ1cGRhdGVWZXJzaW9ucyIsInBhY2thZ2VJbmZvIiwiX3JlYWRDcmVhdGVQYWNrYWdlIiwicGFja2FnZUxvY2FsSnNvbiIsImNoYW5nZSIsInJlYWRtZSIsInZlcnNpb25JZCIsInZlcnNpb24iLCJjb250cmlidXRvcnMiLCJkaXN0IiwidGFyYmFsbCIsInVybE9iamVjdCIsIlVybE5vZGUiLCJwYXJzZSIsImZpbGVuYW1lIiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiX2Rpc3RmaWxlcyIsImhhc2giLCJ1cmwiLCJzaGEiLCJzaGFzdW0iLCJ1cExpbmsiLCJTeW1ib2wiLCJmb3IiLCJfdXBkYXRlVXBsaW5rVG9SZW1vdGVQcm90b2NvbCIsInRhZyIsIkRJU1RfVEFHUyIsInVwIiwiX3VwbGlua3MiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJuZWVkX2NoYW5nZSIsImV0YWciLCJmZXRjaGVkIiwiaXNFcXVhbCIsInRpbWUiLCJfd3JpdGVQYWNrYWdlIiwiYWRkVmVyc2lvbiIsIm1ldGFkYXRhIiwiX3VwZGF0ZVBhY2thZ2UiLCJjYiIsImhhc1ZlcnNpb24iLCJpc1N0cmluZyIsImVycm9yTWVzc2FnZSIsImdldEJhZFJlcXVlc3QiLCJjdXJyZW50RGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNyZWF0ZWQiLCJhZGQiLCJhZGRGYWlsZWQiLCJtZXJnZVRhZ3MiLCJwa2dOYW1lIiwidGFncyIsIl9nZXRWZXJzaW9uTm90Rm91bmQiLCJBUElfRVJST1IiLCJWRVJTSU9OX05PVF9FWElTVCIsIl9nZXRGaWxlTm90QXZhaWxhYmxlIiwiY2hhbmdlUGFja2FnZSIsImluY29taW5nUGtnIiwicmV2aXNpb24iLCJsb2NhbERhdGEiLCJpbmNvbWluZ1ZlcnNpb24iLCJpbmZvIiwiZmlsZSIsImluY29taW5nRGVwcmVjYXRlZCIsImRlcHJlY2F0ZWQiLCJtb2RpZmllZCIsIlVTRVJTIiwicmVtb3ZlVGFyYmFsbCIsImFkZFRhcmJhbGwiLCJsZW5ndGgiLCJzaGFPbmVIYXNoIiwidXBsb2FkU3RyZWFtIiwiVXBsb2FkVGFyYmFsbCIsIl90cmFuc2Zvcm0iLCJhYm9ydCIsImRvbmUiLCJhcmdzIiwidXBkYXRlIiwiYXBwbGllZERhdGEiLCJhcHBseSIsInByb2Nlc3MiLCJuZXh0VGljayIsImVtaXQiLCJnZXRGb3JiaWRkZW4iLCJ3cml0ZVN0cmVhbSIsIndyaXRlVGFyYmFsbCIsIm9uIiwiZ2V0UGFja2FnZU1ldGFkYXRhIiwiX2VyciIsIl9yZXMiLCJ1cGRhdGVyIiwiZGlnZXN0IiwicGlwZSIsImdldFRhcmJhbGwiLCJfY3JlYXRlRmFpbHVyZVN0cmVhbVJlc3BvbnNlIiwiX3N0cmVhbVN1Y2Nlc3NSZWFkVGFyQmFsbCIsInN0cmVhbSIsIlJlYWRUYXJiYWxsIiwicmVhZFRhcmJhbGxTdHJlYW0iLCJyZWFkVGFyYmFsbCIsImU0MDQiLCJjb250ZW50IiwiX3JlYWRQYWNrYWdlIiwic2VhcmNoIiwic3RhcnRLZXkiLCJvcHRpb25zIiwib2JqZWN0TW9kZSIsIl9zZWFyY2hFYWNoUGFja2FnZSIsIml0ZW0iLCJwYXJzZUludCIsInJlc3VsdCIsInB1c2giLCJvbkVuZCIsImVuZCIsImdldFBhY2thZ2VTdG9yYWdlIiwiX2ludGVybmFsRXJyb3IiLCJvblBhY2thZ2UiLCJ3YXJuIiwidmFsaWRhdGVOYW1lIiwiX2NyZWF0ZU5ld1BhY2thZ2UiLCJnZXRJbnRlcm5hbEVycm9yIiwidXBkYXRlSGFuZGxlciIsInVwZGF0ZVBhY2thZ2UiLCJiaW5kIiwibm9ybWFsaXplUGFja2FnZSIsImpzb24iLCJzYXZlUGFja2FnZSIsIl9zZXREZWZhdWx0UmV2aXNpb24iLCJfcmV2IiwiREVGQVVMVF9SRVZJU0lPTiIsIl9kZWJ1ZyIsInVubGlua05leHQiLCJpc0VtcHR5IiwiYXR0YWNobWVudCIsInNoaWZ0IiwidXBMaW5rS2V5IiwidGFyYmFsbFVybCIsInVwbGlua1VybCIsInVwbGlua3MiLCJob3N0IiwicHJvdG9jb2wiLCJyZWdpc3RyeSIsImZvcm1hdCIsImdldFNlY3JldCIsInNlY3JldEtleSIsInNldFNlY3JldCIsImNoZWNrU2VjcmV0S2V5IiwiU3RvcmFnZSIsIl9sb2FkU3RvcmVQbHVnaW4iLCJMb2NhbERhdGFiYXNlIiwicGx1Z2luX3BhcmFtcyIsInBsdWdpbnMiLCJzdG9yZSIsInBsdWdpbiIsImhlYWQiLCJzYXZlVG9rZW4iLCJ0b2tlbiIsImlzRnVuY3Rpb24iLCJQcm9taXNlIiwicmVqZWN0IiwiZ2V0Q29kZSIsIlNFUlZJQ0VfVU5BVkFJTEFCTEUiLCJTVVBQT1JUX0VSUk9SUyIsIlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSIsImRlbGV0ZVRva2VuIiwidXNlciIsInRva2VuS2V5IiwicmVh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a00sT0FBVixDQUFrQjFMLHVCQUFZMkwsbUJBQTlCLEVBQW1EQywwQkFBZUMsd0JBQWxFLENBQWYsQ0FBUDtBQUNEOztBQUVELFdBQU8sS0FBSy9NLGFBQUwsQ0FBbUJ1TSxTQUFuQixDQUE2QkMsS0FBN0IsQ0FBUDtBQUNEOztBQUVNUSxFQUFBQSxXQUFXLENBQUNDLElBQUQsRUFBZUMsUUFBZixFQUErQztBQUMvRCxRQUFJMU0sZ0JBQUVpTSxVQUFGLENBQWEsS0FBS3pNLGFBQUwsQ0FBbUJnTixXQUFoQyxNQUFpRCxLQUFyRCxFQUE0RDtBQUMxRCxhQUFPTixPQUFPLENBQUNDLE1BQVIsQ0FBZWpNLGlCQUFVa00sT0FBVixDQUFrQjFMLHVCQUFZMkwsbUJBQTlCLEVBQW1EQywwQkFBZUMsd0JBQWxFLENBQWYsQ0FBUDtBQUNEOztBQUVELFdBQU8sS0FBSy9NLGFBQUwsQ0FBbUJnTixXQUFuQixDQUErQkMsSUFBL0IsRUFBcUNDLFFBQXJDLENBQVA7QUFDRDs7QUFFTUMsRUFBQUEsVUFBVSxDQUFDQyxNQUFELEVBQXdDO0FBQ3ZELFFBQUk1TSxnQkFBRWlNLFVBQUYsQ0FBYSxLQUFLek0sYUFBTCxDQUFtQm1OLFVBQWhDLE1BQWdELEtBQXBELEVBQTJEO0FBQ3pELGFBQU9ULE9BQU8sQ0FBQ0MsTUFBUixDQUFlak0saUJBQVVrTSxPQUFWLENBQWtCMUwsdUJBQVkyTCxtQkFBOUIsRUFBbURDLDBCQUFlQyx3QkFBbEUsQ0FBZixDQUFQO0FBQ0Q7O0FBRUQsV0FBTyxLQUFLL00sYUFBTCxDQUFtQm1OLFVBQW5CLENBQThCQyxNQUE5QixDQUFQO0FBQ0Q7O0FBdjBCb0M7O2VBMDBCeEJ4TixZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IFVybE5vZGUgZnJvbSAndXJsJztcbmltcG9ydCBidWlsRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBMb2NhbERhdGFiYXNlIGZyb20gJ0B2ZXJkYWNjaW8vbG9jYWwtc3RvcmFnZSc7XG5pbXBvcnQgeyBVcGxvYWRUYXJiYWxsLCBSZWFkVGFyYmFsbCB9IGZyb20gJ0B2ZXJkYWNjaW8vc3RyZWFtcyc7XG5pbXBvcnQge1xuICBUb2tlbixcbiAgVG9rZW5GaWx0ZXIsXG4gIFBhY2thZ2UsXG4gIENvbmZpZyxcbiAgSVVwbG9hZFRhcmJhbGwsXG4gIElSZWFkVGFyYmFsbCxcbiAgTWVyZ2VUYWdzLFxuICBWZXJzaW9uLFxuICBEaXN0RmlsZSxcbiAgQ2FsbGJhY2ssXG4gIExvZ2dlcixcbiAgSVBsdWdpblN0b3JhZ2UsXG4gIElQYWNrYWdlU3RvcmFnZSxcbiAgQXV0aG9yLFxuICBDYWxsYmFja0FjdGlvbixcbiAgb25TZWFyY2hQYWNrYWdlLFxuICBvbkVuZFNlYXJjaFBhY2thZ2UsXG4gIFN0b3JhZ2VVcGRhdGVDYWxsYmFjayxcbn0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQgeyBWZXJkYWNjaW9FcnJvciB9IGZyb20gJ0B2ZXJkYWNjaW8vY29tbW9ucy1hcGknO1xuaW1wb3J0IGxvYWRQbHVnaW4gZnJvbSAnLi4vbGliL3BsdWdpbi1sb2FkZXInO1xuaW1wb3J0IHsgSVN0b3JhZ2UsIFN0cmluZ1ZhbHVlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgRXJyb3JDb2RlLCBpc09iamVjdCwgZ2V0TGF0ZXN0VmVyc2lvbiwgdGFnVmVyc2lvbiwgdmFsaWRhdGVOYW1lIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVBhY2thZ2VUZW1wbGF0ZSwgbm9ybWFsaXplUGFja2FnZSwgZ2VuZXJhdGVSZXZpc2lvbiwgZ2V0TGF0ZXN0UmVhZG1lLCBjbGVhblVwUmVhZG1lLCBub3JtYWxpemVDb250cmlidXRvcnMgfSBmcm9tICcuL3N0b3JhZ2UtdXRpbHMnO1xuaW1wb3J0IHsgQVBJX0VSUk9SLCBESVNUX1RBR1MsIEhUVFBfU1RBVFVTLCBTVE9SQUdFLCBTVVBQT1JUX0VSUk9SUywgVVNFUlMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVUYXJiYWxsSGFzaCB9IGZyb20gJy4vY3J5cHRvLXV0aWxzJztcbmltcG9ydCB7IHByZXBhcmVTZWFyY2hQYWNrYWdlIH0gZnJvbSAnLi9zdG9yYWdlLXV0aWxzJztcblxuY29uc3QgZGVidWcgPSBidWlsRGVidWcoJ3ZlcmRhY2Npbzpsb2NhbC1zdG9yYWdlJyk7XG4vKipcbiAqIEltcGxlbWVudHMgU3RvcmFnZSBpbnRlcmZhY2UgKHNhbWUgZm9yIHN0b3JhZ2UuanMsIGxvY2FsLXN0b3JhZ2UuanMsIHVwLXN0b3JhZ2UuanMpLlxuICovXG5jbGFzcyBMb2NhbFN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIHB1YmxpYyBjb25maWc6IENvbmZpZztcbiAgcHVibGljIHN0b3JhZ2VQbHVnaW46IElQbHVnaW5TdG9yYWdlPENvbmZpZz47XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29uZmlnOiBDb25maWcsIGxvZ2dlcjogTG9nZ2VyKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zdG9yYWdlUGx1Z2luID0gdGhpcy5fbG9hZFN0b3JhZ2UoY29uZmlnLCBsb2dnZXIpO1xuICB9XG5cbiAgcHVibGljIGFkZFBhY2thZ2UobmFtZTogc3RyaW5nLCBwa2c6IFBhY2thZ2UsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2U6IGFueSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcblxuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCd0aGlzIHBhY2thZ2UgY2Fubm90IGJlIGFkZGVkJykpO1xuICAgIH1cblxuICAgIHN0b3JhZ2UuY3JlYXRlUGFja2FnZShuYW1lLCBnZW5lcmF0ZVBhY2thZ2VUZW1wbGF0ZShuYW1lKSwgKGVycikgPT4ge1xuICAgICAgLy8gRklYTUU6IGl0IHdpbGwgYmUgZml4ZWQgaGVyZSBodHRwczovL2dpdGh1Yi5jb20vdmVyZGFjY2lvL3ZlcmRhY2Npby9wdWxsLzEzNjBcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmIChfLmlzTnVsbChlcnIpID09PSBmYWxzZSAmJiAoZXJyLmNvZGUgPT09IFNUT1JBR0UuRklMRV9FWElTVF9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuQ09ORkxJQ1QpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0Q29uZmxpY3QoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhdGVzdCA9IGdldExhdGVzdFZlcnNpb24ocGtnKTtcbiAgICAgIGlmIChfLmlzTmlsKGxhdGVzdCkgPT09IGZhbHNlICYmIHBrZy52ZXJzaW9uc1tsYXRlc3RdKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBwa2cudmVyc2lvbnNbbGF0ZXN0XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBwYWNrYWdlLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHB1YmxpYyByZW1vdmVQYWNrYWdlKG5hbWU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogYW55ID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuICAgIGRlYnVnKCdbc3RvcmFnZV0gcmVtb3ZpbmcgcGFja2FnZSAlbycsIG5hbWUpO1xuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKCkpO1xuICAgIH1cblxuICAgIHN0b3JhZ2UucmVhZFBhY2thZ2UobmFtZSwgKGVyciwgZGF0YTogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKF8uaXNOaWwoZXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLk5PX1NVQ0hfRklMRV9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IG5vcm1hbGl6ZVBhY2thZ2UoZGF0YSk7XG5cbiAgICAgIHRoaXMuc3RvcmFnZVBsdWdpbi5yZW1vdmUobmFtZSwgKHJlbW92ZUZhaWxlZDogRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHJlbW92ZUZhaWxlZCkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBoYXBwZW4gd2hlbiBkYXRhYmFzZSBpcyBsb2NrZWRcbiAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcih7IG5hbWUgfSwgYFtzdG9yYWdlL3JlbW92ZVBhY2thZ2VdIHRoZSBkYXRhYmFzZSBpcyBsb2NrZWQsIHJlbW92ZWQgaGFzIGZhaWxlZCBmb3IgQHtuYW1lfWApO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0QmFkRGF0YShyZW1vdmVGYWlsZWQubWVzc2FnZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmFnZS5kZWxldGVQYWNrYWdlKFNUT1JBR0UuUEFDS0FHRV9GSUxFX05BTUUsIChlcnIpOiB2b2lkID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXR0YWNobWVudHMgPSBPYmplY3Qua2V5cyhkYXRhLl9hdHRhY2htZW50cyk7XG5cbiAgICAgICAgICB0aGlzLl9kZWxldGVBdHRhY2htZW50cyhzdG9yYWdlLCBhdHRhY2htZW50cywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplIHJlbW90ZSBwYWNrYWdlIGluZm8gd2l0aCB0aGUgbG9jYWwgb25lXG4gICAqIEBwYXJhbSB7Kn0gbmFtZVxuICAgKiBAcGFyYW0geyp9IHBhY2thZ2VJbmZvXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVWZXJzaW9ucyhuYW1lOiBzdHJpbmcsIHBhY2thZ2VJbmZvOiBQYWNrYWdlLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLl9yZWFkQ3JlYXRlUGFja2FnZShuYW1lLCAoZXJyLCBwYWNrYWdlTG9jYWxKc29uKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY2hhbmdlID0gZmFsc2U7XG4gICAgICAvLyB1cGRhdGluZyByZWFkbWVcbiAgICAgIHBhY2thZ2VMb2NhbEpzb24ucmVhZG1lID0gZ2V0TGF0ZXN0UmVhZG1lKHBhY2thZ2VJbmZvKTtcbiAgICAgIGlmIChwYWNrYWdlSW5mby5yZWFkbWUgIT09IHBhY2thZ2VMb2NhbEpzb24ucmVhZG1lKSB7XG4gICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZlcnNpb25JZCBpbiBwYWNrYWdlSW5mby52ZXJzaW9ucykge1xuICAgICAgICBpZiAoXy5pc05pbChwYWNrYWdlTG9jYWxKc29uLnZlcnNpb25zW3ZlcnNpb25JZF0pKSB7XG4gICAgICAgICAgbGV0IHZlcnNpb24gPSBwYWNrYWdlSW5mby52ZXJzaW9uc1t2ZXJzaW9uSWRdO1xuXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qga2VlcCByZWFkbWUgZm9yIHBhY2thZ2UgdmVyc2lvbnMsXG4gICAgICAgICAgLy8gb25seSBvbmUgcmVhZG1lIHBlciBwYWNrYWdlXG4gICAgICAgICAgdmVyc2lvbiA9IGNsZWFuVXBSZWFkbWUodmVyc2lvbik7XG4gICAgICAgICAgdmVyc2lvbi5jb250cmlidXRvcnMgPSBub3JtYWxpemVDb250cmlidXRvcnModmVyc2lvbi5jb250cmlidXRvcnMgYXMgQXV0aG9yW10pO1xuXG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICBwYWNrYWdlTG9jYWxKc29uLnZlcnNpb25zW3ZlcnNpb25JZF0gPSB2ZXJzaW9uO1xuXG4gICAgICAgICAgaWYgKHZlcnNpb24uZGlzdCAmJiB2ZXJzaW9uLmRpc3QudGFyYmFsbCkge1xuICAgICAgICAgICAgY29uc3QgdXJsT2JqZWN0OiBhbnkgPSBVcmxOb2RlLnBhcnNlKHZlcnNpb24uZGlzdC50YXJiYWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL14uKlxcLy8sICcnKTtcblxuICAgICAgICAgICAgLy8gd2UgZG8gTk9UIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgcmVjb3Jkc1xuICAgICAgICAgICAgaWYgKF8uaXNOaWwocGFja2FnZUxvY2FsSnNvbi5fZGlzdGZpbGVzW2ZpbGVuYW1lXSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgaGFzaDogRGlzdEZpbGUgPSAocGFja2FnZUxvY2FsSnNvbi5fZGlzdGZpbGVzW2ZpbGVuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHZlcnNpb24uZGlzdC50YXJiYWxsLFxuICAgICAgICAgICAgICAgIHNoYTogdmVyc2lvbi5kaXN0LnNoYXN1bSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8qIGVzbGludCBzcGFjZWQtY29tbWVudDogMCAqL1xuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgICAgIGNvbnN0IHVwTGluazogc3RyaW5nID0gdmVyc2lvbltTeW1ib2wuZm9yKCdfX3ZlcmRhY2Npb191cGxpbmsnKV07XG5cbiAgICAgICAgICAgICAgaWYgKF8uaXNOaWwodXBMaW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVVcGxpbmtUb1JlbW90ZVByb3RvY29sKGhhc2gsIHVwTGluayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0YWcgaW4gcGFja2FnZUluZm9bRElTVF9UQUdTXSkge1xuICAgICAgICBpZiAoIXBhY2thZ2VMb2NhbEpzb25bRElTVF9UQUdTXVt0YWddIHx8IHBhY2thZ2VMb2NhbEpzb25bRElTVF9UQUdTXVt0YWddICE9PSBwYWNrYWdlSW5mb1tESVNUX1RBR1NdW3RhZ10pIHtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgIHBhY2thZ2VMb2NhbEpzb25bRElTVF9UQUdTXVt0YWddID0gcGFja2FnZUluZm9bRElTVF9UQUdTXVt0YWddO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgdXAgaW4gcGFja2FnZUluZm8uX3VwbGlua3MpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYWNrYWdlSW5mby5fdXBsaW5rcywgdXApKSB7XG4gICAgICAgICAgY29uc3QgbmVlZF9jaGFuZ2UgPVxuICAgICAgICAgICAgIWlzT2JqZWN0KHBhY2thZ2VMb2NhbEpzb24uX3VwbGlua3NbdXBdKSB8fFxuICAgICAgICAgICAgcGFja2FnZUluZm8uX3VwbGlua3NbdXBdLmV0YWcgIT09IHBhY2thZ2VMb2NhbEpzb24uX3VwbGlua3NbdXBdLmV0YWcgfHxcbiAgICAgICAgICAgIHBhY2thZ2VJbmZvLl91cGxpbmtzW3VwXS5mZXRjaGVkICE9PSBwYWNrYWdlTG9jYWxKc29uLl91cGxpbmtzW3VwXS5mZXRjaGVkO1xuXG4gICAgICAgICAgaWYgKG5lZWRfY2hhbmdlKSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgcGFja2FnZUxvY2FsSnNvbi5fdXBsaW5rc1t1cF0gPSBwYWNrYWdlSW5mby5fdXBsaW5rc1t1cF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgndGltZScgaW4gcGFja2FnZUluZm8gJiYgIV8uaXNFcXVhbChwYWNrYWdlTG9jYWxKc29uLnRpbWUsIHBhY2thZ2VJbmZvLnRpbWUpKSB7XG4gICAgICAgIHBhY2thZ2VMb2NhbEpzb24udGltZSA9IHBhY2thZ2VJbmZvLnRpbWU7XG4gICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgZGVidWcoJ3VwZGF0aW5nIHBhY2thZ2UgJW8gaW5mbycsIG5hbWUpO1xuICAgICAgICB0aGlzLl93cml0ZVBhY2thZ2UobmFtZSwgcGFja2FnZUxvY2FsSnNvbiwgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgICAgIGNhbGxiYWNrKGVyciwgcGFja2FnZUxvY2FsSnNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcGFja2FnZUxvY2FsSnNvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHZlcnNpb24gdG8gYSBwcmV2aW91cyBsb2NhbCBwYWNrYWdlLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7Kn0gbWV0YWRhdGFcbiAgICogQHBhcmFtIHsqfSB0YWdcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGFkZFZlcnNpb24obmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcsIG1ldGFkYXRhOiBWZXJzaW9uLCB0YWc6IFN0cmluZ1ZhbHVlLCBjYWxsYmFjazogQ2FsbGJhY2tBY3Rpb24pOiB2b2lkIHtcbiAgICB0aGlzLl91cGRhdGVQYWNrYWdlKFxuICAgICAgbmFtZSxcbiAgICAgIChkYXRhLCBjYjogQ2FsbGJhY2spOiB2b2lkID0+IHtcbiAgICAgICAgLy8ga2VlcCBvbmx5IG9uZSByZWFkbWUgcGVyIHBhY2thZ2VcbiAgICAgICAgZGF0YS5yZWFkbWUgPSBtZXRhZGF0YS5yZWFkbWU7XG5cbiAgICAgICAgLy8gVE9ETzogbG9kYXNoIHJlbW92ZVxuICAgICAgICBtZXRhZGF0YSA9IGNsZWFuVXBSZWFkbWUobWV0YWRhdGEpO1xuICAgICAgICBtZXRhZGF0YS5jb250cmlidXRvcnMgPSBub3JtYWxpemVDb250cmlidXRvcnMobWV0YWRhdGEuY29udHJpYnV0b3JzIGFzIEF1dGhvcltdKTtcblxuICAgICAgICBjb25zdCBoYXNWZXJzaW9uID0gZGF0YS52ZXJzaW9uc1t2ZXJzaW9uXSAhPSBudWxsO1xuICAgICAgICBpZiAoaGFzVmVyc2lvbikge1xuICAgICAgICAgIHJldHVybiBjYihFcnJvckNvZGUuZ2V0Q29uZmxpY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB1cGxvYWRlZCB0YXJiYWxsIGhhcyBhIGRpZmZlcmVudCBzaGFzdW0sIGl0J3MgdmVyeSBsaWtlbHkgdGhhdCB3ZSBoYXZlIHNvbWUga2luZCBvZiBlcnJvclxuICAgICAgICBpZiAoaXNPYmplY3QobWV0YWRhdGEuZGlzdCkgJiYgXy5pc1N0cmluZyhtZXRhZGF0YS5kaXN0LnRhcmJhbGwpKSB7XG4gICAgICAgICAgY29uc3QgdGFyYmFsbCA9IG1ldGFkYXRhLmRpc3QudGFyYmFsbC5yZXBsYWNlKC8uKlxcLy8sICcnKTtcblxuICAgICAgICAgIGlmIChpc09iamVjdChkYXRhLl9hdHRhY2htZW50c1t0YXJiYWxsXSkpIHtcbiAgICAgICAgICAgIGlmIChfLmlzTmlsKGRhdGEuX2F0dGFjaG1lbnRzW3RhcmJhbGxdLnNoYXN1bSkgPT09IGZhbHNlICYmIF8uaXNOaWwobWV0YWRhdGEuZGlzdC5zaGFzdW0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAoZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0uc2hhc3VtICE9IG1ldGFkYXRhLmRpc3Quc2hhc3VtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYHNoYXN1bSBlcnJvciwgJHtkYXRhLl9hdHRhY2htZW50c1t0YXJiYWxsXS5zaGFzdW19ICE9ICR7bWV0YWRhdGEuZGlzdC5zaGFzdW19YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoRXJyb3JDb2RlLmdldEJhZFJlcXVlc3QoZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIC8vIHNvbWUgb2xkIHN0b3JhZ2UgZG8gbm90IGhhdmUgdGhpcyBmaWVsZCAjNzQwXG4gICAgICAgICAgICBpZiAoXy5pc05pbChkYXRhLnRpbWUpKSB7XG4gICAgICAgICAgICAgIGRhdGEudGltZSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLnRpbWVbJ21vZGlmaWVkJ10gPSBjdXJyZW50RGF0ZTtcblxuICAgICAgICAgICAgaWYgKCdjcmVhdGVkJyBpbiBkYXRhLnRpbWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGRhdGEudGltZS5jcmVhdGVkID0gY3VycmVudERhdGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEudGltZVt2ZXJzaW9uXSA9IGN1cnJlbnREYXRlO1xuICAgICAgICAgICAgZGF0YS5fYXR0YWNobWVudHNbdGFyYmFsbF0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS52ZXJzaW9uc1t2ZXJzaW9uXSA9IG1ldGFkYXRhO1xuICAgICAgICB0YWdWZXJzaW9uKGRhdGEsIHZlcnNpb24sIHRhZyk7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlUGx1Z2luLmFkZChuYW1lLCAoYWRkRmFpbGVkKTogdm9pZCA9PiB7XG4gICAgICAgICAgaWYgKGFkZEZhaWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKEVycm9yQ29kZS5nZXRCYWREYXRhKGFkZEZhaWxlZC5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGEgbmV3IGxpc3Qgb2YgdGFncyBmb3IgYSBsb2NhbCBwYWNrYWdlcyB3aXRoIHRoZSBleGlzdGluZyBvbmUuXG4gICAqIEBwYXJhbSB7Kn0gcGtnTmFtZVxuICAgKiBAcGFyYW0geyp9IHRhZ3NcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIG1lcmdlVGFncyhwa2dOYW1lOiBzdHJpbmcsIHRhZ3M6IE1lcmdlVGFncywgY2FsbGJhY2s6IENhbGxiYWNrQWN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5fdXBkYXRlUGFja2FnZShcbiAgICAgIHBrZ05hbWUsXG4gICAgICAoZGF0YSwgY2IpOiB2b2lkID0+IHtcbiAgICAgICAgLyogZXNsaW50IGd1YXJkLWZvci1pbjogMCAqL1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBpbiB0YWdzKSB7XG4gICAgICAgICAgLy8gdGhpcyBoYW5kbGUgZGlzdC10YWcgcm0gY29tbWFuZFxuICAgICAgICAgIGlmIChfLmlzTnVsbCh0YWdzW3RhZ10pKSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0YVtESVNUX1RBR1NdW3RhZ107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXy5pc05pbChkYXRhLnZlcnNpb25zW3RhZ3NbdGFnXV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IodGhpcy5fZ2V0VmVyc2lvbk5vdEZvdW5kKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2ZXJzaW9uOiBzdHJpbmcgPSB0YWdzW3RhZ107XG4gICAgICAgICAgdGFnVmVyc2lvbihkYXRhLCB2ZXJzaW9uLCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGNiKG51bGwpO1xuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdmVyc2lvbiBub3QgZm91bmRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0VmVyc2lvbk5vdEZvdW5kKCk6IFZlcmRhY2Npb0Vycm9yIHtcbiAgICByZXR1cm4gRXJyb3JDb2RlLmdldE5vdEZvdW5kKEFQSV9FUlJPUi5WRVJTSU9OX05PVF9FWElTVCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGZpbGUgbm8gYXZhaWxhYmxlXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX2dldEZpbGVOb3RBdmFpbGFibGUoKTogVmVyZGFjY2lvRXJyb3Ige1xuICAgIHJldHVybiBFcnJvckNvZGUuZ2V0Tm90Rm91bmQoJ25vIHN1Y2ggZmlsZSBhdmFpbGFibGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhY2thZ2UgbWV0YWRhdGEsIHRhZ3MgYW5kIGF0dGFjaG1lbnRzICh0YXJiYWxscykuXG4gICAqIE5vdGU6IEN1cnJlbnRseSBzdXBwb3J0cyB1bnB1Ymxpc2hpbmcgYW5kIGRlcHJlY2F0aW9uLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBpbmNvbWluZ1BrZ1xuICAgKiBAcGFyYW0geyp9IHJldmlzaW9uXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBwdWJsaWMgY2hhbmdlUGFja2FnZShuYW1lOiBzdHJpbmcsIGluY29taW5nUGtnOiBQYWNrYWdlLCByZXZpc2lvbjogc3RyaW5nIHwgdm9pZCwgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgaWYgKCFpc09iamVjdChpbmNvbWluZ1BrZy52ZXJzaW9ucykgfHwgIWlzT2JqZWN0KGluY29taW5nUGtnW0RJU1RfVEFHU10pKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcih7IG5hbWUgfSwgYGNoYW5nZVBhY2thZ2UgYmFkIGRhdGEgZm9yIEB7bmFtZX1gKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0QmFkRGF0YSgpKTtcbiAgICB9XG4gICAgZGVidWcoJ2NoYW5nZVBhY2thZ2UgdWRhcHRpbmcgcGFja2FnZSBmb3IgJW8nLCBuYW1lKTtcbiAgICB0aGlzLl91cGRhdGVQYWNrYWdlKFxuICAgICAgbmFtZSxcbiAgICAgIChsb2NhbERhdGE6IFBhY2thZ2UsIGNiOiBDYWxsYmFja0FjdGlvbik6IHZvaWQgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHZlcnNpb24gaW4gbG9jYWxEYXRhLnZlcnNpb25zKSB7XG4gICAgICAgICAgY29uc3QgaW5jb21pbmdWZXJzaW9uID0gaW5jb21pbmdQa2cudmVyc2lvbnNbdmVyc2lvbl07XG4gICAgICAgICAgaWYgKF8uaXNOaWwoaW5jb21pbmdWZXJzaW9uKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyh7IG5hbWU6IG5hbWUsIHZlcnNpb246IHZlcnNpb24gfSwgJ3VucHVibGlzaGluZyBAe25hbWV9QEB7dmVyc2lvbn0nKTtcblxuICAgICAgICAgICAgLy8gRklYTUU6IEkgcHJlZmVyIHJldHVybiBhIG5ldyBvYmplY3QgcmF0aGVyIG11dGF0ZSB0aGUgbWV0YWRhdGFcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbERhdGEudmVyc2lvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICBkZWxldGUgbG9jYWxEYXRhLnRpbWUhW3ZlcnNpb25dO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgaW4gbG9jYWxEYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgICAgICAgICBpZiAobG9jYWxEYXRhLl9hdHRhY2htZW50c1tmaWxlXS52ZXJzaW9uID09PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsRGF0YS5fYXR0YWNobWVudHNbZmlsZV0udmVyc2lvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluY29taW5nVmVyc2lvbiwgJ2RlcHJlY2F0ZWQnKSkge1xuICAgICAgICAgICAgY29uc3QgaW5jb21pbmdEZXByZWNhdGVkID0gaW5jb21pbmdWZXJzaW9uLmRlcHJlY2F0ZWQ7XG4gICAgICAgICAgICBpZiAoaW5jb21pbmdEZXByZWNhdGVkICE9IGxvY2FsRGF0YS52ZXJzaW9uc1t2ZXJzaW9uXS5kZXByZWNhdGVkKSB7XG4gICAgICAgICAgICAgIGlmICghaW5jb21pbmdEZXByZWNhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyh7IG5hbWU6IG5hbWUsIHZlcnNpb246IHZlcnNpb24gfSwgJ3VuZGVwcmVjYXRpbmcgQHtuYW1lfUBAe3ZlcnNpb259Jyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsRGF0YS52ZXJzaW9uc1t2ZXJzaW9uXS5kZXByZWNhdGVkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oeyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uIH0sICdkZXByZWNhdGluZyBAe25hbWV9QEB7dmVyc2lvbn0nKTtcbiAgICAgICAgICAgICAgICBsb2NhbERhdGEudmVyc2lvbnNbdmVyc2lvbl0uZGVwcmVjYXRlZCA9IGluY29taW5nRGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsb2NhbERhdGEudGltZSEubW9kaWZpZWQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxEYXRhW1VTRVJTXSA9IGluY29taW5nUGtnW1VTRVJTXTtcbiAgICAgICAgbG9jYWxEYXRhW0RJU1RfVEFHU10gPSBpbmNvbWluZ1BrZ1tESVNUX1RBR1NdO1xuICAgICAgICBjYihudWxsKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHRhcmJhbGwuXG4gICAqIEBwYXJhbSB7Kn0gbmFtZVxuICAgKiBAcGFyYW0geyp9IGZpbGVuYW1lXG4gICAqIEBwYXJhbSB7Kn0gcmV2aXNpb25cbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIHJlbW92ZVRhcmJhbGwobmFtZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nLCByZXZpc2lvbjogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2tBY3Rpb24pOiB2b2lkIHtcbiAgICBhc3NlcnQodmFsaWRhdGVOYW1lKGZpbGVuYW1lKSk7XG5cbiAgICB0aGlzLl91cGRhdGVQYWNrYWdlKFxuICAgICAgbmFtZSxcbiAgICAgIChkYXRhLCBjYik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoZGF0YS5fYXR0YWNobWVudHNbZmlsZW5hbWVdKSB7XG4gICAgICAgICAgZGVsZXRlIGRhdGEuX2F0dGFjaG1lbnRzW2ZpbGVuYW1lXTtcbiAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYih0aGlzLl9nZXRGaWxlTm90QXZhaWxhYmxlKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKGVycjogVmVyZGFjY2lvRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLl9nZXRMb2NhbFN0b3JhZ2UobmFtZSk7XG5cbiAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICBzdG9yYWdlLmRlbGV0ZVBhY2thZ2UoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdGFyYmFsbC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHB1YmxpYyBhZGRUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IElVcGxvYWRUYXJiYWxsIHtcbiAgICBhc3NlcnQodmFsaWRhdGVOYW1lKGZpbGVuYW1lKSk7XG5cbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBjb25zdCBzaGFPbmVIYXNoID0gY3JlYXRlVGFyYmFsbEhhc2goKTtcbiAgICBjb25zdCB1cGxvYWRTdHJlYW06IElVcGxvYWRUYXJiYWxsID0gbmV3IFVwbG9hZFRhcmJhbGwoe30pO1xuICAgIGNvbnN0IF90cmFuc2Zvcm0gPSB1cGxvYWRTdHJlYW0uX3RyYW5zZm9ybTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuXG4gICAgdXBsb2FkU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge307XG4gICAgdXBsb2FkU3RyZWFtLmRvbmUgPSBmdW5jdGlvbiAoKTogdm9pZCB7fTtcblxuICAgIHVwbG9hZFN0cmVhbS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIC4uLmFyZ3MpOiB2b2lkIHtcbiAgICAgIHNoYU9uZUhhc2gudXBkYXRlKGRhdGEpO1xuICAgICAgLy8gbWVhc3VyZSB0aGUgbGVuZ3RoIGZvciB2YWxpZGF0aW9uIHJlYXNvbnNcbiAgICAgIGxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgIGNvbnN0IGFwcGxpZWREYXRhID0gW2RhdGEsIC4uLmFyZ3NdO1xuICAgICAgLy8gRklYTUU6IG5vdCBzdXJlIGFib3V0IHRoaXMgYXBwcm9hY2gsIHRzYyBjb21wbGFpbnNcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIF90cmFuc2Zvcm0uYXBwbHkodXBsb2FkU3RyZWFtLCBhcHBsaWVkRGF0YSk7XG4gICAgfTtcblxuICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKTogdm9pZCA9PiB7XG4gICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXRGb3JiaWRkZW4oKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGxvYWRTdHJlYW07XG4gICAgfVxuXG4gICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpOiB2b2lkID0+IHtcbiAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ2Vycm9yJywgXCJjYW4ndCB1cGxvYWQgdGhpcyBwYWNrYWdlXCIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdXBsb2FkU3RyZWFtO1xuICAgIH1cblxuICAgIGNvbnN0IHdyaXRlU3RyZWFtOiBJVXBsb2FkVGFyYmFsbCA9IHN0b3JhZ2Uud3JpdGVUYXJiYWxsKGZpbGVuYW1lKTtcblxuICAgIHdyaXRlU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gU1RPUkFHRS5GSUxFX0VYSVNUX0VSUk9SIHx8IGVyci5jb2RlID09PSBIVFRQX1NUQVRVUy5DT05GTElDVCkge1xuICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0Q29uZmxpY3QoKSk7XG4gICAgICAgIHVwbG9hZFN0cmVhbS5hYm9ydCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLk5PX1NVQ0hfRklMRV9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHBhY2thZ2UgZXhpc3RzIHRvIHRocm93IGFuIGFwcHJvcHJpYXRlIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5nZXRQYWNrYWdlTWV0YWRhdGEobmFtZSwgZnVuY3Rpb24gKF9lcnI6IFZlcmRhY2Npb0Vycm9yLCBfcmVzOiBQYWNrYWdlKTogdm9pZCB7XG4gICAgICAgICAgaWYgKF9lcnIpIHtcbiAgICAgICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIF9lcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGxvYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgd3JpdGVTdHJlYW0ub24oJ29wZW4nLCBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAvLyByZS1lbWl0dGluZyBvcGVuIGJlY2F1c2UgaXQncyBoYW5kbGVkIGluIHN0b3JhZ2UuanNcbiAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdvcGVuJyk7XG4gICAgfSk7XG5cbiAgICB3cml0ZVN0cmVhbS5vbignc3VjY2VzcycsICgpOiB2b2lkID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBhY2thZ2UoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZXIoZGF0YSwgY2IpOiB2b2lkIHtcbiAgICAgICAgICBkYXRhLl9hdHRhY2htZW50c1tmaWxlbmFtZV0gPSB7XG4gICAgICAgICAgICBzaGFzdW06IHNoYU9uZUhhc2guZGlnZXN0KCdoZXgnKSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBsb2FkU3RyZWFtLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB1cGxvYWRTdHJlYW0uYWJvcnQgPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICB3cml0ZVN0cmVhbS5hYm9ydCgpO1xuICAgIH07XG5cbiAgICB1cGxvYWRTdHJlYW0uZG9uZSA9IGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHVwbG9hZFN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXRCYWREYXRhKCdyZWZ1c2luZyB0byBhY2NlcHQgemVyby1sZW5ndGggZmlsZScpKTtcbiAgICAgICAgd3JpdGVTdHJlYW0uYWJvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlU3RyZWFtLmRvbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdXBsb2FkU3RyZWFtLnBpcGUod3JpdGVTdHJlYW0pO1xuXG4gICAgcmV0dXJuIHVwbG9hZFN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0YXJiYWxsLlxuICAgKiBAcGFyYW0geyp9IG5hbWVcbiAgICogQHBhcmFtIHsqfSBmaWxlbmFtZVxuICAgKiBAcmV0dXJuIHtSZWFkVGFyYmFsbH1cbiAgICovXG4gIHB1YmxpYyBnZXRUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IElSZWFkVGFyYmFsbCB7XG4gICAgYXNzZXJ0KHZhbGlkYXRlTmFtZShmaWxlbmFtZSkpO1xuXG4gICAgY29uc3Qgc3RvcmFnZTogSVBhY2thZ2VTdG9yYWdlID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuXG4gICAgaWYgKF8uaXNOaWwoc3RvcmFnZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVGYWlsdXJlU3RyZWFtUmVzcG9uc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtU3VjY2Vzc1JlYWRUYXJCYWxsKHN0b3JhZ2UsIGZpbGVuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzdHJlYW0gdGhhdCBlbWl0cyBhIHJlYWQgZmFpbHVyZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7UmVhZFRhcmJhbGx9XG4gICAqL1xuICBwcml2YXRlIF9jcmVhdGVGYWlsdXJlU3RyZWFtUmVzcG9uc2UoKTogSVJlYWRUYXJiYWxsIHtcbiAgICBjb25zdCBzdHJlYW06IElSZWFkVGFyYmFsbCA9IG5ldyBSZWFkVGFyYmFsbCh7fSk7XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpOiB2b2lkID0+IHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIHRoaXMuX2dldEZpbGVOb3RBdmFpbGFibGUoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzdHJlYW0gdGhhdCBlbWl0cyB0aGUgdGFyYmFsbCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtSZWFkVGFyYmFsbH1cbiAgICovXG4gIHByaXZhdGUgX3N0cmVhbVN1Y2Nlc3NSZWFkVGFyQmFsbChzdG9yYWdlOiBhbnksIGZpbGVuYW1lOiBzdHJpbmcpOiBJUmVhZFRhcmJhbGwge1xuICAgIGNvbnN0IHN0cmVhbTogSVJlYWRUYXJiYWxsID0gbmV3IFJlYWRUYXJiYWxsKHt9KTtcbiAgICBjb25zdCByZWFkVGFyYmFsbFN0cmVhbSA9IHN0b3JhZ2UucmVhZFRhcmJhbGwoZmlsZW5hbWUpO1xuICAgIGNvbnN0IGU0MDQgPSBFcnJvckNvZGUuZ2V0Tm90Rm91bmQ7XG5cbiAgICBzdHJlYW0uYWJvcnQgPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICBpZiAoXy5pc05pbChyZWFkVGFyYmFsbFN0cmVhbSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlYWRUYXJiYWxsU3RyZWFtLmFib3J0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlYWRUYXJiYWxsU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gU1RPUkFHRS5OT19TVUNIX0ZJTEVfRVJST1IgfHwgZXJyLmNvZGUgPT09IEhUVFBfU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlNDA0KCdubyBzdWNoIGZpbGUgYXZhaWxhYmxlJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWRUYXJiYWxsU3RyZWFtLm9uKCdjb250ZW50LWxlbmd0aCcsIGZ1bmN0aW9uIChjb250ZW50KTogdm9pZCB7XG4gICAgICBzdHJlYW0uZW1pdCgnY29udGVudC1sZW5ndGgnLCBjb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJlYWRUYXJiYWxsU3RyZWFtLm9uKCdvcGVuJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgLy8gcmUtZW1pdHRpbmcgb3BlbiBiZWNhdXNlIGl0J3MgaGFuZGxlZCBpbiBzdG9yYWdlLmpzXG4gICAgICBzdHJlYW0uZW1pdCgnb3BlbicpO1xuICAgICAgcmVhZFRhcmJhbGxTdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIHBhY2thZ2UgYnkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBwdWJsaWMgZ2V0UGFja2FnZU1ldGFkYXRhKG5hbWU6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrID0gKCk6IHZvaWQgPT4ge30pOiB2b2lkIHtcbiAgICBjb25zdCBzdG9yYWdlOiBJUGFja2FnZVN0b3JhZ2UgPSB0aGlzLl9nZXRMb2NhbFN0b3JhZ2UobmFtZSk7XG4gICAgaWYgKF8uaXNOaWwoc3RvcmFnZSkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0Tm90Rm91bmQoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZFBhY2thZ2UobmFtZSwgc3RvcmFnZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBhIGxvY2FsIHBhY2thZ2UuXG4gICAqIEBwYXJhbSB7Kn0gc3RhcnRLZXlcbiAgICogQHBhcmFtIHsqfSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgcHVibGljIHNlYXJjaChzdGFydEtleTogc3RyaW5nLCBvcHRpb25zOiBhbnkpOiBJUmVhZFRhcmJhbGwge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkVGFyYmFsbCh7IG9iamVjdE1vZGU6IHRydWUgfSk7XG5cbiAgICB0aGlzLl9zZWFyY2hFYWNoUGFja2FnZShcbiAgICAgIChpdGVtOiBQYWNrYWdlLCBjYjogQ2FsbGJhY2tBY3Rpb24pOiB2b2lkID0+IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoaXRlbS50aW1lID4gcGFyc2VJbnQoc3RhcnRLZXksIDEwKSkge1xuICAgICAgICAgIHRoaXMuZ2V0UGFja2FnZU1ldGFkYXRhKGl0ZW0ubmFtZSwgKGVycjogVmVyZGFjY2lvRXJyb3IsIGRhdGE6IFBhY2thZ2UpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBuZXcgRGF0ZShpdGVtLnRpbWUpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcmVwYXJlU2VhcmNoUGFja2FnZShkYXRhLCB0aW1lKTtcbiAgICAgICAgICAgIGlmIChfLmlzTmlsKHJlc3VsdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIG9uRW5kKGVycik6IHZvaWQge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmVuZCgpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGEgd3JhcHBlciB0aGF0IHByb3ZpZGUgYWNjZXNzIHRvIHRoZSBwYWNrYWdlIGxvY2F0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGtnTmFtZSBwYWNrYWdlIG5hbWUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHByaXZhdGUgX2dldExvY2FsU3RvcmFnZShwa2dOYW1lOiBzdHJpbmcpOiBJUGFja2FnZVN0b3JhZ2Uge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQbHVnaW4uZ2V0UGFja2FnZVN0b3JhZ2UocGtnTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIGpzb24gZmlsZSBmcm9tIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdG9yYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwcml2YXRlIF9yZWFkUGFja2FnZShuYW1lOiBzdHJpbmcsIHN0b3JhZ2U6IGFueSwgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgc3RvcmFnZS5yZWFkUGFja2FnZShuYW1lLCAoZXJyLCByZXN1bHQpOiB2b2lkID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBTVE9SQUdFLk5PX1NVQ0hfRklMRV9FUlJPUiB8fCBlcnIuY29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5faW50ZXJuYWxFcnJvcihlcnIsIFNUT1JBR0UuUEFDS0FHRV9GSUxFX05BTUUsICdlcnJvciByZWFkaW5nJykpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhlcnIsIG5vcm1hbGl6ZVBhY2thZ2UocmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2Fsa3MgdGhyb3VnaCBlYWNoIHBhY2thZ2UgYW5kIGNhbGxzIGBvbl9wYWNrYWdlYCBvbiB0aGVtLlxuICAgKiBAcGFyYW0geyp9IG9uUGFja2FnZVxuICAgKiBAcGFyYW0geyp9IG9uRW5kXG4gICAqL1xuICBwcml2YXRlIF9zZWFyY2hFYWNoUGFja2FnZShvblBhY2thZ2U6IG9uU2VhcmNoUGFja2FnZSwgb25FbmQ6IG9uRW5kU2VhcmNoUGFja2FnZSk6IHZvaWQge1xuICAgIC8vIHNhdmUgd2FpdCB3aGV0aGVyIHBsdWdpbiBzdGlsbCBkbyBub3Qgc3VwcG9ydCBzZWFyY2ggZnVuY3Rpb25hbGl0eVxuICAgIGlmIChfLmlzTmlsKHRoaXMuc3RvcmFnZVBsdWdpbi5zZWFyY2gpKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKCdwbHVnaW4gc2VhcmNoIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgIG9uRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcmFnZVBsdWdpbi5zZWFyY2gob25QYWNrYWdlLCBvbkVuZCwgdmFsaWRhdGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgZWl0aGVyIGEgcHJldmlvdXMgY3JlYXRlZCBsb2NhbCBwYWNrYWdlIG9yIGEgYm9pbGVycGxhdGUuXG4gICAqIEBwYXJhbSB7Kn0gcGtnTmFtZVxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgcHJpdmF0ZSBfcmVhZENyZWF0ZVBhY2thZ2UocGtnTmFtZTogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBzdG9yYWdlOiBhbnkgPSB0aGlzLl9nZXRMb2NhbFN0b3JhZ2UocGtnTmFtZSk7XG4gICAgaWYgKF8uaXNOaWwoc3RvcmFnZSkpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZU5ld1BhY2thZ2UocGtnTmFtZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0b3JhZ2UucmVhZFBhY2thZ2UocGtnTmFtZSwgKGVyciwgZGF0YSk6IHZvaWQgPT4ge1xuICAgICAgLy8gVE9ETzogcmFjZSBjb25kaXRpb25cbiAgICAgIGlmIChfLmlzTmlsKGVycikgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gU1RPUkFHRS5OT19TVUNIX0ZJTEVfRVJST1IgfHwgZXJyLmNvZGUgPT09IEhUVFBfU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICAgIGRhdGEgPSBnZW5lcmF0ZVBhY2thZ2VUZW1wbGF0ZShwa2dOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5faW50ZXJuYWxFcnJvcihlcnIsIFNUT1JBR0UuUEFDS0FHRV9GSUxFX05BTUUsICdlcnJvciByZWFkaW5nJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIG5vcm1hbGl6ZVBhY2thZ2UoZGF0YSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfY3JlYXRlTmV3UGFja2FnZShuYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayk6IENhbGxiYWNrIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbm9ybWFsaXplUGFja2FnZShnZW5lcmF0ZVBhY2thZ2VUZW1wbGF0ZShuYW1lKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBpbnRlcm5hbCBlcnJvclxuICAgKiBAcGFyYW0geyp9IGVyclxuICAgKiBAcGFyYW0geyp9IGZpbGVcbiAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXJyb3IgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgX2ludGVybmFsRXJyb3IoZXJyOiBzdHJpbmcsIGZpbGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogVmVyZGFjY2lvRXJyb3Ige1xuICAgIHRoaXMubG9nZ2VyLmVycm9yKHsgZXJyOiBlcnIsIGZpbGU6IGZpbGUgfSwgYCR7bWVzc2FnZX0gIEB7ZmlsZX06IEB7IWVyci5tZXNzYWdlfWApO1xuXG4gICAgcmV0dXJuIEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBuYW1lIHBhY2thZ2UgbmFtZVxuICAgKiBAcGFyYW0geyp9IHVwZGF0ZUhhbmRsZXIgZnVuY3Rpb24ocGFja2FnZSwgY2IpIC0gdXBkYXRlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2sgY2FsbGJhY2sgdGhhdCBnZXRzIGludm9rZWQgYWZ0ZXIgaXQncyBhbGwgdXBkYXRlZFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG4gIHByaXZhdGUgX3VwZGF0ZVBhY2thZ2UobmFtZTogc3RyaW5nLCB1cGRhdGVIYW5kbGVyOiBTdG9yYWdlVXBkYXRlQ2FsbGJhY2ssIGNhbGxiYWNrOiBDYWxsYmFja0FjdGlvbik6IHZvaWQge1xuICAgIGNvbnN0IHN0b3JhZ2U6IElQYWNrYWdlU3RvcmFnZSA9IHRoaXMuX2dldExvY2FsU3RvcmFnZShuYW1lKTtcblxuICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZCgpKTtcbiAgICB9XG5cbiAgICBzdG9yYWdlLnVwZGF0ZVBhY2thZ2UobmFtZSwgdXBkYXRlSGFuZGxlciwgdGhpcy5fd3JpdGVQYWNrYWdlLmJpbmQodGhpcyksIG5vcm1hbGl6ZVBhY2thZ2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHJldmlzaW9uIChfcmV2KSBzdHJpbmcgZm9yIGEgcGFja2FnZS5cbiAgICogQHBhcmFtIHsqfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0ganNvblxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgcHJpdmF0ZSBfd3JpdGVQYWNrYWdlKG5hbWU6IHN0cmluZywganNvbjogUGFja2FnZSwgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmFnZTogYW55ID0gdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKG5hbWUpO1xuICAgIGlmIChfLmlzTmlsKHN0b3JhZ2UpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgc3RvcmFnZS5zYXZlUGFja2FnZShuYW1lLCB0aGlzLl9zZXREZWZhdWx0UmV2aXNpb24oanNvbiksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NldERlZmF1bHRSZXZpc2lvbihqc29uOiBQYWNrYWdlKTogUGFja2FnZSB7XG4gICAgLy8gY2FsY3VsYXRlIHJldmlzaW9uIGZyb20gY291Y2ggZGJcbiAgICBpZiAoXy5pc1N0cmluZyhqc29uLl9yZXYpID09PSBmYWxzZSkge1xuICAgICAganNvbi5fcmV2ID0gU1RPUkFHRS5ERUZBVUxUX1JFVklTSU9OO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgaW50ZW5kZWQgaW4gZGVidWcgbW9kZSB3ZSBkbyBub3Qgd2FudCBtb2RpZnkgdGhlIHN0b3JlIHJldmlzaW9uXG4gICAgaWYgKF8uaXNOaWwodGhpcy5jb25maWcuX2RlYnVnKSkge1xuICAgICAganNvbi5fcmV2ID0gZ2VuZXJhdGVSZXZpc2lvbihqc29uLl9yZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGVsZXRlQXR0YWNobWVudHMoc3RvcmFnZTogYW55LCBhdHRhY2htZW50czogc3RyaW5nW10sIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGRlYnVnKCdbc3RvcmFnZS9fZGVsZXRlQXR0YWNobWVudHNdIGRlbGV0ZSBhdHRhY2htZW50cyB0b3RhbDogJW8nLCBhdHRhY2htZW50cz8ubGVuZ3RoKTtcbiAgICBjb25zdCB1bmxpbmtOZXh0ID0gZnVuY3Rpb24gKGNiKTogdm9pZCB7XG4gICAgICBpZiAoXy5pc0VtcHR5KGF0dGFjaG1lbnRzKSkge1xuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0YWNobWVudCA9IGF0dGFjaG1lbnRzLnNoaWZ0KCk7XG4gICAgICBzdG9yYWdlLmRlbGV0ZVBhY2thZ2UoYXR0YWNobWVudCwgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICB1bmxpbmtOZXh0KGNiKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB1bmxpbmtOZXh0KGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgIC8vIHRyeSB0byB1bmxpbmsgdGhlIGRpcmVjdG9yeSwgYnV0IGlnbm9yZSBlcnJvcnMgYmVjYXVzZSBpdCBjYW4gZmFpbFxuICAgICAgc3RvcmFnZS5yZW1vdmVQYWNrYWdlKGZ1bmN0aW9uIChlcnIpOiB2b2lkIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSB0aGUgZGlzdCBmaWxlIHJlbWFpbnMgYXMgdGhlIHNhbWUgcHJvdG9jb2xcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggbWV0YWRhdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVwTGlua0tleSByZWdpc3RyeSBrZXlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3VwZGF0ZVVwbGlua1RvUmVtb3RlUHJvdG9jb2woaGFzaDogRGlzdEZpbGUsIHVwTGlua0tleTogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gaWYgd2UgZ290IHRoaXMgaW5mb3JtYXRpb24gZnJvbSBhIGtub3duIHJlZ2lzdHJ5LFxuICAgIC8vIHVzZSB0aGUgc2FtZSBwcm90b2NvbCBmb3IgdGhlIHRhcmJhbGxcbiAgICAvL1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmxpZHdrYS9zaW5vcGlhL2lzc3Vlcy8xNjZcbiAgICBjb25zdCB0YXJiYWxsVXJsOiBhbnkgPSBVcmxOb2RlLnBhcnNlKGhhc2gudXJsKTtcbiAgICBjb25zdCB1cGxpbmtVcmw6IGFueSA9IFVybE5vZGUucGFyc2UodGhpcy5jb25maWcudXBsaW5rc1t1cExpbmtLZXldLnVybCk7XG5cbiAgICBpZiAodXBsaW5rVXJsLmhvc3QgPT09IHRhcmJhbGxVcmwuaG9zdCkge1xuICAgICAgdGFyYmFsbFVybC5wcm90b2NvbCA9IHVwbGlua1VybC5wcm90b2NvbDtcbiAgICAgIGhhc2gucmVnaXN0cnkgPSB1cExpbmtLZXk7XG4gICAgICBoYXNoLnVybCA9IFVybE5vZGUuZm9ybWF0KHRhcmJhbGxVcmwpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRTZWNyZXQoY29uZmlnOiBDb25maWcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBhd2FpdCB0aGlzLnN0b3JhZ2VQbHVnaW4uZ2V0U2VjcmV0KCk7XG5cbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlUGx1Z2luLnNldFNlY3JldChjb25maWcuY2hlY2tTZWNyZXRLZXkoc2VjcmV0S2V5KSk7XG4gIH1cblxuICBwcml2YXRlIF9sb2FkU3RvcmFnZShjb25maWc6IENvbmZpZywgbG9nZ2VyOiBMb2dnZXIpOiBJUGx1Z2luU3RvcmFnZTxDb25maWc+IHtcbiAgICBjb25zdCBTdG9yYWdlID0gdGhpcy5fbG9hZFN0b3JlUGx1Z2luKCk7XG5cbiAgICBpZiAoXy5pc05pbChTdG9yYWdlKSkge1xuICAgICAgYXNzZXJ0KHRoaXMuY29uZmlnLnN0b3JhZ2UsICdDT05GSUc6IHN0b3JhZ2UgcGF0aCBub3QgZGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIG5ldyBMb2NhbERhdGFiYXNlKHRoaXMuY29uZmlnLCBsb2dnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gU3RvcmFnZSBhcyBJUGx1Z2luU3RvcmFnZTxDb25maWc+O1xuICB9XG5cbiAgcHJpdmF0ZSBfbG9hZFN0b3JlUGx1Z2luKCk6IElQbHVnaW5TdG9yYWdlPENvbmZpZz4gfCB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5fcGFyYW1zID0ge1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgfTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgY29uc3QgcGx1Z2luczogSVBsdWdpblN0b3JhZ2U8Q29uZmlnPltdID0gbG9hZFBsdWdpbjxJUGx1Z2luU3RvcmFnZTxDb25maWc+PihcbiAgICAgIHRoaXMuY29uZmlnLFxuICAgICAgdGhpcy5jb25maWcuc3RvcmUsXG4gICAgICBwbHVnaW5fcGFyYW1zLFxuICAgICAgKHBsdWdpbik6IElQbHVnaW5TdG9yYWdlPENvbmZpZz4gPT4ge1xuICAgICAgICByZXR1cm4gcGx1Z2luLmdldFBhY2thZ2VTdG9yYWdlO1xuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gXy5oZWFkKHBsdWdpbnMpO1xuICB9XG5cbiAgcHVibGljIHNhdmVUb2tlbih0b2tlbjogVG9rZW4pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5zdG9yYWdlUGx1Z2luLnNhdmVUb2tlbikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoRXJyb3JDb2RlLmdldENvZGUoSFRUUF9TVEFUVVMuU0VSVklDRV9VTkFWQUlMQUJMRSwgU1VQUE9SVF9FUlJPUlMuUExVR0lOX01JU1NJTkdfSU5URVJGQUNFKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVBsdWdpbi5zYXZlVG9rZW4odG9rZW4pO1xuICB9XG5cbiAgcHVibGljIGRlbGV0ZVRva2VuKHVzZXI6IHN0cmluZywgdG9rZW5LZXk6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLnN0b3JhZ2VQbHVnaW4uZGVsZXRlVG9rZW4pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yQ29kZS5nZXRDb2RlKEhUVFBfU1RBVFVTLlNFUlZJQ0VfVU5BVkFJTEFCTEUsIFNVUFBPUlRfRVJST1JTLlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQbHVnaW4uZGVsZXRlVG9rZW4odXNlciwgdG9rZW5LZXkpO1xuICB9XG5cbiAgcHVibGljIHJlYWRUb2tlbnMoZmlsdGVyOiBUb2tlbkZpbHRlcik6IFByb21pc2U8VG9rZW5bXT4ge1xuICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5zdG9yYWdlUGx1Z2luLnJlYWRUb2tlbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEVycm9yQ29kZS5nZXRDb2RlKEhUVFBfU1RBVFVTLlNFUlZJQ0VfVU5BVkFJTEFCTEUsIFNVUFBPUlRfRVJST1JTLlBMVUdJTl9NSVNTSU5HX0lOVEVSRkFDRSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VQbHVnaW4ucmVhZFRva2VucyhmaWx0ZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvY2FsU3RvcmFnZTtcbiJdfQ==