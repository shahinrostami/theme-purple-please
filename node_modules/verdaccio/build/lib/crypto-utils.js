"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aesEncrypt = aesEncrypt;
exports.aesDecrypt = aesDecrypt;
exports.createTarballHash = createTarballHash;
exports.stringToMD5 = stringToMD5;
exports.generateRandomHexString = generateRandomHexString;
exports.signPayload = signPayload;
exports.verifyPayload = verifyPayload;
exports.defaultTarballHashAlgorithm = exports.defaultAlgorithm = void 0;

var _crypto = require("crypto");

var _jsonwebtoken = _interopRequireDefault(require("jsonwebtoken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const defaultAlgorithm = 'aes192';
exports.defaultAlgorithm = defaultAlgorithm;
const defaultTarballHashAlgorithm = 'sha1';
exports.defaultTarballHashAlgorithm = defaultTarballHashAlgorithm;

function aesEncrypt(buf, secret) {
  // deprecated (it will be migrated in Verdaccio 5), it is a breaking change
  // https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password_options
  // https://www.grainger.xyz/changing-from-cipher-to-cipheriv/
  const c = (0, _crypto.createCipher)(defaultAlgorithm, secret);
  const b1 = c.update(buf);
  const b2 = c.final();
  return Buffer.concat([b1, b2]);
}

function aesDecrypt(buf, secret) {
  try {
    // deprecated (it will be migrated in Verdaccio 5), it is a breaking change
    // https://nodejs.org/api/crypto.html#crypto_crypto_createdecipher_algorithm_password_options
    // https://www.grainger.xyz/changing-from-cipher-to-cipheriv/
    const c = (0, _crypto.createDecipher)(defaultAlgorithm, secret);
    const b1 = c.update(buf);
    const b2 = c.final();
    return Buffer.concat([b1, b2]);
  } catch (_) {
    return Buffer.alloc(0);
  }
}

function createTarballHash() {
  return (0, _crypto.createHash)(defaultTarballHashAlgorithm);
}
/**
 * Express doesn't do ETAGS with requests <= 1024b
 * we use md5 here, it works well on 1k+ bytes, but sucks with fewer data
 * could improve performance using crc32 after benchmarks.
 * @param {Object} data
 * @return {String}
 */


function stringToMD5(data) {
  return (0, _crypto.createHash)('md5').update(data).digest('hex');
}

function generateRandomHexString(length = 8) {
  return (0, _crypto.pseudoRandomBytes)(length).toString('hex');
}

async function signPayload(payload, secretOrPrivateKey, options) {
  return new Promise(function (resolve, reject) {
    return _jsonwebtoken.default.sign(payload, secretOrPrivateKey, _objectSpread({
      notBefore: '1'
    }, options), (error, token) => error ? reject(error) : resolve(token));
  });
}

function verifyPayload(token, secretOrPrivateKey) {
  return _jsonwebtoken.default.verify(token, secretOrPrivateKey);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY3J5cHRvLXV0aWxzLnRzIl0sIm5hbWVzIjpbImRlZmF1bHRBbGdvcml0aG0iLCJkZWZhdWx0VGFyYmFsbEhhc2hBbGdvcml0aG0iLCJhZXNFbmNyeXB0IiwiYnVmIiwic2VjcmV0IiwiYyIsImIxIiwidXBkYXRlIiwiYjIiLCJmaW5hbCIsIkJ1ZmZlciIsImNvbmNhdCIsImFlc0RlY3J5cHQiLCJfIiwiYWxsb2MiLCJjcmVhdGVUYXJiYWxsSGFzaCIsInN0cmluZ1RvTUQ1IiwiZGF0YSIsImRpZ2VzdCIsImdlbmVyYXRlUmFuZG9tSGV4U3RyaW5nIiwibGVuZ3RoIiwidG9TdHJpbmciLCJzaWduUGF5bG9hZCIsInBheWxvYWQiLCJzZWNyZXRPclByaXZhdGVLZXkiLCJvcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJqd3QiLCJzaWduIiwibm90QmVmb3JlIiwiZXJyb3IiLCJ0b2tlbiIsInZlcmlmeVBheWxvYWQiLCJ2ZXJpZnkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7Ozs7Ozs7QUFJTyxNQUFNQSxnQkFBZ0IsR0FBRyxRQUF6Qjs7QUFDQSxNQUFNQywyQkFBMkIsR0FBRyxNQUFwQzs7O0FBRUEsU0FBU0MsVUFBVCxDQUFvQkMsR0FBcEIsRUFBaUNDLE1BQWpDLEVBQXlEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFFBQU1DLENBQUMsR0FBRywwQkFBYUwsZ0JBQWIsRUFBK0JJLE1BQS9CLENBQVY7QUFDQSxRQUFNRSxFQUFFLEdBQUdELENBQUMsQ0FBQ0UsTUFBRixDQUFTSixHQUFULENBQVg7QUFDQSxRQUFNSyxFQUFFLEdBQUdILENBQUMsQ0FBQ0ksS0FBRixFQUFYO0FBQ0EsU0FBT0MsTUFBTSxDQUFDQyxNQUFQLENBQWMsQ0FBQ0wsRUFBRCxFQUFLRSxFQUFMLENBQWQsQ0FBUDtBQUNEOztBQUVNLFNBQVNJLFVBQVQsQ0FBb0JULEdBQXBCLEVBQWlDQyxNQUFqQyxFQUF5RDtBQUM5RCxNQUFJO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsVUFBTUMsQ0FBQyxHQUFHLDRCQUFlTCxnQkFBZixFQUFpQ0ksTUFBakMsQ0FBVjtBQUNBLFVBQU1FLEVBQUUsR0FBR0QsQ0FBQyxDQUFDRSxNQUFGLENBQVNKLEdBQVQsQ0FBWDtBQUNBLFVBQU1LLEVBQUUsR0FBR0gsQ0FBQyxDQUFDSSxLQUFGLEVBQVg7QUFDQSxXQUFPQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxDQUFDTCxFQUFELEVBQUtFLEVBQUwsQ0FBZCxDQUFQO0FBQ0QsR0FSRCxDQVFFLE9BQU9LLENBQVAsRUFBVTtBQUNWLFdBQU9ILE1BQU0sQ0FBQ0ksS0FBUCxDQUFhLENBQWIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRU0sU0FBU0MsaUJBQVQsR0FBbUM7QUFDeEMsU0FBTyx3QkFBV2QsMkJBQVgsQ0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNlLFdBQVQsQ0FBcUJDLElBQXJCLEVBQW9EO0FBQ3pELFNBQU8sd0JBQVcsS0FBWCxFQUFrQlYsTUFBbEIsQ0FBeUJVLElBQXpCLEVBQStCQyxNQUEvQixDQUFzQyxLQUF0QyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0MsdUJBQVQsQ0FBaUNDLE1BQU0sR0FBRyxDQUExQyxFQUFxRDtBQUMxRCxTQUFPLCtCQUFrQkEsTUFBbEIsRUFBMEJDLFFBQTFCLENBQW1DLEtBQW5DLENBQVA7QUFDRDs7QUFFTSxlQUFlQyxXQUFmLENBQ0xDLE9BREssRUFFTEMsa0JBRkssRUFHTEMsT0FISyxFQUlZO0FBQ2pCLFNBQU8sSUFBSUMsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTRDO0FBQzdELFdBQU9DLHNCQUFJQyxJQUFKLENBQ0xQLE9BREssRUFFTEMsa0JBRks7QUFJSE8sTUFBQUEsU0FBUyxFQUFFO0FBSlIsT0FLQU4sT0FMQSxHQU9MLENBQUNPLEtBQUQsRUFBUUMsS0FBUixLQUFtQkQsS0FBSyxHQUFHSixNQUFNLENBQUNJLEtBQUQsQ0FBVCxHQUFtQkwsT0FBTyxDQUFDTSxLQUFELENBUDdDLENBQVA7QUFTRCxHQVZNLENBQVA7QUFXRDs7QUFFTSxTQUFTQyxhQUFULENBQXVCRCxLQUF2QixFQUFzQ1Qsa0JBQXRDLEVBQThFO0FBQ25GLFNBQU9LLHNCQUFJTSxNQUFKLENBQVdGLEtBQVgsRUFBa0JULGtCQUFsQixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVEZWNpcGhlciwgY3JlYXRlQ2lwaGVyLCBjcmVhdGVIYXNoLCBwc2V1ZG9SYW5kb21CeXRlcywgSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5cbmltcG9ydCB7IEpXVFNpZ25PcHRpb25zLCBSZW1vdGVVc2VyIH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0QWxnb3JpdGhtID0gJ2FlczE5Mic7XG5leHBvcnQgY29uc3QgZGVmYXVsdFRhcmJhbGxIYXNoQWxnb3JpdGhtID0gJ3NoYTEnO1xuXG5leHBvcnQgZnVuY3Rpb24gYWVzRW5jcnlwdChidWY6IEJ1ZmZlciwgc2VjcmV0OiBzdHJpbmcpOiBCdWZmZXIge1xuICAvLyBkZXByZWNhdGVkIChpdCB3aWxsIGJlIG1pZ3JhdGVkIGluIFZlcmRhY2NpbyA1KSwgaXQgaXMgYSBicmVha2luZyBjaGFuZ2VcbiAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9jcnlwdG8uaHRtbCNjcnlwdG9fY3J5cHRvX2NyZWF0ZWNpcGhlcl9hbGdvcml0aG1fcGFzc3dvcmRfb3B0aW9uc1xuICAvLyBodHRwczovL3d3dy5ncmFpbmdlci54eXovY2hhbmdpbmctZnJvbS1jaXBoZXItdG8tY2lwaGVyaXYvXG4gIGNvbnN0IGMgPSBjcmVhdGVDaXBoZXIoZGVmYXVsdEFsZ29yaXRobSwgc2VjcmV0KTtcbiAgY29uc3QgYjEgPSBjLnVwZGF0ZShidWYpO1xuICBjb25zdCBiMiA9IGMuZmluYWwoKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2IxLCBiMl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWVzRGVjcnlwdChidWY6IEJ1ZmZlciwgc2VjcmV0OiBzdHJpbmcpOiBCdWZmZXIge1xuICB0cnkge1xuICAgIC8vIGRlcHJlY2F0ZWQgKGl0IHdpbGwgYmUgbWlncmF0ZWQgaW4gVmVyZGFjY2lvIDUpLCBpdCBpcyBhIGJyZWFraW5nIGNoYW5nZVxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjY3J5cHRvX2NyeXB0b19jcmVhdGVkZWNpcGhlcl9hbGdvcml0aG1fcGFzc3dvcmRfb3B0aW9uc1xuICAgIC8vIGh0dHBzOi8vd3d3LmdyYWluZ2VyLnh5ei9jaGFuZ2luZy1mcm9tLWNpcGhlci10by1jaXBoZXJpdi9cbiAgICBjb25zdCBjID0gY3JlYXRlRGVjaXBoZXIoZGVmYXVsdEFsZ29yaXRobSwgc2VjcmV0KTtcbiAgICBjb25zdCBiMSA9IGMudXBkYXRlKGJ1Zik7XG4gICAgY29uc3QgYjIgPSBjLmZpbmFsKCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2IxLCBiMl0pO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGFyYmFsbEhhc2goKTogSGFzaCB7XG4gIHJldHVybiBjcmVhdGVIYXNoKGRlZmF1bHRUYXJiYWxsSGFzaEFsZ29yaXRobSk7XG59XG5cbi8qKlxuICogRXhwcmVzcyBkb2Vzbid0IGRvIEVUQUdTIHdpdGggcmVxdWVzdHMgPD0gMTAyNGJcbiAqIHdlIHVzZSBtZDUgaGVyZSwgaXQgd29ya3Mgd2VsbCBvbiAxaysgYnl0ZXMsIGJ1dCBzdWNrcyB3aXRoIGZld2VyIGRhdGFcbiAqIGNvdWxkIGltcHJvdmUgcGVyZm9ybWFuY2UgdXNpbmcgY3JjMzIgYWZ0ZXIgYmVuY2htYXJrcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb01ENShkYXRhOiBCdWZmZXIgfCBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKGRhdGEpLmRpZ2VzdCgnaGV4Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUhleFN0cmluZyhsZW5ndGggPSA4KTogc3RyaW5nIHtcbiAgcmV0dXJuIHBzZXVkb1JhbmRvbUJ5dGVzKGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblBheWxvYWQoXG4gIHBheWxvYWQ6IFJlbW90ZVVzZXIsXG4gIHNlY3JldE9yUHJpdmF0ZUtleTogc3RyaW5nLFxuICBvcHRpb25zOiBKV1RTaWduT3B0aW9uc1xuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBqd3Quc2lnbihcbiAgICAgIHBheWxvYWQsXG4gICAgICBzZWNyZXRPclByaXZhdGVLZXksXG4gICAgICB7XG4gICAgICAgIG5vdEJlZm9yZTogJzEnLCAvLyBNYWtlIHN1cmUgdGhlIHRpbWUgd2lsbCBub3Qgcm9sbGJhY2sgOilcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSxcbiAgICAgIChlcnJvciwgdG9rZW4pID0+IChlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHRva2VuKSlcbiAgICApO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVBheWxvYWQodG9rZW46IHN0cmluZywgc2VjcmV0T3JQcml2YXRlS2V5OiBzdHJpbmcpOiBSZW1vdGVVc2VyIHtcbiAgcmV0dXJuIGp3dC52ZXJpZnkodG9rZW4sIHNlY3JldE9yUHJpdmF0ZUtleSk7XG59XG4iXX0=