"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _debug = _interopRequireDefault(require("debug"));

var _pluginLoader = _interopRequireDefault(require("../lib/plugin-loader"));

var _constants = require("./constants");

var _cryptoUtils = require("./crypto-utils");

var _logger = require("./logger");

var _authUtils = require("./auth-utils");

var _utils = require("./utils");

var _configUtils = require("./config-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('verdaccio:auth');

class Auth {
  // pragma: allowlist secret
  constructor(config) {
    _defineProperty(this, "config", void 0);

    _defineProperty(this, "logger", void 0);

    _defineProperty(this, "secret", void 0);

    _defineProperty(this, "plugins", void 0);

    this.config = config;
    this.logger = _logger.logger;
    this.secret = config.secret;
    this.plugins = this._loadPlugin(config);

    this._applyDefaultPlugins();
  }

  _loadPlugin(config) {
    const pluginOptions = {
      config,
      logger: this.logger
    };
    return (0, _pluginLoader.default)(config, config.auth, pluginOptions, plugin => {
      const {
        authenticate,
        allow_access,
        allow_publish
      } = plugin; // @ts-ignore

      return authenticate || allow_access || allow_publish;
    });
  }

  _applyDefaultPlugins() {
    this.plugins.push((0, _authUtils.getDefaultPlugins)(this.logger));
  }

  changePassword(username, password, // pragma: allowlist secret
  newPassword, // pragma: allowlist secret
  cb) {
    const validPlugins = _lodash.default.filter(this.plugins, plugin => _lodash.default.isFunction(plugin.changePassword));

    if (_lodash.default.isEmpty(validPlugins)) {
      return cb(_utils.ErrorCode.getInternalError(_constants.SUPPORT_ERRORS.PLUGIN_MISSING_INTERFACE));
    }

    for (const plugin of validPlugins) {
      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.changePassword) === false) {
        debug('auth plugin does not implement changePassword, trying next one');
        continue;
      } else {
        debug('updating password for %o', username);
        plugin.changePassword(username, password, newPassword, (err, profile) => {
          if (err) {
            this.logger.error({
              username,
              err
            }, `An error has been produced
            updating the password for @{username}. Error: @{err.message}`);
            return cb(err);
          }

          this.logger.info({
            username
          }, 'updated password for @{username} was successful');
          return cb(null, profile);
        });
      }
    }
  }

  authenticate(username, password, cb) {
    const plugins = this.plugins.slice(0);
    const self = this;

    (function next() {
      const plugin = plugins.shift();

      if (_lodash.default.isFunction(plugin.authenticate) === false) {
        return next();
      }

      debug('authenticating %o', username);
      plugin.authenticate(username, password, function (err, groups) {
        if (err) {
          self.logger.error({
            username,
            err
          }, 'authenticating for user @{username} failed. Error: @{err.message}');
          return cb(err);
        } // Expect: SKIP if groups is falsey and not an array
        //         with at least one item (truthy length)
        // Expect: CONTINUE otherwise (will error if groups is not
        //         an array, but this is current behavior)
        // Caveat: STRING (if valid) will pass successfully
        //         bug give unexpected results
        // Info: Cannot use `== false to check falsey values`


        if (!!groups && groups.length !== 0) {
          // TODO: create a better understanding of expectations
          if (_lodash.default.isString(groups)) {
            throw new TypeError('plugin group error: invalid type for function');
          }

          const isGroupValid = _lodash.default.isArray(groups);

          if (!isGroupValid) {
            throw new TypeError(_constants.API_ERROR.BAD_FORMAT_USER_GROUP);
          }

          debug('authentication for user %o was successfully. Groups: %o', username, groups);
          return cb(err, (0, _authUtils.createRemoteUser)(username, groups));
        }

        next();
      });
    })();
  }

  add_user(user, password, cb) {
    const self = this;
    const plugins = this.plugins.slice(0);
    debug('add user %o', user);

    (function next() {
      const plugin = plugins.shift();
      let method = 'adduser';

      if (_lodash.default.isFunction(plugin[method]) === false) {
        method = 'add_user';
        self.logger.warn('the plugin method add_user in the auth plugin is deprecated and will be removed in next major release, notify to the plugin author');
      }

      if (_lodash.default.isFunction(plugin[method]) === false) {
        next();
      } else {
        // p.add_user() execution
        plugin[method](user, password, function (err, ok) {
          if (err) {
            self.logger.error({
              user,
              err: err.message
            }, 'the user @{user} could not being added. Error: @{err}');
            return cb(err);
          }

          if (ok) {
            self.logger.info({
              user
            }, 'the user @{user} has been added');
            return self.authenticate(user, password, cb);
          }

          next();
        });
      }
    })();
  }
  /**
   * Allow user to access a package.
   */


  allow_access({
    packageName,
    packageVersion
  }, user, callback) {
    const plugins = this.plugins.slice(0);
    const self = this;
    const pkgAllowAcces = {
      name: packageName,
      version: packageVersion
    };
    const pkg = Object.assign({}, pkgAllowAcces, (0, _configUtils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow access for %o', packageName);

    (function next() {
      const plugin = plugins.shift();

      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.allow_access) === false) {
        return next();
      }

      plugin.allow_access(user, pkg, function (err, ok) {
        if (err) {
          self.logger.error({
            packageName,
            err
          }, 'forbidden access for @{packageName}. Error: @{err.message}');
          return callback(err);
        }

        if (ok) {
          self.logger.info({
            packageName
          }, 'allowed access for @{packageName}');
          return callback(null, ok);
        }

        next(); // cb(null, false) causes next plugin to roll
      });
    })();
  }

  allow_unpublish({
    packageName,
    packageVersion
  }, user, callback) {
    const pkg = Object.assign({
      name: packageName,
      version: packageVersion
    }, (0, _configUtils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow unpublish for %o', packageName);

    for (const plugin of this.plugins) {
      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.allow_unpublish) === false) {
        debug('allow unpublish for %o plugin does not implement allow_unpublish', packageName);
        continue;
      } else {
        plugin.allow_unpublish(user, pkg, (err, ok) => {
          if (err) {
            this.logger.error({
              packageName,
              user: user === null || user === void 0 ? void 0 : user.name
            }, '@{user} forbidden publish for @{packageName}, it will fallback on unpublish permissions');
            return callback(err);
          }

          if (_lodash.default.isNil(ok) === true) {
            debug('we bypass unpublish for %o, publish will handle the access', packageName); // @ts-ignore
            // eslint-disable-next-line

            return this.allow_publish(...arguments);
          }

          if (ok) {
            this.logger.info({
              packageName,
              user: user === null || user === void 0 ? void 0 : user.name
            }, '@{user} allowed unpublish for @{packageName}');
            return callback(null, ok);
          }
        });
      }
    }
  }
  /**
   * Allow user to publish a package.
   */


  allow_publish({
    packageName,
    packageVersion
  }, user, callback) {
    const plugins = this.plugins.slice(0);
    const self = this;
    const pkg = Object.assign({
      name: packageName,
      version: packageVersion
    }, (0, _configUtils.getMatchedPackagesSpec)(packageName, this.config.packages));
    debug('allow publish for %o init | plugins: %o', packageName, plugins);

    (function next() {
      const plugin = plugins.shift();

      if (_lodash.default.isNil(plugin) || _lodash.default.isFunction(plugin.allow_publish) === false) {
        debug('allow publish for %o plugin does not implement allow_publish', packageName);
        return next();
      } // @ts-ignore


      plugin.allow_publish(user, pkg, (err, ok) => {
        if (_lodash.default.isNil(err) === false && _lodash.default.isError(err)) {
          self.logger.error({
            packageName,
            user: user === null || user === void 0 ? void 0 : user.name
          }, '@{user} is forbidden publish for @{packageName}');
          return callback(err);
        }

        if (ok) {
          self.logger.info({
            packageName,
            user: user === null || user === void 0 ? void 0 : user.name
          }, '@{user} is allowed publish for @{packageName}');
          return callback(null, ok);
        }

        debug('allow publish skip validation for %o', packageName);
        next(); // cb(null, false) causes next plugin to roll
      });
    })();
  }

  apiJWTmiddleware() {
    const plugins = this.plugins.slice(0);
    const helpers = {
      createAnonymousRemoteUser: _authUtils.createAnonymousRemoteUser,
      createRemoteUser: _authUtils.createRemoteUser
    };

    for (const plugin of plugins) {
      if (plugin.apiJWTmiddleware) {
        return plugin.apiJWTmiddleware(helpers);
      }
    }

    return (req, res, _next) => {
      req.pause();

      const next = function (err) {
        req.resume(); // uncomment this to reject users with bad auth headers
        // return _next.apply(null, arguments)
        // swallow error, user remains unauthorized
        // set remoteUserError to indicate that user was attempting authentication

        if (err) {
          req.remote_user.error = err.message;
        }

        return _next();
      };

      if (this._isRemoteUserValid(req.remote_user)) {
        return next();
      } // in case auth header does not exist we return anonymous function


      req.remote_user = (0, _authUtils.createAnonymousRemoteUser)();
      const {
        authorization
      } = req.headers;

      if (_lodash.default.isNil(authorization)) {
        return next();
      }

      if (!(0, _authUtils.isAuthHeaderValid)(authorization)) {
        debug('api middleware auth heather is not valid');
        return next(_utils.ErrorCode.getBadRequest(_constants.API_ERROR.BAD_AUTH_HEADER));
      }

      const security = (0, _authUtils.getSecurity)(this.config);
      const {
        secret
      } = this.config;

      if ((0, _authUtils.isAESLegacy)(security)) {
        debug('api middleware using legacy auth token');

        this._handleAESMiddleware(req, security, secret, authorization, next);
      } else {
        debug('api middleware using JWT auth token');

        this._handleJWTAPIMiddleware(req, security, secret, authorization, next);
      }
    };
  }

  _handleJWTAPIMiddleware(req, security, secret, authorization, next) {
    const {
      scheme,
      token
    } = (0, _authUtils.parseAuthTokenHeader)(authorization);

    if (scheme.toUpperCase() === _constants.TOKEN_BASIC.toUpperCase()) {
      // this should happen when client tries to login with an existing user
      const credentials = (0, _utils.convertPayloadToBase64)(token).toString();
      const {
        user,
        password
      } = (0, _authUtils.parseBasicPayload)(credentials);
      this.authenticate(user, password, (err, user) => {
        if (!err) {
          req.remote_user = user;
          next();
        } else {
          req.remote_user = (0, _authUtils.createAnonymousRemoteUser)();
          next(err);
        }
      });
    } else {
      // jwt handler
      const credentials = (0, _authUtils.getMiddlewareCredentials)(security, secret, authorization);

      if (credentials) {
        // if the signature is valid we rely on it
        req.remote_user = credentials;
        next();
      } else {
        // with JWT throw 401
        next(_utils.ErrorCode.getForbidden(_constants.API_ERROR.BAD_USERNAME_PASSWORD));
      }
    }
  }

  _handleAESMiddleware(req, security, secret, authorization, next) {
    const credentials = (0, _authUtils.getMiddlewareCredentials)(security, secret, authorization);

    if (credentials) {
      const {
        user,
        password
      } = credentials;
      this.authenticate(user, password, (err, user) => {
        if (!err) {
          req.remote_user = user;
          next();
        } else {
          req.remote_user = (0, _authUtils.createAnonymousRemoteUser)();
          next(err);
        }
      });
    } else {
      // we force npm client to ask again with basic authentication
      return next(_utils.ErrorCode.getBadRequest(_constants.API_ERROR.BAD_AUTH_HEADER));
    }
  }

  _isRemoteUserValid(remote_user) {
    return _lodash.default.isUndefined(remote_user) === false && _lodash.default.isUndefined(remote_user.name) === false;
  }
  /**
   * JWT middleware for WebUI
   */


  webUIJWTmiddleware() {
    return (req, res, _next) => {
      if (this._isRemoteUserValid(req.remote_user)) {
        return _next();
      }

      req.pause();

      const next = err => {
        req.resume();

        if (err) {
          // req.remote_user.error = err.message;
          res.status(err.statusCode).send(err.message);
        }

        return _next();
      };

      const {
        authorization
      } = req.headers;

      if (_lodash.default.isNil(authorization)) {
        return next();
      }

      if (!(0, _authUtils.isAuthHeaderValid)(authorization)) {
        return next(_utils.ErrorCode.getBadRequest(_constants.API_ERROR.BAD_AUTH_HEADER));
      }

      const token = (authorization || '').replace(`${_constants.TOKEN_BEARER} `, '');

      if (!token) {
        return next();
      }

      let credentials;

      try {
        credentials = (0, _authUtils.verifyJWTPayload)(token, this.config.secret);
      } catch (err) {// FIXME: intended behaviour, do we want it?
      }

      if (this._isRemoteUserValid(credentials)) {
        const {
          name,
          groups
        } = credentials; // $FlowFixMe

        req.remote_user = (0, _authUtils.createRemoteUser)(name, groups);
      } else {
        req.remote_user = (0, _authUtils.createAnonymousRemoteUser)();
      }

      next();
    };
  }

  async jwtEncrypt(user, signOptions) {
    const {
      real_groups,
      name,
      groups
    } = user;
    const realGroupsValidated = _lodash.default.isNil(real_groups) ? [] : real_groups;
    const groupedGroups = _lodash.default.isNil(groups) ? real_groups : groups.concat(realGroupsValidated);
    const payload = {
      real_groups: realGroupsValidated,
      name,
      groups: groupedGroups
    };
    const token = await (0, _cryptoUtils.signPayload)(payload, this.secret, signOptions);
    return token;
  }
  /**
   * Encrypt a string.
   */


  aesEncrypt(buf) {
    return (0, _cryptoUtils.aesEncrypt)(buf, this.secret);
  }

}

var _default = Auth;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXV0aC50cyJdLCJuYW1lcyI6WyJkZWJ1ZyIsIkF1dGgiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImxvZ2dlciIsInNlY3JldCIsInBsdWdpbnMiLCJfbG9hZFBsdWdpbiIsIl9hcHBseURlZmF1bHRQbHVnaW5zIiwicGx1Z2luT3B0aW9ucyIsImF1dGgiLCJwbHVnaW4iLCJhdXRoZW50aWNhdGUiLCJhbGxvd19hY2Nlc3MiLCJhbGxvd19wdWJsaXNoIiwicHVzaCIsImNoYW5nZVBhc3N3b3JkIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIm5ld1Bhc3N3b3JkIiwiY2IiLCJ2YWxpZFBsdWdpbnMiLCJfIiwiZmlsdGVyIiwiaXNGdW5jdGlvbiIsImlzRW1wdHkiLCJFcnJvckNvZGUiLCJnZXRJbnRlcm5hbEVycm9yIiwiU1VQUE9SVF9FUlJPUlMiLCJQTFVHSU5fTUlTU0lOR19JTlRFUkZBQ0UiLCJpc05pbCIsImVyciIsInByb2ZpbGUiLCJlcnJvciIsImluZm8iLCJzbGljZSIsInNlbGYiLCJuZXh0Iiwic2hpZnQiLCJncm91cHMiLCJsZW5ndGgiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsImlzR3JvdXBWYWxpZCIsImlzQXJyYXkiLCJBUElfRVJST1IiLCJCQURfRk9STUFUX1VTRVJfR1JPVVAiLCJhZGRfdXNlciIsInVzZXIiLCJtZXRob2QiLCJ3YXJuIiwib2siLCJtZXNzYWdlIiwicGFja2FnZU5hbWUiLCJwYWNrYWdlVmVyc2lvbiIsImNhbGxiYWNrIiwicGtnQWxsb3dBY2NlcyIsIm5hbWUiLCJ2ZXJzaW9uIiwicGtnIiwiT2JqZWN0IiwiYXNzaWduIiwicGFja2FnZXMiLCJhbGxvd191bnB1Ymxpc2giLCJhcmd1bWVudHMiLCJpc0Vycm9yIiwiYXBpSldUbWlkZGxld2FyZSIsImhlbHBlcnMiLCJjcmVhdGVBbm9ueW1vdXNSZW1vdGVVc2VyIiwiY3JlYXRlUmVtb3RlVXNlciIsInJlcSIsInJlcyIsIl9uZXh0IiwicGF1c2UiLCJyZXN1bWUiLCJyZW1vdGVfdXNlciIsIl9pc1JlbW90ZVVzZXJWYWxpZCIsImF1dGhvcml6YXRpb24iLCJoZWFkZXJzIiwiZ2V0QmFkUmVxdWVzdCIsIkJBRF9BVVRIX0hFQURFUiIsInNlY3VyaXR5IiwiX2hhbmRsZUFFU01pZGRsZXdhcmUiLCJfaGFuZGxlSldUQVBJTWlkZGxld2FyZSIsInNjaGVtZSIsInRva2VuIiwidG9VcHBlckNhc2UiLCJUT0tFTl9CQVNJQyIsImNyZWRlbnRpYWxzIiwidG9TdHJpbmciLCJnZXRGb3JiaWRkZW4iLCJCQURfVVNFUk5BTUVfUEFTU1dPUkQiLCJpc1VuZGVmaW5lZCIsIndlYlVJSldUbWlkZGxld2FyZSIsInN0YXR1cyIsInN0YXR1c0NvZGUiLCJzZW5kIiwicmVwbGFjZSIsIlRPS0VOX0JFQVJFUiIsImp3dEVuY3J5cHQiLCJzaWduT3B0aW9ucyIsInJlYWxfZ3JvdXBzIiwicmVhbEdyb3Vwc1ZhbGlkYXRlZCIsImdyb3VwZWRHcm91cHMiLCJjb25jYXQiLCJwYXlsb2FkIiwiYWVzRW5jcnlwdCIsImJ1ZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQUdBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQVlBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxLQUFLLEdBQUcsb0JBQVcsZ0JBQVgsQ0FBZDs7QUFFQSxNQUFNQyxJQUFOLENBQTRCO0FBR0g7QUFHaEJDLEVBQUFBLFdBQVcsQ0FBQ0MsTUFBRCxFQUFpQjtBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUNqQyxTQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxNQUFMLEdBQWNBLGNBQWQ7QUFDQSxTQUFLQyxNQUFMLEdBQWNGLE1BQU0sQ0FBQ0UsTUFBckI7QUFDQSxTQUFLQyxPQUFMLEdBQWUsS0FBS0MsV0FBTCxDQUFpQkosTUFBakIsQ0FBZjs7QUFDQSxTQUFLSyxvQkFBTDtBQUNEOztBQUVPRCxFQUFBQSxXQUFXLENBQUNKLE1BQUQsRUFBd0M7QUFDekQsVUFBTU0s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O0FBRUR0QyxNQUFBQSxJQUFJO0FBQ0wsS0E5Q0Q7QUErQ0Q7O0FBRXNCLFFBQVY4RCxVQUFVLENBQUNuRCxJQUFELEVBQW1Cb0QsV0FBbkIsRUFBaUU7QUFDdEYsVUFBTTtBQUFFQyxNQUFBQSxXQUFGO0FBQWU1QyxNQUFBQSxJQUFmO0FBQXFCbEIsTUFBQUE7QUFBckIsUUFBZ0NTLElBQXRDO0FBQ0EsVUFBTXNELG1CQUFtQixHQUFHaEYsZ0JBQUVRLEtBQUYsQ0FBUXVFLFdBQVIsSUFBdUIsRUFBdkIsR0FBNEJBLFdBQXhEO0FBQ0EsVUFBTUUsYUFBYSxHQUFHakYsZ0JBQUVRLEtBQUYsQ0FBUVMsTUFBUixJQUFrQjhELFdBQWxCLEdBQWdDOUQsTUFBTSxDQUFDaUUsTUFBUCxDQUFjRixtQkFBZCxDQUF0RDtBQUNBLFVBQU1HLE9BQW1CLEdBQUc7QUFDMUJKLE1BQUFBLFdBQVcsRUFBRUMsbUJBRGE7QUFFMUI3QyxNQUFBQSxJQUYwQjtBQUcxQmxCLE1BQUFBLE1BQU0sRUFBRWdFO0FBSGtCLEtBQTVCO0FBTUEsVUFBTWxCLEtBQWEsR0FBRyxNQUFNLDhCQUFZb0IsT0FBWixFQUFxQixLQUFLcEcsTUFBMUIsRUFBa0MrRixXQUFsQyxDQUE1QjtBQUVBLFdBQU9mLEtBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ1NxQixFQUFBQSxVQUFVLENBQUNDLEdBQUQsRUFBc0I7QUFDckMsV0FBTyw2QkFBV0EsR0FBWCxFQUFnQixLQUFLdEcsTUFBckIsQ0FBUDtBQUNEOztBQTFaeUI7O2VBNlpiSixJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFZlcmRhY2Npb0Vycm9yIH0gZnJvbSAnQHZlcmRhY2Npby9jb21tb25zLWFwaSc7XG5pbXBvcnQgYnVpbGREZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBDb25maWcsIExvZ2dlciwgQ2FsbGJhY2ssIElQbHVnaW5BdXRoLCBSZW1vdGVVc2VyLCBKV1RTaWduT3B0aW9ucywgU2VjdXJpdHksIEF1dGhQbHVnaW5QYWNrYWdlLCBBbGxvd0FjY2VzcywgUGFja2FnZUFjY2VzcyB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgTmV4dEZ1bmN0aW9uIH0gZnJvbSAnZXhwcmVzcyc7XG5pbXBvcnQgbG9hZFBsdWdpbiBmcm9tICcuLi9saWIvcGx1Z2luLWxvYWRlcic7XG5pbXBvcnQgeyAkUmVxdWVzdEV4dGVuZCwgJFJlc3BvbnNlRXh0ZW5kLCBJQXV0aCwgQUVTUGF5bG9hZCB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IEFQSV9FUlJPUiwgU1VQUE9SVF9FUlJPUlMsIFRPS0VOX0JBU0lDLCBUT0tFTl9CRUFSRVIgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBhZXNFbmNyeXB0LCBzaWduUGF5bG9hZCB9IGZyb20gJy4vY3J5cHRvLXV0aWxzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7XG4gIGdldERlZmF1bHRQbHVnaW5zLFxuICBnZXRNaWRkbGV3YXJlQ3JlZGVudGlhbHMsXG4gIHZlcmlmeUpXVFBheWxvYWQsXG4gIGNyZWF0ZUFub255bW91c1JlbW90ZVVzZXIsXG4gIGlzQXV0aEhlYWRlclZhbGlkLFxuICBnZXRTZWN1cml0eSxcbiAgaXNBRVNMZWdhY3ksXG4gIHBhcnNlQXV0aFRva2VuSGVhZGVyLFxuICBwYXJzZUJhc2ljUGF5bG9hZCxcbiAgY3JlYXRlUmVtb3RlVXNlcixcbn0gZnJvbSAnLi9hdXRoLXV0aWxzJztcbmltcG9ydCB7IGNvbnZlcnRQYXlsb2FkVG9CYXNlNjQsIEVycm9yQ29kZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0TWF0Y2hlZFBhY2thZ2VzU3BlYyB9IGZyb20gJy4vY29uZmlnLXV0aWxzJztcblxuY29uc3QgZGVidWcgPSBidWlsZERlYnVnKCd2ZXJkYWNjaW86YXV0aCcpO1xuXG5jbGFzcyBBdXRoIGltcGxlbWVudHMgSUF1dGgge1xuICBwdWJsaWMgY29uZmlnOiBDb25maWc7XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcbiAgcHVibGljIHNlY3JldDogc3RyaW5nOyAvLyBwcmFnbWE6IGFsbG93bGlzdCBzZWNyZXRcbiAgcHVibGljIHBsdWdpbnM6IElQbHVnaW5BdXRoPENvbmZpZz5bXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29uZmlnOiBDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLnNlY3JldCA9IGNvbmZpZy5zZWNyZXQ7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5fbG9hZFBsdWdpbihjb25maWcpO1xuICAgIHRoaXMuX2FwcGx5RGVmYXVsdFBsdWdpbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRQbHVnaW4oY29uZmlnOiBDb25maWcpOiBJUGx1Z2luQXV0aDxDb25maWc+W10ge1xuICAgIGNvbnN0IHBsdWdpbk9wdGlvbnMgPSB7XG4gICAgICBjb25maWcsXG4gICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgIH07XG5cbiAgICByZXR1cm4gbG9hZFBsdWdpbjxJUGx1Z2luQXV0aDxDb25maWc+Pihjb25maWcsIGNvbmZpZy5hdXRoLCBwbHVnaW5PcHRpb25zLCAocGx1Z2luOiBJUGx1Z2luQXV0aDxDb25maWc+KTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCB7IGF1dGhlbnRpY2F0ZSwgYWxsb3dfYWNjZXNzLCBhbGxvd19wdWJsaXNoIH0gPSBwbHVnaW47XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gYXV0aGVudGljYXRlIHx8IGFsbG93X2FjY2VzcyB8fCBhbGxvd19wdWJsaXNoO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfYXBwbHlEZWZhdWx0UGx1Z2lucygpOiB2b2lkIHtcbiAgICB0aGlzLnBsdWdpbnMucHVzaChnZXREZWZhdWx0UGx1Z2lucyh0aGlzLmxvZ2dlcikpO1xuICB9XG5cbiAgcHVibGljIGNoYW5nZVBhc3N3b3JkKFxuICAgIHVzZXJuYW1lOiBzdHJpbmcsXG4gICAgcGFzc3dvcmQ6IHN0cmluZywgLy8gcHJhZ21hOiBhbGxvd2xpc3Qgc2VjcmV0XG4gICAgbmV3UGFzc3dvcmQ6IHN0cmluZywgLy8gcHJhZ21hOiBhbGxvd2xpc3Qgc2VjcmV0XG4gICAgY2I6IENhbGxiYWNrXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHZhbGlkUGx1Z2lucyA9IF8uZmlsdGVyKHRoaXMucGx1Z2lucywgKHBsdWdpbikgPT4gXy5pc0Z1bmN0aW9uKHBsdWdpbi5jaGFuZ2VQYXNzd29yZCkpO1xuXG4gICAgaWYgKF8uaXNFbXB0eSh2YWxpZFBsdWdpbnMpKSB7XG4gICAgICByZXR1cm4gY2IoRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoU1VQUE9SVF9FUlJPUlMuUExVR0lOX01JU1NJTkdfSU5URVJGQUNFKSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdmFsaWRQbHVnaW5zKSB7XG4gICAgICBpZiAoXy5pc05pbChwbHVnaW4pIHx8IF8uaXNGdW5jdGlvbihwbHVnaW4uY2hhbmdlUGFzc3dvcmQpID09PSBmYWxzZSkge1xuICAgICAgICBkZWJ1ZygnYXV0aCBwbHVnaW4gZG9lcyBub3QgaW1wbGVtZW50IGNoYW5nZVBhc3N3b3JkLCB0cnlpbmcgbmV4dCBvbmUnKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygndXBkYXRpbmcgcGFzc3dvcmQgZm9yICVvJywgdXNlcm5hbWUpO1xuICAgICAgICBwbHVnaW4uY2hhbmdlUGFzc3dvcmQhKHVzZXJuYW1lLCBwYXNzd29yZCwgbmV3UGFzc3dvcmQsIChlcnIsIHByb2ZpbGUpOiB2b2lkID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgICAgICAgeyB1c2VybmFtZSwgZXJyIH0sXG4gICAgICAgICAgICAgIGBBbiBlcnJvciBoYXMgYmVlbiBwcm9kdWNlZFxuICAgICAgICAgICAgdXBkYXRpbmcgdGhlIHBhc3N3b3JkIGZvciBAe3VzZXJuYW1lfS4gRXJyb3I6IEB7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKHsgdXNlcm5hbWUgfSwgJ3VwZGF0ZWQgcGFzc3dvcmQgZm9yIEB7dXNlcm5hbWV9IHdhcyBzdWNjZXNzZnVsJyk7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHByb2ZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXV0aGVudGljYXRlKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIGNiOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuc2xpY2UoMCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgKGZ1bmN0aW9uIG5leHQoKTogdm9pZCB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zLnNoaWZ0KCkgYXMgSVBsdWdpbkF1dGg8Q29uZmlnPjtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ocGx1Z2luLmF1dGhlbnRpY2F0ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG4gICAgICBkZWJ1ZygnYXV0aGVudGljYXRpbmcgJW8nLCB1c2VybmFtZSk7XG4gICAgICBwbHVnaW4uYXV0aGVudGljYXRlKHVzZXJuYW1lLCBwYXNzd29yZCwgZnVuY3Rpb24gKGVyciwgZ3JvdXBzKTogdm9pZCB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcih7IHVzZXJuYW1lLCBlcnIgfSwgJ2F1dGhlbnRpY2F0aW5nIGZvciB1c2VyIEB7dXNlcm5hbWV9IGZhaWxlZC4gRXJyb3I6IEB7ZXJyLm1lc3NhZ2V9Jyk7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBlY3Q6IFNLSVAgaWYgZ3JvdXBzIGlzIGZhbHNleSBhbmQgbm90IGFuIGFycmF5XG4gICAgICAgIC8vICAgICAgICAgd2l0aCBhdCBsZWFzdCBvbmUgaXRlbSAodHJ1dGh5IGxlbmd0aClcbiAgICAgICAgLy8gRXhwZWN0OiBDT05USU5VRSBvdGhlcndpc2UgKHdpbGwgZXJyb3IgaWYgZ3JvdXBzIGlzIG5vdFxuICAgICAgICAvLyAgICAgICAgIGFuIGFycmF5LCBidXQgdGhpcyBpcyBjdXJyZW50IGJlaGF2aW9yKVxuICAgICAgICAvLyBDYXZlYXQ6IFNUUklORyAoaWYgdmFsaWQpIHdpbGwgcGFzcyBzdWNjZXNzZnVsbHlcbiAgICAgICAgLy8gICAgICAgICBidWcgZ2l2ZSB1bmV4cGVjdGVkIHJlc3VsdHNcbiAgICAgICAgLy8gSW5mbzogQ2Fubm90IHVzZSBgPT0gZmFsc2UgdG8gY2hlY2sgZmFsc2V5IHZhbHVlc2BcbiAgICAgICAgaWYgKCEhZ3JvdXBzICYmIGdyb3Vwcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBUT0RPOiBjcmVhdGUgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBleHBlY3RhdGlvbnNcbiAgICAgICAgICBpZiAoXy5pc1N0cmluZyhncm91cHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwbHVnaW4gZ3JvdXAgZXJyb3I6IGludmFsaWQgdHlwZSBmb3IgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNHcm91cFZhbGlkOiBib29sZWFuID0gXy5pc0FycmF5KGdyb3Vwcyk7XG4gICAgICAgICAgaWYgKCFpc0dyb3VwVmFsaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoQVBJX0VSUk9SLkJBRF9GT1JNQVRfVVNFUl9HUk9VUCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnKCdhdXRoZW50aWNhdGlvbiBmb3IgdXNlciAlbyB3YXMgc3VjY2Vzc2Z1bGx5LiBHcm91cHM6ICVvJywgdXNlcm5hbWUsIGdyb3Vwcyk7XG4gICAgICAgICAgcmV0dXJuIGNiKGVyciwgY3JlYXRlUmVtb3RlVXNlcih1c2VybmFtZSwgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRfdXNlcih1c2VyOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIGNiOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuc2xpY2UoMCk7XG4gICAgZGVidWcoJ2FkZCB1c2VyICVvJywgdXNlcik7XG4gICAgKGZ1bmN0aW9uIG5leHQoKTogdm9pZCB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zLnNoaWZ0KCkgYXMgSVBsdWdpbkF1dGg8Q29uZmlnPjtcbiAgICAgIGxldCBtZXRob2QgPSAnYWRkdXNlcic7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHBsdWdpblttZXRob2RdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWV0aG9kID0gJ2FkZF91c2VyJztcbiAgICAgICAgc2VsZi5sb2dnZXIud2FybigndGhlIHBsdWdpbiBtZXRob2QgYWRkX3VzZXIgaW4gdGhlIGF1dGggcGx1Z2luIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IG1ham9yIHJlbGVhc2UsIG5vdGlmeSB0byB0aGUgcGx1Z2luIGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHBsdWdpblttZXRob2RdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcC5hZGRfdXNlcigpIGV4ZWN1dGlvblxuICAgICAgICBwbHVnaW5bbWV0aG9kXSh1c2VyLCBwYXNzd29yZCwgZnVuY3Rpb24gKGVyciwgb2spOiB2b2lkIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcih7IHVzZXIsIGVycjogZXJyLm1lc3NhZ2UgfSwgJ3RoZSB1c2VyIEB7dXNlcn0gY291bGQgbm90IGJlaW5nIGFkZGVkLiBFcnJvcjogQHtlcnJ9Jyk7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICBzZWxmLmxvZ2dlci5pbmZvKHsgdXNlciB9LCAndGhlIHVzZXIgQHt1c2VyfSBoYXMgYmVlbiBhZGRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuYXV0aGVudGljYXRlKHVzZXIsIHBhc3N3b3JkLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyB1c2VyIHRvIGFjY2VzcyBhIHBhY2thZ2UuXG4gICAqL1xuICBwdWJsaWMgYWxsb3dfYWNjZXNzKHsgcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uIH06IEF1dGhQbHVnaW5QYWNrYWdlLCB1c2VyOiBSZW1vdGVVc2VyLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5wbHVnaW5zLnNsaWNlKDApO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHBrZ0FsbG93QWNjZXM6IEFsbG93QWNjZXNzID0geyBuYW1lOiBwYWNrYWdlTmFtZSwgdmVyc2lvbjogcGFja2FnZVZlcnNpb24gfTtcbiAgICBjb25zdCBwa2cgPSBPYmplY3QuYXNzaWduKHt9LCBwa2dBbGxvd0FjY2VzLCBnZXRNYXRjaGVkUGFja2FnZXNTcGVjKHBhY2thZ2VOYW1lLCB0aGlzLmNvbmZpZy5wYWNrYWdlcykpIGFzIEFsbG93QWNjZXNzICYgUGFja2FnZUFjY2VzcztcbiAgICBkZWJ1ZygnYWxsb3cgYWNjZXNzIGZvciAlbycsIHBhY2thZ2VOYW1lKTtcblxuICAgIChmdW5jdGlvbiBuZXh0KCk6IHZvaWQge1xuICAgICAgY29uc3QgcGx1Z2luOiBJUGx1Z2luQXV0aDxDb25maWc+ID0gcGx1Z2lucy5zaGlmdCgpIGFzIElQbHVnaW5BdXRoPENvbmZpZz47XG5cbiAgICAgIGlmIChfLmlzTmlsKHBsdWdpbikgfHwgXy5pc0Z1bmN0aW9uKHBsdWdpbi5hbGxvd19hY2Nlc3MpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW4uYWxsb3dfYWNjZXNzISh1c2VyLCBwa2csIGZ1bmN0aW9uIChlcnIsIG9rOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcih7IHBhY2thZ2VOYW1lLCBlcnIgfSwgJ2ZvcmJpZGRlbiBhY2Nlc3MgZm9yIEB7cGFja2FnZU5hbWV9LiBFcnJvcjogQHtlcnIubWVzc2FnZX0nKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSB9LCAnYWxsb3dlZCBhY2Nlc3MgZm9yIEB7cGFja2FnZU5hbWV9Jyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG9rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTsgLy8gY2IobnVsbCwgZmFsc2UpIGNhdXNlcyBuZXh0IHBsdWdpbiB0byByb2xsXG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9XG5cbiAgcHVibGljIGFsbG93X3VucHVibGlzaCh7IHBhY2thZ2VOYW1lLCBwYWNrYWdlVmVyc2lvbiB9OiBBdXRoUGx1Z2luUGFja2FnZSwgdXNlcjogUmVtb3RlVXNlciwgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3QgcGtnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IHBhY2thZ2VOYW1lLCB2ZXJzaW9uOiBwYWNrYWdlVmVyc2lvbiB9LCBnZXRNYXRjaGVkUGFja2FnZXNTcGVjKHBhY2thZ2VOYW1lLCB0aGlzLmNvbmZpZy5wYWNrYWdlcykpO1xuICAgIGRlYnVnKCdhbGxvdyB1bnB1Ymxpc2ggZm9yICVvJywgcGFja2FnZU5hbWUpO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKF8uaXNOaWwocGx1Z2luKSB8fCBfLmlzRnVuY3Rpb24ocGx1Z2luLmFsbG93X3VucHVibGlzaCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlYnVnKCdhbGxvdyB1bnB1Ymxpc2ggZm9yICVvIHBsdWdpbiBkb2VzIG5vdCBpbXBsZW1lbnQgYWxsb3dfdW5wdWJsaXNoJywgcGFja2FnZU5hbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsdWdpbi5hbGxvd191bnB1Ymxpc2ghKHVzZXIsIHBrZywgKGVyciwgb2s6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcih7IHBhY2thZ2VOYW1lLCB1c2VyOiB1c2VyPy5uYW1lIH0sICdAe3VzZXJ9IGZvcmJpZGRlbiBwdWJsaXNoIGZvciBAe3BhY2thZ2VOYW1lfSwgaXQgd2lsbCBmYWxsYmFjayBvbiB1bnB1Ymxpc2ggcGVybWlzc2lvbnMnKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfLmlzTmlsKG9rKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3dlIGJ5cGFzcyB1bnB1Ymxpc2ggZm9yICVvLCBwdWJsaXNoIHdpbGwgaGFuZGxlIHRoZSBhY2Nlc3MnLCBwYWNrYWdlTmFtZSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbG93X3B1Ymxpc2goLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSwgdXNlcjogdXNlcj8ubmFtZSB9LCAnQHt1c2VyfSBhbGxvd2VkIHVucHVibGlzaCBmb3IgQHtwYWNrYWdlTmFtZX0nKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBvayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdXNlciB0byBwdWJsaXNoIGEgcGFja2FnZS5cbiAgICovXG4gIHB1YmxpYyBhbGxvd19wdWJsaXNoKHsgcGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uIH06IEF1dGhQbHVnaW5QYWNrYWdlLCB1c2VyOiBSZW1vdGVVc2VyLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5wbHVnaW5zLnNsaWNlKDApO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHBrZyA9IE9iamVjdC5hc3NpZ24oeyBuYW1lOiBwYWNrYWdlTmFtZSwgdmVyc2lvbjogcGFja2FnZVZlcnNpb24gfSwgZ2V0TWF0Y2hlZFBhY2thZ2VzU3BlYyhwYWNrYWdlTmFtZSwgdGhpcy5jb25maWcucGFja2FnZXMpKTtcbiAgICBkZWJ1ZygnYWxsb3cgcHVibGlzaCBmb3IgJW8gaW5pdCB8IHBsdWdpbnM6ICVvJywgcGFja2FnZU5hbWUsIHBsdWdpbnMpO1xuICAgIChmdW5jdGlvbiBuZXh0KCk6IHZvaWQge1xuICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2lucy5zaGlmdCgpO1xuXG4gICAgICBpZiAoXy5pc05pbChwbHVnaW4pIHx8IF8uaXNGdW5jdGlvbihwbHVnaW4uYWxsb3dfcHVibGlzaCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlYnVnKCdhbGxvdyBwdWJsaXNoIGZvciAlbyBwbHVnaW4gZG9lcyBub3QgaW1wbGVtZW50IGFsbG93X3B1Ymxpc2gnLCBwYWNrYWdlTmFtZSk7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHBsdWdpbi5hbGxvd19wdWJsaXNoKHVzZXIsIHBrZywgKGVycjogVmVyZGFjY2lvRXJyb3IsIG9rOiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChfLmlzTmlsKGVycikgPT09IGZhbHNlICYmIF8uaXNFcnJvcihlcnIpKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoeyBwYWNrYWdlTmFtZSwgdXNlcjogdXNlcj8ubmFtZSB9LCAnQHt1c2VyfSBpcyBmb3JiaWRkZW4gcHVibGlzaCBmb3IgQHtwYWNrYWdlTmFtZX0nKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSwgdXNlcjogdXNlcj8ubmFtZSB9LCAnQHt1c2VyfSBpcyBhbGxvd2VkIHB1Ymxpc2ggZm9yIEB7cGFja2FnZU5hbWV9Jyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG9rKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnYWxsb3cgcHVibGlzaCBza2lwIHZhbGlkYXRpb24gZm9yICVvJywgcGFja2FnZU5hbWUpO1xuICAgICAgICBuZXh0KCk7IC8vIGNiKG51bGwsIGZhbHNlKSBjYXVzZXMgbmV4dCBwbHVnaW4gdG8gcm9sbFxuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIHB1YmxpYyBhcGlKV1RtaWRkbGV3YXJlKCk6IEZ1bmN0aW9uIHtcbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5wbHVnaW5zLnNsaWNlKDApO1xuICAgIGNvbnN0IGhlbHBlcnMgPSB7IGNyZWF0ZUFub255bW91c1JlbW90ZVVzZXIsIGNyZWF0ZVJlbW90ZVVzZXIgfTtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICBpZiAocGx1Z2luLmFwaUpXVG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5hcGlKV1RtaWRkbGV3YXJlKGhlbHBlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiAkUmVzcG9uc2VFeHRlbmQsIF9uZXh0OiBOZXh0RnVuY3Rpb24pOiB2b2lkID0+IHtcbiAgICAgIHJlcS5wYXVzZSgpO1xuXG4gICAgICBjb25zdCBuZXh0ID0gZnVuY3Rpb24gKGVycjogVmVyZGFjY2lvRXJyb3IgfCB2b2lkKTogdm9pZCB7XG4gICAgICAgIHJlcS5yZXN1bWUoKTtcbiAgICAgICAgLy8gdW5jb21tZW50IHRoaXMgdG8gcmVqZWN0IHVzZXJzIHdpdGggYmFkIGF1dGggaGVhZGVyc1xuICAgICAgICAvLyByZXR1cm4gX25leHQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAvLyBzd2FsbG93IGVycm9yLCB1c2VyIHJlbWFpbnMgdW5hdXRob3JpemVkXG4gICAgICAgIC8vIHNldCByZW1vdGVVc2VyRXJyb3IgdG8gaW5kaWNhdGUgdGhhdCB1c2VyIHdhcyBhdHRlbXB0aW5nIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXEucmVtb3RlX3VzZXIuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX25leHQoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9pc1JlbW90ZVVzZXJWYWxpZChyZXEucmVtb3RlX3VzZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGluIGNhc2UgYXV0aCBoZWFkZXIgZG9lcyBub3QgZXhpc3Qgd2UgcmV0dXJuIGFub255bW91cyBmdW5jdGlvblxuICAgICAgcmVxLnJlbW90ZV91c2VyID0gY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlcigpO1xuXG4gICAgICBjb25zdCB7IGF1dGhvcml6YXRpb24gfSA9IHJlcS5oZWFkZXJzO1xuICAgICAgaWYgKF8uaXNOaWwoYXV0aG9yaXphdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0F1dGhIZWFkZXJWYWxpZChhdXRob3JpemF0aW9uKSkge1xuICAgICAgICBkZWJ1ZygnYXBpIG1pZGRsZXdhcmUgYXV0aCBoZWF0aGVyIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0QmFkUmVxdWVzdChBUElfRVJST1IuQkFEX0FVVEhfSEVBREVSKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlY3VyaXR5OiBTZWN1cml0eSA9IGdldFNlY3VyaXR5KHRoaXMuY29uZmlnKTtcbiAgICAgIGNvbnN0IHsgc2VjcmV0IH0gPSB0aGlzLmNvbmZpZztcblxuICAgICAgaWYgKGlzQUVTTGVnYWN5KHNlY3VyaXR5KSkge1xuICAgICAgICBkZWJ1ZygnYXBpIG1pZGRsZXdhcmUgdXNpbmcgbGVnYWN5IGF1dGggdG9rZW4nKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQUVTTWlkZGxld2FyZShyZXEsIHNlY3VyaXR5LCBzZWNyZXQsIGF1dGhvcml6YXRpb24sIG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2FwaSBtaWRkbGV3YXJlIHVzaW5nIEpXVCBhdXRoIHRva2VuJyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUpXVEFQSU1pZGRsZXdhcmUocmVxLCBzZWN1cml0eSwgc2VjcmV0LCBhdXRob3JpemF0aW9uLCBuZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlSldUQVBJTWlkZGxld2FyZShyZXE6ICRSZXF1ZXN0RXh0ZW5kLCBzZWN1cml0eTogU2VjdXJpdHksIHNlY3JldDogc3RyaW5nLCBhdXRob3JpemF0aW9uOiBzdHJpbmcsIG5leHQ6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgeyBzY2hlbWUsIHRva2VuIH0gPSBwYXJzZUF1dGhUb2tlbkhlYWRlcihhdXRob3JpemF0aW9uKTtcbiAgICBpZiAoc2NoZW1lLnRvVXBwZXJDYXNlKCkgPT09IFRPS0VOX0JBU0lDLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIC8vIHRoaXMgc2hvdWxkIGhhcHBlbiB3aGVuIGNsaWVudCB0cmllcyB0byBsb2dpbiB3aXRoIGFuIGV4aXN0aW5nIHVzZXJcbiAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gY29udmVydFBheWxvYWRUb0Jhc2U2NCh0b2tlbikudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHsgdXNlciwgcGFzc3dvcmQgfSA9IHBhcnNlQmFzaWNQYXlsb2FkKGNyZWRlbnRpYWxzKSBhcyBBRVNQYXlsb2FkO1xuICAgICAgdGhpcy5hdXRoZW50aWNhdGUodXNlciwgcGFzc3dvcmQsIChlcnIsIHVzZXIpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXEucmVtb3RlX3VzZXIgPSB1c2VyO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXEucmVtb3RlX3VzZXIgPSBjcmVhdGVBbm9ueW1vdXNSZW1vdGVVc2VyKCk7XG4gICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gand0IGhhbmRsZXJcbiAgICAgIGNvbnN0IGNyZWRlbnRpYWxzOiBhbnkgPSBnZXRNaWRkbGV3YXJlQ3JlZGVudGlhbHMoc2VjdXJpdHksIHNlY3JldCwgYXV0aG9yaXphdGlvbik7XG4gICAgICBpZiAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgLy8gaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCB3ZSByZWx5IG9uIGl0XG4gICAgICAgIHJlcS5yZW1vdGVfdXNlciA9IGNyZWRlbnRpYWxzO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aXRoIEpXVCB0aHJvdyA0MDFcbiAgICAgICAgbmV4dChFcnJvckNvZGUuZ2V0Rm9yYmlkZGVuKEFQSV9FUlJPUi5CQURfVVNFUk5BTUVfUEFTU1dPUkQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVBRVNNaWRkbGV3YXJlKHJlcTogJFJlcXVlc3RFeHRlbmQsIHNlY3VyaXR5OiBTZWN1cml0eSwgc2VjcmV0OiBzdHJpbmcsIGF1dGhvcml6YXRpb246IHN0cmluZywgbmV4dDogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICBjb25zdCBjcmVkZW50aWFsczogYW55ID0gZ2V0TWlkZGxld2FyZUNyZWRlbnRpYWxzKHNlY3VyaXR5LCBzZWNyZXQsIGF1dGhvcml6YXRpb24pO1xuICAgIGlmIChjcmVkZW50aWFscykge1xuICAgICAgY29uc3QgeyB1c2VyLCBwYXNzd29yZCB9ID0gY3JlZGVudGlhbHM7XG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZSh1c2VyLCBwYXNzd29yZCwgKGVyciwgdXNlcik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlcS5yZW1vdGVfdXNlciA9IHVzZXI7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcS5yZW1vdGVfdXNlciA9IGNyZWF0ZUFub255bW91c1JlbW90ZVVzZXIoKTtcbiAgICAgICAgICBuZXh0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBmb3JjZSBucG0gY2xpZW50IHRvIGFzayBhZ2FpbiB3aXRoIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0QmFkUmVxdWVzdChBUElfRVJST1IuQkFEX0FVVEhfSEVBREVSKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNSZW1vdGVVc2VyVmFsaWQocmVtb3RlX3VzZXI6IFJlbW90ZVVzZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChyZW1vdGVfdXNlcikgPT09IGZhbHNlICYmIF8uaXNVbmRlZmluZWQocmVtb3RlX3VzZXIubmFtZSkgPT09IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEpXVCBtaWRkbGV3YXJlIGZvciBXZWJVSVxuICAgKi9cbiAgcHVibGljIHdlYlVJSldUbWlkZGxld2FyZSgpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuIChyZXE6ICRSZXF1ZXN0RXh0ZW5kLCByZXM6ICRSZXNwb25zZUV4dGVuZCwgX25leHQ6IE5leHRGdW5jdGlvbik6IHZvaWQgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzUmVtb3RlVXNlclZhbGlkKHJlcS5yZW1vdGVfdXNlcikpIHtcbiAgICAgICAgcmV0dXJuIF9uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5wYXVzZSgpO1xuICAgICAgY29uc3QgbmV4dCA9IChlcnI6IFZlcmRhY2Npb0Vycm9yIHwgdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgICByZXEucmVzdW1lKCk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyByZXEucmVtb3RlX3VzZXIuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICByZXMuc3RhdHVzKGVyci5zdGF0dXNDb2RlKS5zZW5kKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbmV4dCgpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uIH0gPSByZXEuaGVhZGVycztcbiAgICAgIGlmIChfLmlzTmlsKGF1dGhvcml6YXRpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBdXRoSGVhZGVyVmFsaWQoYXV0aG9yaXphdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldEJhZFJlcXVlc3QoQVBJX0VSUk9SLkJBRF9BVVRIX0hFQURFUikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbiA9IChhdXRob3JpemF0aW9uIHx8ICcnKS5yZXBsYWNlKGAke1RPS0VOX0JFQVJFUn0gYCwgJycpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY3JlZGVudGlhbHM7XG4gICAgICB0cnkge1xuICAgICAgICBjcmVkZW50aWFscyA9IHZlcmlmeUpXVFBheWxvYWQodG9rZW4sIHRoaXMuY29uZmlnLnNlY3JldCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gRklYTUU6IGludGVuZGVkIGJlaGF2aW91ciwgZG8gd2Ugd2FudCBpdD9cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzUmVtb3RlVXNlclZhbGlkKGNyZWRlbnRpYWxzKSkge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGdyb3VwcyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgcmVxLnJlbW90ZV91c2VyID0gY3JlYXRlUmVtb3RlVXNlcihuYW1lLCBncm91cHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxLnJlbW90ZV91c2VyID0gY3JlYXRlQW5vbnltb3VzUmVtb3RlVXNlcigpO1xuICAgICAgfVxuXG4gICAgICBuZXh0KCk7XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBqd3RFbmNyeXB0KHVzZXI6IFJlbW90ZVVzZXIsIHNpZ25PcHRpb25zOiBKV1RTaWduT3B0aW9ucyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgeyByZWFsX2dyb3VwcywgbmFtZSwgZ3JvdXBzIH0gPSB1c2VyO1xuICAgIGNvbnN0IHJlYWxHcm91cHNWYWxpZGF0ZWQgPSBfLmlzTmlsKHJlYWxfZ3JvdXBzKSA/IFtdIDogcmVhbF9ncm91cHM7XG4gICAgY29uc3QgZ3JvdXBlZEdyb3VwcyA9IF8uaXNOaWwoZ3JvdXBzKSA/IHJlYWxfZ3JvdXBzIDogZ3JvdXBzLmNvbmNhdChyZWFsR3JvdXBzVmFsaWRhdGVkKTtcbiAgICBjb25zdCBwYXlsb2FkOiBSZW1vdGVVc2VyID0ge1xuICAgICAgcmVhbF9ncm91cHM6IHJlYWxHcm91cHNWYWxpZGF0ZWQsXG4gICAgICBuYW1lLFxuICAgICAgZ3JvdXBzOiBncm91cGVkR3JvdXBzLFxuICAgIH07XG5cbiAgICBjb25zdCB0b2tlbjogc3RyaW5nID0gYXdhaXQgc2lnblBheWxvYWQocGF5bG9hZCwgdGhpcy5zZWNyZXQsIHNpZ25PcHRpb25zKTtcblxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0IGEgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIGFlc0VuY3J5cHQoYnVmOiBCdWZmZXIpOiBCdWZmZXIge1xuICAgIHJldHVybiBhZXNFbmNyeXB0KGJ1ZiwgdGhpcy5zZWNyZXQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGg7XG4iXX0=