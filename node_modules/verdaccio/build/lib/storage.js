"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _stream = _interopRequireDefault(require("stream"));

var _lodash = _interopRequireDefault(require("lodash"));

var _async = _interopRequireDefault(require("async"));

var _streams = require("@verdaccio/streams");

var _logger = require("../lib/logger");

var _upStorage = _interopRequireDefault(require("./up-storage"));

var _search = _interopRequireDefault(require("./search"));

var _constants = require("./constants");

var _localStorage = _interopRequireDefault(require("./local-storage"));

var _storageUtils = require("./storage-utils");

var _uplinkUtil = require("./uplink-util");

var _metadataUtils = require("./metadata-utils");

var _utils = require("./utils");

var _configUtils = require("./config-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Storage {
  constructor(config) {
    _defineProperty(this, "localStorage", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "logger", void 0);

    _defineProperty(this, "uplinks", void 0);

    _defineProperty(this, "filters", void 0);

    this.config = config;
    this.uplinks = (0, _uplinkUtil.setupUpLinks)(config);
    this.logger = _logger.logger;
    this.filters = []; // @ts-ignore

    this.localStorage = null;
  }

  init(config, filters = []) {
    this.filters = filters;
    this.localStorage = new _localStorage.default(this.config, _logger.logger);
    return this.localStorage.getSecret(config);
  }
  /**
   *  Add a {name} package to a system
   Function checks if package with the same name is available from uplinks.
   If it isn't, we create package locally
   Used storages: local (write) && uplinks
   */


  async addPackage(name, metadata, callback) {
    try {
      await (0, _storageUtils.checkPackageLocal)(name, this.localStorage);
      await (0, _storageUtils.checkPackageRemote)(name, this._isAllowPublishOffline(), this._syncUplinksMetadata.bind(this));
      await (0, _storageUtils.publishPackage)(name, metadata, this.localStorage);
      callback();
    } catch (err) {
      callback(err);
    }
  }

  _isAllowPublishOffline() {
    return typeof this.config.publish !== 'undefined' && _lodash.default.isBoolean(this.config.publish.allow_offline) && this.config.publish.allow_offline;
  }

  readTokens(filter) {
    return this.localStorage.readTokens(filter);
  }

  saveToken(token) {
    return this.localStorage.saveToken(token);
  }

  deleteToken(user, tokenKey) {
    return this.localStorage.deleteToken(user, tokenKey);
  }
  /**
   * Add a new version of package {name} to a system
   Used storages: local (write)
   */


  addVersion(name, version, metadata, tag, callback) {
    this.localStorage.addVersion(name, version, metadata, tag, callback);
  }
  /**
   * Tags a package version with a provided tag
   Used storages: local (write)
   */


  mergeTags(name, tagHash, callback) {
    this.localStorage.mergeTags(name, tagHash, callback);
  }
  /**
   * Change an existing package (i.e. unpublish one version)
   Function changes a package info from local storage and all uplinks with write access./
   Used storages: local (write)
   */


  changePackage(name, metadata, revision, callback) {
    this.localStorage.changePackage(name, metadata, revision, callback);
  }
  /**
   * Remove a package from a system
   Function removes a package from local storage
   Used storages: local (write)
   */


  removePackage(name, callback) {
    this.localStorage.removePackage(name, callback); // update the indexer

    _search.default.remove(name);
  }
  /**
   Remove a tarball from a system
   Function removes a tarball from local storage.
   Tarball in question should not be linked to in any existing
   versions, i.e. package version should be unpublished first.
   Used storage: local (write)
   */


  removeTarball(name, filename, revision, callback) {
    this.localStorage.removeTarball(name, filename, revision, callback);
  }
  /**
   * Upload a tarball for {name} package
   Function is synchronous and returns a WritableStream
   Used storages: local (write)
   */


  addTarball(name, filename) {
    return this.localStorage.addTarball(name, filename);
  }

  hasLocalTarball(name, filename) {
    const self = this;
    return new Promise((resolve, reject) => {
      let localStream = self.localStorage.getTarball(name, filename);
      let isOpen = false;
      localStream.on('error', err => {
        if (isOpen || err.status !== _constants.HTTP_STATUS.NOT_FOUND) {
          reject(err);
        } // local reported 404 or request was aborted already


        if (localStream) {
          localStream.abort();
          localStream = null;
        }

        resolve(false);
      });
      localStream.on('open', function () {
        isOpen = true;
        localStream.abort();
        localStream = null;
        resolve(true);
      });
    });
  }
  /**
   Get a tarball from a storage for {name} package
   Function is synchronous and returns a ReadableStream
   Function tries to read tarball locally, if it fails then it reads package
   information in order to figure out where we can get this tarball from
   Used storages: local || uplink (just one)
   */


  getTarball(name, filename) {
    const readStream = new _streams.ReadTarball({});

    readStream.abort = function () {};

    const self = this; // if someone requesting tarball, it means that we should already have some
    // information about it, so fetching package info is unnecessary
    // trying local first
    // flow: should be IReadTarball

    let localStream = self.localStorage.getTarball(name, filename);
    let isOpen = false;
    localStream.on('error', err => {
      if (isOpen || err.status !== _constants.HTTP_STATUS.NOT_FOUND) {
        return readStream.emit('error', err);
      } // local reported 404


      const err404 = err;
      localStream.abort();
      localStream = null; // we force for garbage collector

      self.localStorage.getPackageMetadata(name, (err, info) => {
        if (_lodash.default.isNil(err) && info._distfiles && _lodash.default.isNil(info._distfiles[filename]) === false) {
          // information about this file exists locally
          serveFile(info._distfiles[filename]);
        } else {
          // we know nothing about this file, trying to get information elsewhere
          self._syncUplinksMetadata(name, info, {}, (err, info) => {
            if (_lodash.default.isNil(err) === false) {
              return readStream.emit('error', err);
            }

            if (_lodash.default.isNil(info._distfiles) || _lodash.default.isNil(info._distfiles[filename])) {
              return readStream.emit('error', err404);
            }

            serveFile(info._distfiles[filename]);
          });
        }
      });
    });
    localStream.on('content-length', function (v) {
      readStream.emit('content-length', v);
    });
    localStream.on('open', function () {
      isOpen = true;
      localStream.pipe(readStream);
    });
    return readStream;
    /**
     * Fetch and cache local/remote packages.
     * @param {Object} file define the package shape
     */

    function serveFile(file) {
      let uplink = null;

      for (const uplinkId in self.uplinks) {
        if ((0, _configUtils.hasProxyTo)(name, uplinkId, self.config.packages)) {
          uplink = self.uplinks[uplinkId];
        }
      }

      if (uplink == null) {
        uplink = new _upStorage.default({
          url: file.url,
          cache: true,
          _autogenerated: true
        }, self.config);
      }

      let savestream = null;

      if (uplink.config.cache) {
        savestream = self.localStorage.addTarball(name, filename);
      }

      let on_open = function () {
        // prevent it from being called twice
        on_open = function () {};

        const rstream2 = uplink.fetchTarball(file.url);
        rstream2.on('error', function (err) {
          if (savestream) {
            savestream.abort();
          }

          savestream = null;
          readStream.emit('error', err);
        });
        rstream2.on('end', function () {
          if (savestream) {
            savestream.done();
          }
        });
        rstream2.on('content-length', function (v) {
          readStream.emit('content-length', v);

          if (savestream) {
            savestream.emit('content-length', v);
          }
        });
        rstream2.pipe(readStream);

        if (savestream) {
          rstream2.pipe(savestream);
        }
      };

      if (savestream) {
        savestream.on('open', function () {
          on_open();
        });
        savestream.on('error', function (err) {
          self.logger.warn({
            err: err,
            fileName: file
          }, 'error saving file @{fileName}: @{err.message}\n@{err.stack}');

          if (savestream) {
            savestream.abort();
          }

          savestream = null;
          on_open();
        });
      } else {
        on_open();
      }
    }
  }
  /**
   Retrieve a package metadata for {name} package
   Function invokes localStorage.getPackage and uplink.get_package for every
   uplink with proxy_access rights against {name} and combines results
   into one json object
   Used storages: local && uplink (proxy_access)
    * @param {object} options
   * @property {string} options.name Package Name
   * @property {object}  options.req Express `req` object
   * @property {boolean} options.keepUpLinkData keep up link info in package meta, last update, etc.
   * @property {function} options.callback Callback for receive data
   */


  getPackage(options) {
    this.localStorage.getPackageMetadata(options.name, (err, data) => {
      if (err && (!err.status || err.status >= _constants.HTTP_STATUS.INTERNAL_ERROR)) {
        // report internal errors right away
        return options.callback(err);
      }

      this._syncUplinksMetadata(options.name, data, {
        req: options.req,
        uplinksLook: options.uplinksLook
      }, function getPackageSynUpLinksCallback(err, result, uplinkErrors) {
        if (err) {
          return options.callback(err);
        }

        (0, _utils.normalizeDistTags)((0, _storageUtils.cleanUpLinksRef)(options.keepUpLinkData, result)); // npm can throw if this field doesn't exist

        result._attachments = {};
        options.callback(null, result, uplinkErrors);
      });
    });
  }
  /**
   Retrieve remote and local packages more recent than {startkey}
   Function streams all packages from all uplinks first, and then
   local packages.
   Note that local packages could override registry ones just because
   they appear in JSON last. That's a trade-off we make to avoid
   memory issues.
   Used storages: local && uplink (proxy_access)
   * @param {*} startkey
   * @param {*} options
   * @return {Stream}
   */


  search(startkey, options) {
    const self = this;
    const searchStream = new _stream.default.PassThrough({
      objectMode: true
    });

    _async.default.eachSeries(Object.keys(this.uplinks), function (up_name, cb) {
      var _options$req, _options$req$query;

      // shortcut: if `local=1` is supplied, don't call uplinks
      if (((_options$req = options.req) === null || _options$req === void 0 ? void 0 : (_options$req$query = _options$req.query) === null || _options$req$query === void 0 ? void 0 : _options$req$query.local) !== undefined) {
        return cb();
      }

      _logger.logger.info(`search for uplink ${up_name}`); // search by keyword for each uplink


      const uplinkStream = self.uplinks[up_name].search(options); // join uplink stream with streams PassThrough

      uplinkStream.pipe(searchStream, {
        end: false
      });
      uplinkStream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'uplink error: @{err.message}');
        cb(); // to avoid call callback more than once

        cb = function () {};
      });
      uplinkStream.on('end', function () {
        cb(); // to avoid call callback more than once

        cb = function () {};
      });

      searchStream.abort = function () {
        if (uplinkStream.abort) {
          uplinkStream.abort();
        }

        cb(); // to avoid call callback more than once

        cb = function () {};
      };
    }, // executed after all series
    function () {
      // attach a local search results
      const localSearchStream = self.localStorage.search(startkey, options);

      searchStream.abort = function () {
        localSearchStream.abort();
      };

      localSearchStream.pipe(searchStream, {
        end: true
      });
      localSearchStream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'search error: @{err.message}');
        searchStream.end();
      });
    });

    return searchStream;
  }
  /**
   * Retrieve only private local packages
   * @param {*} callback
   */


  getLocalDatabase(callback) {
    const self = this;
    this.localStorage.storagePlugin.get((err, locals) => {
      if (err) {
        callback(err);
      }

      const packages = [];

      const getPackage = function (itemPkg) {
        self.localStorage.getPackageMetadata(locals[itemPkg], function (err, pkgMetadata) {
          if (_lodash.default.isNil(err)) {
            const latest = pkgMetadata[_constants.DIST_TAGS].latest;

            if (latest && pkgMetadata.versions[latest]) {
              const version = pkgMetadata.versions[latest];
              const timeList = pkgMetadata.time;
              const time = timeList[latest]; // @ts-ignore

              version.time = time; // Add for stars api
              // @ts-ignore

              version.users = pkgMetadata.users;
              packages.push(version);
            } else {
              self.logger.warn({
                package: locals[itemPkg]
              }, 'package @{package} does not have a "latest" tag?');
            }
          }

          if (itemPkg >= locals.length - 1) {
            callback(null, packages);
          } else {
            getPackage(itemPkg + 1);
          }
        });
      };

      if (locals.length) {
        getPackage(0);
      } else {
        callback(null, []);
      }
    });
  }
  /**
   * Function fetches package metadata from uplinks and synchronizes it with local data
   if package is available locally, it MUST be provided in pkginfo
   returns callback(err, result, uplink_errors)
   */


  _syncUplinksMetadata(name, packageInfo, options, callback) {
    let found = true;
    const self = this;
    const upLinks = [];
    const hasToLookIntoUplinks = _lodash.default.isNil(options.uplinksLook) || options.uplinksLook;

    if (!packageInfo) {
      found = false;
      packageInfo = (0, _storageUtils.generatePackageTemplate)(name);
    }

    for (const uplink in this.uplinks) {
      if ((0, _configUtils.hasProxyTo)(name, uplink, this.config.packages) && hasToLookIntoUplinks) {
        upLinks.push(this.uplinks[uplink]);
      }
    }

    _async.default.map(upLinks, (upLink, cb) => {
      const _options = Object.assign({}, options);

      const upLinkMeta = packageInfo._uplinks[upLink.upname];

      if ((0, _utils.isObject)(upLinkMeta)) {
        const fetched = upLinkMeta.fetched;

        if (fetched && Date.now() - fetched < upLink.maxage) {
          return cb();
        }

        _options.etag = upLinkMeta.etag;
      }

      upLink.getRemoteMetadata(name, _options, (err, upLinkResponse, eTag) => {
        if (err && err.remoteStatus === 304) {
          upLinkMeta.fetched = Date.now();
        }

        if (err || !upLinkResponse) {
          return cb(null, [err || _utils.ErrorCode.getInternalError('no data')]);
        }

        try {
          (0, _utils.validateMetadata)(upLinkResponse, name);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json validating error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        }

        packageInfo._uplinks[upLink.upname] = {
          etag: eTag,
          fetched: Date.now()
        };
        packageInfo.time = (0, _storageUtils.mergeUplinkTimeIntoLocal)(packageInfo, upLinkResponse);
        (0, _uplinkUtil.updateVersionsHiddenUpLink)(upLinkResponse.versions, upLink);

        try {
          (0, _metadataUtils.mergeVersions)(packageInfo, upLinkResponse);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json parsing error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        } // if we got to this point, assume that the correct package exists
        // on the uplink


        found = true;
        cb();
      });
    }, // @ts-ignore
    (err, upLinksErrors) => {
      (0, _assert.default)(!err && Array.isArray(upLinksErrors)); // Check for connection timeout or reset errors with uplink(s)
      // (these should be handled differently from the package not being found)

      if (!found) {
        let uplinkTimeoutError;

        for (let i = 0; i < upLinksErrors.length; i++) {
          if (upLinksErrors[i]) {
            for (let j = 0; j < upLinksErrors[i].length; j++) {
              if (upLinksErrors[i][j]) {
                const code = upLinksErrors[i][j].code;

                if (code === 'ETIMEDOUT' || code === 'ESOCKETTIMEDOUT' || code === 'ECONNRESET') {
                  uplinkTimeoutError = true;
                  break;
                }
              }
            }
          }
        }

        if (uplinkTimeoutError) {
          return callback(_utils.ErrorCode.getServiceUnavailable(), null, upLinksErrors);
        }

        return callback(_utils.ErrorCode.getNotFound(_constants.API_ERROR.NO_PACKAGE), null, upLinksErrors);
      }

      if (upLinks.length === 0) {
        return callback(null, packageInfo);
      }

      self.localStorage.updateVersions(name, packageInfo, async (err, packageJsonLocal) => {
        if (err) {
          return callback(err);
        } // Any error here will cause a 404, like an uplink error. This is likely the right thing to do
        // as a broken filter is a security risk.


        const filterErrors = []; // This MUST be done serially and not in parallel as they modify packageJsonLocal

        for (const filter of self.filters) {
          try {
            // These filters can assume it's save to modify packageJsonLocal and return it directly for
            // performance (i.e. need not be pure)
            packageJsonLocal = await filter.filter_metadata(packageJsonLocal);
          } catch (err) {
            filterErrors.push(err);
          }
        }

        callback(null, packageJsonLocal, _lodash.default.concat(upLinksErrors, filterErrors));
      });
    });
  }
  /**
   * Set a hidden value for each version.
   * @param {Array} versions list of version
   * @param {String} upLink uplink name
   * @private
   */


  _updateVersionsHiddenUpLink(versions, upLink) {
    for (const i in versions) {
      if (Object.prototype.hasOwnProperty.call(versions, i)) {
        const version = versions[i]; // holds a "hidden" value to be used by the package storage.
        // $FlowFixMe

        version[Symbol.for('__verdaccio_uplink')] = upLink.upname;
      }
    }
  }

}

var _default = Storage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvc3RvcmFnZS50cyJdLCJuYW1lcyI6WyJTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJ1cGxpbmtzIiwibG9nZ2VyIiwiZmlsdGVycyIsImxvY2FsU3RvcmFnZSIsImluaXQiLCJMb2NhbFN0b3JhZ2UiLCJnZXRTZWNyZXQiLCJhZGRQYWNrYWdlIiwibmFtZSIsIm1ldGFkYXRhIiwiY2FsbGJhY2siLCJfaXNBbGxvd1B1Ymxpc2hPZmZsaW5lIiwiX3N5bmNVcGxpbmtzTWV0YWRhdGEiLCJiaW5kIiwiZXJyIiwicHVibGlzaCIsIl8iLCJpc0Jvb2xlYW4iLCJhbGxvd19vZmZsaW5lIiwicmVhZFRva2VucyIsImZpbHRlciIsInNhdmVUb2tlbiIsInRva2VuIiwiZGVsZXRlVG9rZW4iLCJ1c2VyIiwidG9rZW5LZXkiLCJhZGRWZXJzaW9uIiwidmVyc2lvbiIsInRhZyIsIm1lcmdlVGFncyIsInRhZ0hhc2giLCJjaGFuZ2VQYWNrYWdlIiwicmV2aXNpb24iLCJyZW1vdmVQYWNrYWdlIiwiU2VhcmNoIiwicmVtb3ZlIiwicmVtb3ZlVGFyYmFsbCIsImZpbGVuYW1lIiwiYWRkVGFyYmFsbCIsImhhc0xvY2FsVGFyYmFsbCIsInNlbGYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImxvY2FsU3RyZWFtIiwiZ2V0VGFyYmFsbCIsImlzT3BlbiIsIm9uIiwic3RhdHVzIiwiSFRUUF9TVEFUVVMiLCJOT1RfRk9VTkQiLCJhYm9ydCIsInJlYWRTdHJlYW0iLCJSZWFkVGFyYmFsbCIsImVtaXQiLCJlcnI0MDQiLCJnZXRQYWNrYWdlTWV0YWRhdGEiLCJpbmZvIiwiaXNOaWwiLCJfZGlzdGZpbGVzIiwic2VydmVGaWxlIiwidiIsInBpcGUiLCJmaWxlIiwidXBsaW5rIiwidXBsaW5rSWQiLCJwYWNrYWdlcyIsIlByb3h5U3RvcmFnZSIsInVybCIsImNhY2hlIiwiX2F1dG9nZW5lcmF0ZWQiLCJzYXZlc3RyZWFtIiwib25fb3BlbiIsInJzdHJlYW0yIiwiZmV0Y2hUYXJiYWxsIiwiZG9uZSIsIndhcm4iLCJmaWxlTmFtZSIsImdldFBhY2thZ2UiLCJvcHRpb25zIiwiZGF0YSIsIklOVEVSTkFMX0VSUk9SIiwicmVxIiwidXBsaW5rc0xvb2siLCJnZXRQYWNrYWdlU3luVXBMaW5rc0NhbGxiYWNrIiwicmVzdWx0IiwidXBsaW5rRXJyb3JzIiwia2VlcFVwTGlua0RhdGEiLCJfYXR0YWNobWVudHMiLCJzZWFyY2giLCJzdGFydGtleSIsInNlYXJjaFN0cmVhbSIsIlN0cmVhbSIsIlBhc3NUaHJvdWdoIiwib2JqZWN0TW9kZSIsImFzeW5jIiwiZWFjaFNlcmllcyIsIk9iamVjdCIsImtleXMiLCJ1cF9uYW1lIiwiY2IiLCJxdWVyeSIsImxvY2FsIiwidW5kZWZpbmVkIiwidXBsaW5rU3RyZWFtIiwiZW5kIiwiZXJyb3IiLCJsb2NhbFNlYXJjaFN0cmVhbSIsImdldExvY2FsRGF0YWJhc2UiLCJzdG9yYWdlUGx1Z2luIiwiZ2V0IiwibG9jYWxzIiwiaXRlbVBrZyIsInBrZ01ldGFkYXRhIiwibGF0ZXN0IiwiRElTVF9UQUdTIiwidmVyc2lvbnMiLCJ0aW1lTGlzdCIsInRpbWUiLCJ1c2VycyIsInB1c2giLCJwYWNrYWdlIiwibGVuZ3RoIiwicGFja2FnZUluZm8iLCJmb3VuZCIsInVwTGlua3MiLCJoYXNUb0xvb2tJbnRvVXBsaW5rcyIsIm1hcCIsInVwTGluayIsIl9vcHRpb25zIiwiYXNzaWduIiwidXBMaW5rTWV0YSIsIl91cGxpbmtzIiwidXBuYW1lIiwiZmV0Y2hlZCIsIkRhdGUiLCJub3ciLCJtYXhhZ2UiLCJldGFnIiwiZ2V0UmVtb3RlTWV0YWRhdGEiLCJ1cExpbmtSZXNwb25zZSIsImVUYWciLCJyZW1vdGVTdGF0dXMiLCJFcnJvckNvZGUiLCJnZXRJbnRlcm5hbEVycm9yIiwic3ViIiwidXBMaW5rc0Vycm9ycyIsIkFycmF5IiwiaXNBcnJheSIsInVwbGlua1RpbWVvdXRFcnJvciIsImkiLCJqIiwiY29kZSIsImdldFNlcnZpY2VVbmF2YWlsYWJsZSIsImdldE5vdEZvdW5kIiwiQVBJX0VSUk9SIiwiTk9fUEFDS0FHRSIsInVwZGF0ZVZlcnNpb25zIiwicGFja2FnZUpzb25Mb2NhbCIsImZpbHRlckVycm9ycyIsImZpbHRlcl9tZXRhZGF0YSIsImNvbmNhdCIsIl91cGRhdGVWZXJzaW9uc0hpZGRlblVwTGluayIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIlN5bWJvbCIsImZvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUtBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxPQUFOLENBQXlDO0FBT2hDQyxFQUFBQSxXQUFXLENBQUNDLE1BQUQsRUFBaUI7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFDakMsU0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLDhCQUFhRCxNQUFiLENBQWY7QUFDQSxTQUFLRSxNQUFMLEdBQWNBLGNBQWQ7QUFDQSxTQUFLQyxPQUFMLEdBQWUsRUFBZixDQUppQyxDQUtqQzs7QUFDQSxTQUFLQyxZQUFMLEdBQW9CLElBQXBCO0FBQ0Q7O0FBRU1DLEVBQUFBLElBQUksQ0FBQ0wsTUFBRCxFQUFpQkcsT0FBdUIsR0FBRyxFQUEzQyxFQUFnRTtBQUN6RSxTQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxZQUFMLEdBQW9CLElBQUlFLHFCQUFKLENBQWlCLEtBQUtOLE1BQXRCLEVBQThCRSxjQUE5QixDQUFwQjtBQUVBLFdBQU8sS0FBS0UsWUFBTCxDQUFrQkcsU0FBbEIsQ0FBNEJQLE1BQTVCLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ3lCLFFBQVZRLFVBQVUsQ0FBQ0MsSUFBRCxFQUFlQyxRQUFmLEVBQThCQyxRQUE5QixFQUFpRTtBQUN0RixRQUFJO0FB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O0FBQ3JELGNBQU0zSCxPQUFPLEdBQUd5RixRQUFRLENBQUNrQyxDQUFELENBQXhCLENBRHFELENBR3JEO0FBQ0E7O0FBQ0EzSCxRQUFBQSxPQUFPLENBQUMySSxNQUFNLENBQUNDLEdBQVAsQ0FBVyxvQkFBWCxDQUFELENBQVAsR0FBNEN2QyxNQUFNLENBQUNLLE1BQW5EO0FBQ0Q7QUFDRjtBQUNGOztBQXhrQnNDOztlQTJrQjFCeEksTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBTdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgYXN5bmMsIHsgQXN5bmNSZXN1bHRBcnJheUNhbGxiYWNrIH0gZnJvbSAnYXN5bmMnO1xuaW1wb3J0IHsgUmVhZFRhcmJhbGwgfSBmcm9tICdAdmVyZGFjY2lvL3N0cmVhbXMnO1xuaW1wb3J0IHsgSVJlYWRUYXJiYWxsLCBJVXBsb2FkVGFyYmFsbCwgVmVyc2lvbnMsIFBhY2thZ2UsIENvbmZpZywgTWVyZ2VUYWdzLCBWZXJzaW9uLCBEaXN0RmlsZSwgQ2FsbGJhY2ssIExvZ2dlciB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgR2VuZXJpY0JvZHksIFRva2VuRmlsdGVyLCBUb2tlbiB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgVmVyZGFjY2lvRXJyb3IgfSBmcm9tICdAdmVyZGFjY2lvL2NvbW1vbnMtYXBpJztcbmltcG9ydCB7IElTdG9yYWdlLCBJUHJveHksIElTdG9yYWdlSGFuZGxlciwgUHJveHlMaXN0LCBTdHJpbmdWYWx1ZSwgSUdldFBhY2thZ2VPcHRpb25zLCBJU3luY1VwbGlua3MsIElQbHVnaW5GaWx0ZXJzIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vbGliL2xvZ2dlcic7XG5pbXBvcnQgUHJveHlTdG9yYWdlIGZyb20gJy4vdXAtc3RvcmFnZSc7XG5pbXBvcnQgU2VhcmNoIGZyb20gJy4vc2VhcmNoJztcbmltcG9ydCB7IEFQSV9FUlJPUiwgSFRUUF9TVEFUVVMsIERJU1RfVEFHUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBMb2NhbFN0b3JhZ2UgZnJvbSAnLi9sb2NhbC1zdG9yYWdlJztcbmltcG9ydCB7IGNoZWNrUGFja2FnZUxvY2FsLCBwdWJsaXNoUGFja2FnZSwgY2hlY2tQYWNrYWdlUmVtb3RlLCBjbGVhblVwTGlua3NSZWYsIG1lcmdlVXBsaW5rVGltZUludG9Mb2NhbCwgZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUgfSBmcm9tICcuL3N0b3JhZ2UtdXRpbHMnO1xuaW1wb3J0IHsgc2V0dXBVcExpbmtzLCB1cGRhdGVWZXJzaW9uc0hpZGRlblVwTGluayB9IGZyb20gJy4vdXBsaW5rLXV0aWwnO1xuaW1wb3J0IHsgbWVyZ2VWZXJzaW9ucyB9IGZyb20gJy4vbWV0YWRhdGEtdXRpbHMnO1xuaW1wb3J0IHsgRXJyb3JDb2RlLCBub3JtYWxpemVEaXN0VGFncywgdmFsaWRhdGVNZXRhZGF0YSwgaXNPYmplY3QgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGhhc1Byb3h5VG8gfSBmcm9tICcuL2NvbmZpZy11dGlscyc7XG5cbmNsYXNzIFN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZUhhbmRsZXIge1xuICBwdWJsaWMgbG9jYWxTdG9yYWdlOiBJU3RvcmFnZTtcbiAgcHVibGljIGNvbmZpZzogQ29uZmlnO1xuICBwdWJsaWMgbG9nZ2VyOiBMb2dnZXI7XG4gIHB1YmxpYyB1cGxpbmtzOiBQcm94eUxpc3Q7XG4gIHB1YmxpYyBmaWx0ZXJzOiBJUGx1Z2luRmlsdGVycztcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29uZmlnOiBDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnVwbGlua3MgPSBzZXR1cFVwTGlua3MoY29uZmlnKTtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIGluaXQoY29uZmlnOiBDb25maWcsIGZpbHRlcnM6IElQbHVnaW5GaWx0ZXJzID0gW10pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKHRoaXMuY29uZmlnLCBsb2dnZXIpO1xuXG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLmdldFNlY3JldChjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqICBBZGQgYSB7bmFtZX0gcGFja2FnZSB0byBhIHN5c3RlbVxuICAgRnVuY3Rpb24gY2hlY2tzIGlmIHBhY2thZ2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGF2YWlsYWJsZSBmcm9tIHVwbGlua3MuXG4gICBJZiBpdCBpc24ndCwgd2UgY3JlYXRlIHBhY2thZ2UgbG9jYWxseVxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKSAmJiB1cGxpbmtzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYWRkUGFja2FnZShuYW1lOiBzdHJpbmcsIG1ldGFkYXRhOiBhbnksIGNhbGxiYWNrOiBGdW5jdGlvbik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjaGVja1BhY2thZ2VMb2NhbChuYW1lLCB0aGlzLmxvY2FsU3RvcmFnZSk7XG4gICAgICBhd2FpdCBjaGVja1BhY2thZ2VSZW1vdGUobmFtZSwgdGhpcy5faXNBbGxvd1B1Ymxpc2hPZmZsaW5lKCksIHRoaXMuX3N5bmNVcGxpbmtzTWV0YWRhdGEuYmluZCh0aGlzKSk7XG4gICAgICBhd2FpdCBwdWJsaXNoUGFja2FnZShuYW1lLCBtZXRhZGF0YSwgdGhpcy5sb2NhbFN0b3JhZ2UgYXMgSVN0b3JhZ2UpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNBbGxvd1B1Ymxpc2hPZmZsaW5lKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5jb25maWcucHVibGlzaCAhPT0gJ3VuZGVmaW5lZCcgJiYgXy5pc0Jvb2xlYW4odGhpcy5jb25maWcucHVibGlzaC5hbGxvd19vZmZsaW5lKSAmJiB0aGlzLmNvbmZpZy5wdWJsaXNoLmFsbG93X29mZmxpbmU7XG4gIH1cblxuICBwdWJsaWMgcmVhZFRva2VucyhmaWx0ZXI6IFRva2VuRmlsdGVyKTogUHJvbWlzZTxUb2tlbltdPiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLnJlYWRUb2tlbnMoZmlsdGVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzYXZlVG9rZW4odG9rZW46IFRva2VuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLnNhdmVUb2tlbih0b2tlbik7XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlVG9rZW4odXNlcjogc3RyaW5nLCB0b2tlbktleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuZGVsZXRlVG9rZW4odXNlciwgdG9rZW5LZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyB2ZXJzaW9uIG9mIHBhY2thZ2Uge25hbWV9IHRvIGEgc3lzdGVtXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgYWRkVmVyc2lvbihuYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZywgbWV0YWRhdGE6IFZlcnNpb24sIHRhZzogU3RyaW5nVmFsdWUsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLmFkZFZlcnNpb24obmFtZSwgdmVyc2lvbiwgbWV0YWRhdGEsIHRhZywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRhZ3MgYSBwYWNrYWdlIHZlcnNpb24gd2l0aCBhIHByb3ZpZGVkIHRhZ1xuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIG1lcmdlVGFncyhuYW1lOiBzdHJpbmcsIHRhZ0hhc2g6IE1lcmdlVGFncywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UubWVyZ2VUYWdzKG5hbWUsIHRhZ0hhc2gsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgYW4gZXhpc3RpbmcgcGFja2FnZSAoaS5lLiB1bnB1Ymxpc2ggb25lIHZlcnNpb24pXG4gICBGdW5jdGlvbiBjaGFuZ2VzIGEgcGFja2FnZSBpbmZvIGZyb20gbG9jYWwgc3RvcmFnZSBhbmQgYWxsIHVwbGlua3Mgd2l0aCB3cml0ZSBhY2Nlc3MuL1xuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIGNoYW5nZVBhY2thZ2UobmFtZTogc3RyaW5nLCBtZXRhZGF0YTogUGFja2FnZSwgcmV2aXNpb246IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UuY2hhbmdlUGFja2FnZShuYW1lLCBtZXRhZGF0YSwgcmV2aXNpb24sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBwYWNrYWdlIGZyb20gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIHJlbW92ZXMgYSBwYWNrYWdlIGZyb20gbG9jYWwgc3RvcmFnZVxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIHJlbW92ZVBhY2thZ2UobmFtZTogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVQYWNrYWdlKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAvLyB1cGRhdGUgdGhlIGluZGV4ZXJcbiAgICBTZWFyY2gucmVtb3ZlKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICBSZW1vdmUgYSB0YXJiYWxsIGZyb20gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIHJlbW92ZXMgYSB0YXJiYWxsIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAgIFRhcmJhbGwgaW4gcXVlc3Rpb24gc2hvdWxkIG5vdCBiZSBsaW5rZWQgdG8gaW4gYW55IGV4aXN0aW5nXG4gICB2ZXJzaW9ucywgaS5lLiBwYWNrYWdlIHZlcnNpb24gc2hvdWxkIGJlIHVucHVibGlzaGVkIGZpcnN0LlxuICAgVXNlZCBzdG9yYWdlOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlVGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcsIHJldmlzaW9uOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZVRhcmJhbGwobmFtZSwgZmlsZW5hbWUsIHJldmlzaW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgdGFyYmFsbCBmb3Ige25hbWV9IHBhY2thZ2VcbiAgIEZ1bmN0aW9uIGlzIHN5bmNocm9ub3VzIGFuZCByZXR1cm5zIGEgV3JpdGFibGVTdHJlYW1cbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICh3cml0ZSlcbiAgICovXG4gIHB1YmxpYyBhZGRUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IElVcGxvYWRUYXJiYWxsIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuYWRkVGFyYmFsbChuYW1lLCBmaWxlbmFtZSk7XG4gIH1cblxuICBwdWJsaWMgaGFzTG9jYWxUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSwgcmVqZWN0KTogdm9pZCA9PiB7XG4gICAgICBsZXQgbG9jYWxTdHJlYW06IGFueSA9IHNlbGYubG9jYWxTdG9yYWdlLmdldFRhcmJhbGwobmFtZSwgZmlsZW5hbWUpO1xuICAgICAgbGV0IGlzT3BlbiA9IGZhbHNlO1xuICAgICAgbG9jYWxTdHJlYW0ub24oJ2Vycm9yJywgKGVycik6IGFueSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4gfHwgZXJyLnN0YXR1cyAhPT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9jYWwgcmVwb3J0ZWQgNDA0IG9yIHJlcXVlc3Qgd2FzIGFib3J0ZWQgYWxyZWFkeVxuICAgICAgICBpZiAobG9jYWxTdHJlYW0pIHtcbiAgICAgICAgICBsb2NhbFN0cmVhbS5hYm9ydCgpO1xuICAgICAgICAgIGxvY2FsU3RyZWFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgbG9jYWxTdHJlYW0ub24oJ29wZW4nLCBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgIGlzT3BlbiA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RyZWFtLmFib3J0KCk7XG4gICAgICAgIGxvY2FsU3RyZWFtID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICBHZXQgYSB0YXJiYWxsIGZyb20gYSBzdG9yYWdlIGZvciB7bmFtZX0gcGFja2FnZVxuICAgRnVuY3Rpb24gaXMgc3luY2hyb25vdXMgYW5kIHJldHVybnMgYSBSZWFkYWJsZVN0cmVhbVxuICAgRnVuY3Rpb24gdHJpZXMgdG8gcmVhZCB0YXJiYWxsIGxvY2FsbHksIGlmIGl0IGZhaWxzIHRoZW4gaXQgcmVhZHMgcGFja2FnZVxuICAgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gZmlndXJlIG91dCB3aGVyZSB3ZSBjYW4gZ2V0IHRoaXMgdGFyYmFsbCBmcm9tXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCB8fCB1cGxpbmsgKGp1c3Qgb25lKVxuICAgKi9cbiAgcHVibGljIGdldFRhcmJhbGwobmFtZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogSVJlYWRUYXJiYWxsIHtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gbmV3IFJlYWRUYXJiYWxsKHt9KTtcbiAgICByZWFkU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIGlmIHNvbWVvbmUgcmVxdWVzdGluZyB0YXJiYWxsLCBpdCBtZWFucyB0aGF0IHdlIHNob3VsZCBhbHJlYWR5IGhhdmUgc29tZVxuICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IGl0LCBzbyBmZXRjaGluZyBwYWNrYWdlIGluZm8gaXMgdW5uZWNlc3NhcnlcblxuICAgIC8vIHRyeWluZyBsb2NhbCBmaXJzdFxuICAgIC8vIGZsb3c6IHNob3VsZCBiZSBJUmVhZFRhcmJhbGxcbiAgICBsZXQgbG9jYWxTdHJlYW06IGFueSA9IHNlbGYubG9jYWxTdG9yYWdlLmdldFRhcmJhbGwobmFtZSwgZmlsZW5hbWUpO1xuICAgIGxldCBpc09wZW4gPSBmYWxzZTtcbiAgICBsb2NhbFN0cmVhbS5vbignZXJyb3InLCAoZXJyKTogYW55ID0+IHtcbiAgICAgIGlmIChpc09wZW4gfHwgZXJyLnN0YXR1cyAhPT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgIHJldHVybiByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gbG9jYWwgcmVwb3J0ZWQgNDA0XG4gICAgICBjb25zdCBlcnI0MDQgPSBlcnI7XG4gICAgICBsb2NhbFN0cmVhbS5hYm9ydCgpO1xuICAgICAgbG9jYWxTdHJlYW0gPSBudWxsOyAvLyB3ZSBmb3JjZSBmb3IgZ2FyYmFnZSBjb2xsZWN0b3JcbiAgICAgIHNlbGYubG9jYWxTdG9yYWdlLmdldFBhY2thZ2VNZXRhZGF0YShuYW1lLCAoZXJyLCBpbmZvOiBQYWNrYWdlKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChfLmlzTmlsKGVycikgJiYgaW5mby5fZGlzdGZpbGVzICYmIF8uaXNOaWwoaW5mby5fZGlzdGZpbGVzW2ZpbGVuYW1lXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBmaWxlIGV4aXN0cyBsb2NhbGx5XG4gICAgICAgICAgc2VydmVGaWxlKGluZm8uX2Rpc3RmaWxlc1tmaWxlbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIGtub3cgbm90aGluZyBhYm91dCB0aGlzIGZpbGUsIHRyeWluZyB0byBnZXQgaW5mb3JtYXRpb24gZWxzZXdoZXJlXG4gICAgICAgICAgc2VsZi5fc3luY1VwbGlua3NNZXRhZGF0YShuYW1lLCBpbmZvLCB7fSwgKGVyciwgaW5mbzogUGFja2FnZSk6IGFueSA9PiB7XG4gICAgICAgICAgICBpZiAoXy5pc05pbChlcnIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5pc05pbChpbmZvLl9kaXN0ZmlsZXMpIHx8IF8uaXNOaWwoaW5mby5fZGlzdGZpbGVzW2ZpbGVuYW1lXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnI0MDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VydmVGaWxlKGluZm8uX2Rpc3RmaWxlc1tmaWxlbmFtZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBsb2NhbFN0cmVhbS5vbignY29udGVudC1sZW5ndGgnLCBmdW5jdGlvbiAodik6IHZvaWQge1xuICAgICAgcmVhZFN0cmVhbS5lbWl0KCdjb250ZW50LWxlbmd0aCcsIHYpO1xuICAgIH0pO1xuICAgIGxvY2FsU3RyZWFtLm9uKCdvcGVuJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgaXNPcGVuID0gdHJ1ZTtcbiAgICAgIGxvY2FsU3RyZWFtLnBpcGUocmVhZFN0cmVhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlYWRTdHJlYW07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbmQgY2FjaGUgbG9jYWwvcmVtb3RlIHBhY2thZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIGRlZmluZSB0aGUgcGFja2FnZSBzaGFwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcnZlRmlsZShmaWxlOiBEaXN0RmlsZSk6IHZvaWQge1xuICAgICAgbGV0IHVwbGluazogYW55ID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCB1cGxpbmtJZCBpbiBzZWxmLnVwbGlua3MpIHtcbiAgICAgICAgaWYgKGhhc1Byb3h5VG8obmFtZSwgdXBsaW5rSWQsIHNlbGYuY29uZmlnLnBhY2thZ2VzKSkge1xuICAgICAgICAgIHVwbGluayA9IHNlbGYudXBsaW5rc1t1cGxpbmtJZF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVwbGluayA9PSBudWxsKSB7XG4gICAgICAgIHVwbGluayA9IG5ldyBQcm94eVN0b3JhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXJsOiBmaWxlLnVybCxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgX2F1dG9nZW5lcmF0ZWQ6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWxmLmNvbmZpZ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2F2ZXN0cmVhbTogSVVwbG9hZFRhcmJhbGwgfCBudWxsID0gbnVsbDtcbiAgICAgIGlmICh1cGxpbmsuY29uZmlnLmNhY2hlKSB7XG4gICAgICAgIHNhdmVzdHJlYW0gPSBzZWxmLmxvY2FsU3RvcmFnZS5hZGRUYXJiYWxsKG5hbWUsIGZpbGVuYW1lKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG9uX29wZW4gPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgIC8vIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICAgICAgb25fb3BlbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBjb25zdCByc3RyZWFtMiA9IHVwbGluay5mZXRjaFRhcmJhbGwoZmlsZS51cmwpO1xuICAgICAgICByc3RyZWFtMi5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICAgIHNhdmVzdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F2ZXN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByc3RyZWFtMi5vbignZW5kJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgICBzYXZlc3RyZWFtLmRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJzdHJlYW0yLm9uKCdjb250ZW50LWxlbmd0aCcsIGZ1bmN0aW9uICh2KTogdm9pZCB7XG4gICAgICAgICAgcmVhZFN0cmVhbS5lbWl0KCdjb250ZW50LWxlbmd0aCcsIHYpO1xuICAgICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgICBzYXZlc3RyZWFtLmVtaXQoJ2NvbnRlbnQtbGVuZ3RoJywgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcnN0cmVhbTIucGlwZShyZWFkU3RyZWFtKTtcbiAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICByc3RyZWFtMi5waXBlKHNhdmVzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2F2ZXN0cmVhbSkge1xuICAgICAgICBzYXZlc3RyZWFtLm9uKCdvcGVuJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAgIG9uX29wZW4oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2F2ZXN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih7IGVycjogZXJyLCBmaWxlTmFtZTogZmlsZSB9LCAnZXJyb3Igc2F2aW5nIGZpbGUgQHtmaWxlTmFtZX06IEB7ZXJyLm1lc3NhZ2V9XFxuQHtlcnIuc3RhY2t9Jyk7XG4gICAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICAgIHNhdmVzdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F2ZXN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgb25fb3BlbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uX29wZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgIFJldHJpZXZlIGEgcGFja2FnZSBtZXRhZGF0YSBmb3Ige25hbWV9IHBhY2thZ2VcbiAgIEZ1bmN0aW9uIGludm9rZXMgbG9jYWxTdG9yYWdlLmdldFBhY2thZ2UgYW5kIHVwbGluay5nZXRfcGFja2FnZSBmb3IgZXZlcnlcbiAgIHVwbGluayB3aXRoIHByb3h5X2FjY2VzcyByaWdodHMgYWdhaW5zdCB7bmFtZX0gYW5kIGNvbWJpbmVzIHJlc3VsdHNcbiAgIGludG8gb25lIGpzb24gb2JqZWN0XG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAmJiB1cGxpbmsgKHByb3h5X2FjY2VzcylcblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gb3B0aW9ucy5uYW1lIFBhY2thZ2UgTmFtZVxuICAgKiBAcHJvcGVydHkge29iamVjdH0gIG9wdGlvbnMucmVxIEV4cHJlc3MgYHJlcWAgb2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy5rZWVwVXBMaW5rRGF0YSBrZWVwIHVwIGxpbmsgaW5mbyBpbiBwYWNrYWdlIG1ldGEsIGxhc3QgdXBkYXRlLCBldGMuXG4gICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9wdGlvbnMuY2FsbGJhY2sgQ2FsbGJhY2sgZm9yIHJlY2VpdmUgZGF0YVxuICAgKi9cbiAgcHVibGljIGdldFBhY2thZ2Uob3B0aW9uczogSUdldFBhY2thZ2VPcHRpb25zKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0UGFja2FnZU1ldGFkYXRhKG9wdGlvbnMubmFtZSwgKGVyciwgZGF0YSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGVyciAmJiAoIWVyci5zdGF0dXMgfHwgZXJyLnN0YXR1cyA+PSBIVFRQX1NUQVRVUy5JTlRFUk5BTF9FUlJPUikpIHtcbiAgICAgICAgLy8gcmVwb3J0IGludGVybmFsIGVycm9ycyByaWdodCBhd2F5XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N5bmNVcGxpbmtzTWV0YWRhdGEoXG4gICAgICAgIG9wdGlvbnMubmFtZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgeyByZXE6IG9wdGlvbnMucmVxLCB1cGxpbmtzTG9vazogb3B0aW9ucy51cGxpbmtzTG9vayB9LFxuICAgICAgICBmdW5jdGlvbiBnZXRQYWNrYWdlU3luVXBMaW5rc0NhbGxiYWNrKGVyciwgcmVzdWx0OiBQYWNrYWdlLCB1cGxpbmtFcnJvcnMpOiB2b2lkIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vcm1hbGl6ZURpc3RUYWdzKGNsZWFuVXBMaW5rc1JlZihvcHRpb25zLmtlZXBVcExpbmtEYXRhLCByZXN1bHQpKTtcblxuICAgICAgICAgIC8vIG5wbSBjYW4gdGhyb3cgaWYgdGhpcyBmaWVsZCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgcmVzdWx0Ll9hdHRhY2htZW50cyA9IHt9O1xuXG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCByZXN1bHQsIHVwbGlua0Vycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgIFJldHJpZXZlIHJlbW90ZSBhbmQgbG9jYWwgcGFja2FnZXMgbW9yZSByZWNlbnQgdGhhbiB7c3RhcnRrZXl9XG4gICBGdW5jdGlvbiBzdHJlYW1zIGFsbCBwYWNrYWdlcyBmcm9tIGFsbCB1cGxpbmtzIGZpcnN0LCBhbmQgdGhlblxuICAgbG9jYWwgcGFja2FnZXMuXG4gICBOb3RlIHRoYXQgbG9jYWwgcGFja2FnZXMgY291bGQgb3ZlcnJpZGUgcmVnaXN0cnkgb25lcyBqdXN0IGJlY2F1c2VcbiAgIHRoZXkgYXBwZWFyIGluIEpTT04gbGFzdC4gVGhhdCdzIGEgdHJhZGUtb2ZmIHdlIG1ha2UgdG8gYXZvaWRcbiAgIG1lbW9yeSBpc3N1ZXMuXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAmJiB1cGxpbmsgKHByb3h5X2FjY2VzcylcbiAgICogQHBhcmFtIHsqfSBzdGFydGtleVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgcHVibGljIHNlYXJjaChzdGFydGtleTogc3RyaW5nLCBvcHRpb25zOiBhbnkpOiBJUmVhZFRhcmJhbGwge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHNlYXJjaFN0cmVhbTogYW55ID0gbmV3IFN0cmVhbS5QYXNzVGhyb3VnaCh7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgYXN5bmMuZWFjaFNlcmllcyhcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMudXBsaW5rcyksXG4gICAgICBmdW5jdGlvbiAodXBfbmFtZSwgY2IpOiB2b2lkIHtcbiAgICAgICAgLy8gc2hvcnRjdXQ6IGlmIGBsb2NhbD0xYCBpcyBzdXBwbGllZCwgZG9uJ3QgY2FsbCB1cGxpbmtzXG4gICAgICAgIGlmIChvcHRpb25zLnJlcT8ucXVlcnk/LmxvY2FsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuaW5mbyhgc2VhcmNoIGZvciB1cGxpbmsgJHt1cF9uYW1lfWApO1xuICAgICAgICAvLyBzZWFyY2ggYnkga2V5d29yZCBmb3IgZWFjaCB1cGxpbmtcbiAgICAgICAgY29uc3QgdXBsaW5rU3RyZWFtOiBJVXBsb2FkVGFyYmFsbCA9IHNlbGYudXBsaW5rc1t1cF9uYW1lXS5zZWFyY2gob3B0aW9ucyk7XG4gICAgICAgIC8vIGpvaW4gdXBsaW5rIHN0cmVhbSB3aXRoIHN0cmVhbXMgUGFzc1Rocm91Z2hcbiAgICAgICAgdXBsaW5rU3RyZWFtLnBpcGUoc2VhcmNoU3RyZWFtLCB7IGVuZDogZmFsc2UgfSk7XG4gICAgICAgIHVwbGlua1N0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoeyBlcnI6IGVyciB9LCAndXBsaW5rIGVycm9yOiBAe2Vyci5tZXNzYWdlfScpO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgY2FsbCBjYWxsYmFjayBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIGNiID0gZnVuY3Rpb24gKCk6IHZvaWQge307XG4gICAgICAgIH0pO1xuICAgICAgICB1cGxpbmtTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGNhbGwgY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICBjYiA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuICAgICAgICB9KTtcblxuICAgICAgICBzZWFyY2hTdHJlYW0uYWJvcnQgPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgICAgaWYgKHVwbGlua1N0cmVhbS5hYm9ydCkge1xuICAgICAgICAgICAgdXBsaW5rU3RyZWFtLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgY2FsbCBjYWxsYmFjayBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIGNiID0gZnVuY3Rpb24gKCk6IHZvaWQge307XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gZXhlY3V0ZWQgYWZ0ZXIgYWxsIHNlcmllc1xuICAgICAgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAvLyBhdHRhY2ggYSBsb2NhbCBzZWFyY2ggcmVzdWx0c1xuICAgICAgICBjb25zdCBsb2NhbFNlYXJjaFN0cmVhbTogSVJlYWRUYXJiYWxsID0gc2VsZi5sb2NhbFN0b3JhZ2Uuc2VhcmNoKHN0YXJ0a2V5LCBvcHRpb25zKTtcbiAgICAgICAgc2VhcmNoU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAgIGxvY2FsU2VhcmNoU3RyZWFtLmFib3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGxvY2FsU2VhcmNoU3RyZWFtLnBpcGUoc2VhcmNoU3RyZWFtLCB7IGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgbG9jYWxTZWFyY2hTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycjogVmVyZGFjY2lvRXJyb3IpOiB2b2lkIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcih7IGVycjogZXJyIH0sICdzZWFyY2ggZXJyb3I6IEB7ZXJyLm1lc3NhZ2V9Jyk7XG4gICAgICAgICAgc2VhcmNoU3RyZWFtLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHNlYXJjaFN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBvbmx5IHByaXZhdGUgbG9jYWwgcGFja2FnZXNcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGdldExvY2FsRGF0YWJhc2UoY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2Uuc3RvcmFnZVBsdWdpbi5nZXQoKGVyciwgbG9jYWxzKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhY2thZ2VzOiBWZXJzaW9uW10gPSBbXTtcbiAgICAgIGNvbnN0IGdldFBhY2thZ2UgPSBmdW5jdGlvbiAoaXRlbVBrZyk6IHZvaWQge1xuICAgICAgICBzZWxmLmxvY2FsU3RvcmFnZS5nZXRQYWNrYWdlTWV0YWRhdGEobG9jYWxzW2l0ZW1Qa2ddLCBmdW5jdGlvbiAoZXJyLCBwa2dNZXRhZGF0YTogUGFja2FnZSk6IHZvaWQge1xuICAgICAgICAgIGlmIChfLmlzTmlsKGVycikpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdCA9IHBrZ01ldGFkYXRhW0RJU1RfVEFHU10ubGF0ZXN0O1xuICAgICAgICAgICAgaWYgKGxhdGVzdCAmJiBwa2dNZXRhZGF0YS52ZXJzaW9uc1tsYXRlc3RdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZlcnNpb246IFZlcnNpb24gPSBwa2dNZXRhZGF0YS52ZXJzaW9uc1tsYXRlc3RdO1xuICAgICAgICAgICAgICBjb25zdCB0aW1lTGlzdCA9IHBrZ01ldGFkYXRhLnRpbWUgYXMgR2VuZXJpY0JvZHk7XG4gICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSB0aW1lTGlzdFtsYXRlc3RdO1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIHZlcnNpb24udGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgICAgLy8gQWRkIGZvciBzdGFycyBhcGlcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICB2ZXJzaW9uLnVzZXJzID0gcGtnTWV0YWRhdGEudXNlcnM7XG5cbiAgICAgICAgICAgICAgcGFja2FnZXMucHVzaCh2ZXJzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4oeyBwYWNrYWdlOiBsb2NhbHNbaXRlbVBrZ10gfSwgJ3BhY2thZ2UgQHtwYWNrYWdlfSBkb2VzIG5vdCBoYXZlIGEgXCJsYXRlc3RcIiB0YWc/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGl0ZW1Qa2cgPj0gbG9jYWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBhY2thZ2VzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFja2FnZShpdGVtUGtnICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChsb2NhbHMubGVuZ3RoKSB7XG4gICAgICAgIGdldFBhY2thZ2UoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gZmV0Y2hlcyBwYWNrYWdlIG1ldGFkYXRhIGZyb20gdXBsaW5rcyBhbmQgc3luY2hyb25pemVzIGl0IHdpdGggbG9jYWwgZGF0YVxuICAgaWYgcGFja2FnZSBpcyBhdmFpbGFibGUgbG9jYWxseSwgaXQgTVVTVCBiZSBwcm92aWRlZCBpbiBwa2dpbmZvXG4gICByZXR1cm5zIGNhbGxiYWNrKGVyciwgcmVzdWx0LCB1cGxpbmtfZXJyb3JzKVxuICAgKi9cbiAgcHVibGljIF9zeW5jVXBsaW5rc01ldGFkYXRhKG5hbWU6IHN0cmluZywgcGFja2FnZUluZm86IFBhY2thZ2UsIG9wdGlvbnM6IElTeW5jVXBsaW5rcywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgbGV0IGZvdW5kID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB1cExpbmtzOiBJUHJveHlbXSA9IFtdO1xuICAgIGNvbnN0IGhhc1RvTG9va0ludG9VcGxpbmtzID0gXy5pc05pbChvcHRpb25zLnVwbGlua3NMb29rKSB8fCBvcHRpb25zLnVwbGlua3NMb29rO1xuXG4gICAgaWYgKCFwYWNrYWdlSW5mbykge1xuICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgIHBhY2thZ2VJbmZvID0gZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUobmFtZSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1cGxpbmsgaW4gdGhpcy51cGxpbmtzKSB7XG4gICAgICBpZiAoaGFzUHJveHlUbyhuYW1lLCB1cGxpbmssIHRoaXMuY29uZmlnLnBhY2thZ2VzKSAmJiBoYXNUb0xvb2tJbnRvVXBsaW5rcykge1xuICAgICAgICB1cExpbmtzLnB1c2godGhpcy51cGxpbmtzW3VwbGlua10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLm1hcChcbiAgICAgIHVwTGlua3MsXG4gICAgICAodXBMaW5rLCBjYik6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB1cExpbmtNZXRhID0gcGFja2FnZUluZm8uX3VwbGlua3NbdXBMaW5rLnVwbmFtZV07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHVwTGlua01ldGEpKSB7XG4gICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IHVwTGlua01ldGEuZmV0Y2hlZDtcblxuICAgICAgICAgIGlmIChmZXRjaGVkICYmIERhdGUubm93KCkgLSBmZXRjaGVkIDwgdXBMaW5rLm1heGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX29wdGlvbnMuZXRhZyA9IHVwTGlua01ldGEuZXRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIHVwTGluay5nZXRSZW1vdGVNZXRhZGF0YShuYW1lLCBfb3B0aW9ucywgKGVyciwgdXBMaW5rUmVzcG9uc2UsIGVUYWcpOiB2b2lkID0+IHtcbiAgICAgICAgICBpZiAoZXJyICYmIGVyci5yZW1vdGVTdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgdXBMaW5rTWV0YS5mZXRjaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXJyIHx8ICF1cExpbmtSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIFtlcnIgfHwgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoJ25vIGRhdGEnKV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU1ldGFkYXRhKHVwTGlua1Jlc3BvbnNlLCBuYW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3ViOiAnb3V0JyxcbiAgICAgICAgICAgICAgICBlcnI6IGVycixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ3BhY2thZ2UuanNvbiB2YWxpZGF0aW5nIGVycm9yIEB7IWVyci5tZXNzYWdlfVxcbkB7ZXJyLnN0YWNrfSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW2Vycl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhY2thZ2VJbmZvLl91cGxpbmtzW3VwTGluay51cG5hbWVdID0ge1xuICAgICAgICAgICAgZXRhZzogZVRhZyxcbiAgICAgICAgICAgIGZldGNoZWQ6IERhdGUubm93KCksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHBhY2thZ2VJbmZvLnRpbWUgPSBtZXJnZVVwbGlua1RpbWVJbnRvTG9jYWwocGFja2FnZUluZm8sIHVwTGlua1Jlc3BvbnNlKTtcblxuICAgICAgICAgIHVwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rKHVwTGlua1Jlc3BvbnNlLnZlcnNpb25zLCB1cExpbmspO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lcmdlVmVyc2lvbnMocGFja2FnZUluZm8sIHVwTGlua1Jlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3ViOiAnb3V0JyxcbiAgICAgICAgICAgICAgICBlcnI6IGVycixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ3BhY2thZ2UuanNvbiBwYXJzaW5nIGVycm9yIEB7IWVyci5tZXNzYWdlfVxcbkB7ZXJyLnN0YWNrfSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW2Vycl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHdlIGdvdCB0byB0aGlzIHBvaW50LCBhc3N1bWUgdGhhdCB0aGUgY29ycmVjdCBwYWNrYWdlIGV4aXN0c1xuICAgICAgICAgIC8vIG9uIHRoZSB1cGxpbmtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgKGVycjogRXJyb3IsIHVwTGlua3NFcnJvcnM6IGFueSk6IEFzeW5jUmVzdWx0QXJyYXlDYWxsYmFjazx1bmtub3duLCBFcnJvcj4gPT4ge1xuICAgICAgICBhc3NlcnQoIWVyciAmJiBBcnJheS5pc0FycmF5KHVwTGlua3NFcnJvcnMpKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgY29ubmVjdGlvbiB0aW1lb3V0IG9yIHJlc2V0IGVycm9ycyB3aXRoIHVwbGluayhzKVxuICAgICAgICAvLyAodGhlc2Ugc2hvdWxkIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZnJvbSB0aGUgcGFja2FnZSBub3QgYmVpbmcgZm91bmQpXG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICBsZXQgdXBsaW5rVGltZW91dEVycm9yO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBMaW5rc0Vycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHVwTGlua3NFcnJvcnNbaV0pIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1cExpbmtzRXJyb3JzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwTGlua3NFcnJvcnNbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB1cExpbmtzRXJyb3JzW2ldW2pdLmNvZGU7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gJ0VUSU1FRE9VVCcgfHwgY29kZSA9PT0gJ0VTT0NLRVRUSU1FRE9VVCcgfHwgY29kZSA9PT0gJ0VDT05OUkVTRVQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbGlua1RpbWVvdXRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cGxpbmtUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0U2VydmljZVVuYXZhaWxhYmxlKCksIG51bGwsIHVwTGlua3NFcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKEFQSV9FUlJPUi5OT19QQUNLQUdFKSwgbnVsbCwgdXBMaW5rc0Vycm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBMaW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcGFja2FnZUluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5sb2NhbFN0b3JhZ2UudXBkYXRlVmVyc2lvbnMobmFtZSwgcGFja2FnZUluZm8sIGFzeW5jIChlcnIsIHBhY2thZ2VKc29uTG9jYWw6IFBhY2thZ2UpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBbnkgZXJyb3IgaGVyZSB3aWxsIGNhdXNlIGEgNDA0LCBsaWtlIGFuIHVwbGluayBlcnJvci4gVGhpcyBpcyBsaWtlbHkgdGhlIHJpZ2h0IHRoaW5nIHRvIGRvXG4gICAgICAgICAgLy8gYXMgYSBicm9rZW4gZmlsdGVyIGlzIGEgc2VjdXJpdHkgcmlzay5cbiAgICAgICAgICBjb25zdCBmaWx0ZXJFcnJvcnM6IEVycm9yW10gPSBbXTtcbiAgICAgICAgICAvLyBUaGlzIE1VU1QgYmUgZG9uZSBzZXJpYWxseSBhbmQgbm90IGluIHBhcmFsbGVsIGFzIHRoZXkgbW9kaWZ5IHBhY2thZ2VKc29uTG9jYWxcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBzZWxmLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFRoZXNlIGZpbHRlcnMgY2FuIGFzc3VtZSBpdCdzIHNhdmUgdG8gbW9kaWZ5IHBhY2thZ2VKc29uTG9jYWwgYW5kIHJldHVybiBpdCBkaXJlY3RseSBmb3JcbiAgICAgICAgICAgICAgLy8gcGVyZm9ybWFuY2UgKGkuZS4gbmVlZCBub3QgYmUgcHVyZSlcbiAgICAgICAgICAgICAgcGFja2FnZUpzb25Mb2NhbCA9IGF3YWl0IGZpbHRlci5maWx0ZXJfbWV0YWRhdGEocGFja2FnZUpzb25Mb2NhbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgZmlsdGVyRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgcGFja2FnZUpzb25Mb2NhbCwgXy5jb25jYXQodXBMaW5rc0Vycm9ycywgZmlsdGVyRXJyb3JzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgaGlkZGVuIHZhbHVlIGZvciBlYWNoIHZlcnNpb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZlcnNpb25zIGxpc3Qgb2YgdmVyc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXBMaW5rIHVwbGluayBuYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwdWJsaWMgX3VwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rKHZlcnNpb25zOiBWZXJzaW9ucywgdXBMaW5rOiBJUHJveHkpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdmVyc2lvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbnMsIGkpKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1tpXTtcblxuICAgICAgICAvLyBob2xkcyBhIFwiaGlkZGVuXCIgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgcGFja2FnZSBzdG9yYWdlLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHZlcnNpb25bU3ltYm9sLmZvcignX192ZXJkYWNjaW9fdXBsaW5rJyldID0gdXBMaW5rLnVwbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZTtcbiJdfQ==