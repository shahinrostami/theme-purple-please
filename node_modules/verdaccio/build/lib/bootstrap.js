"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startVerdaccio = startVerdaccio;
exports.listenDefaultCallback = listenDefaultCallback;

var _url = _interopRequireDefault(require("url"));

var _fs = _interopRequireDefault(require("fs"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _constants = _interopRequireDefault(require("constants"));

var _lodash = require("lodash");

var _index = _interopRequireDefault(require("../api/index"));

var _constants2 = require("./constants");

var _utils = require("./cli/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const logger = require('./logger');

function displayExperimentsInfoBox(experiments) {
  const experimentList = Object.keys(experiments);

  if (experimentList.length >= 1) {
    logger.logger.warn('⚠️  experiments are enabled, we recommend do not use experiments in production, comment out this section to disable it');
    experimentList.forEach(experiment => {
      logger.logger.warn(` - support for ${experiment} ${experiments[experiment] ? 'is enabled' : ' is disabled'}`);
    });
  }
}
/**
 * Trigger the server after configuration has been loaded.
 * @param {Object} config
 * @param {Object} cliArguments
 * @param {String} configPath
 * @param {String} pkgVersion
 * @param {String} pkgName
 */


function startVerdaccio(config, cliListen, configPath, pkgVersion, pkgName, callback) {
  if ((0, _lodash.isObject)(config) === false) {
    throw new Error(_constants2.API_ERROR.CONFIG_BAD_FORMAT);
  }

  if ('experiments' in config) {
    displayExperimentsInfoBox(config.experiments);
  }

  (0, _index.default)(config).then(app => {
    const addresses = (0, _utils.getListListenAddresses)(cliListen, config.listen);
    addresses.forEach(function (addr) {
      let webServer;

      if (addr.proto === 'https') {
        webServer = handleHTTPS(app, configPath, config);
      } else {
        // http
        webServer = _http.default.createServer(app);
      }

      if (config.server && typeof config.server.keepAliveTimeout !== 'undefined' && config.server.keepAliveTimeout !== 'null') {
        // library definition for node is not up to date (doesn't contain recent 8.0 changes)
        webServer.keepAliveTimeout = config.server.keepAliveTimeout * 1000;
      }

      unlinkAddressPath(addr);
      callback(webServer, addr, pkgName, pkgVersion);
    });
  });
}

function unlinkAddressPath(addr) {
  if (addr.path && _fs.default.existsSync(addr.path)) {
    _fs.default.unlinkSync(addr.path);
  }
}

function logHTTPSWarning(storageLocation) {
  logger.logger.fatal(['You have enabled HTTPS and need to specify either ', '    "https.key" and "https.cert" or ', '    "https.pfx" and optionally "https.passphrase" ', 'to run https server', '', // commands are borrowed from node.js docs
  'To quickly create self-signed certificate, use:', ' $ openssl genrsa -out ' + (0, _utils.resolveConfigPath)(storageLocation, _constants2.keyPem) + ' 2048', ' $ openssl req -new -sha256 -key ' + (0, _utils.resolveConfigPath)(storageLocation, _constants2.keyPem) + ' -out ' + (0, _utils.resolveConfigPath)(storageLocation, _constants2.csrPem), ' $ openssl x509 -req -in ' + (0, _utils.resolveConfigPath)(storageLocation, _constants2.csrPem) + ' -signkey ' + (0, _utils.resolveConfigPath)(storageLocation, _constants2.keyPem) + ' -out ' + (0, _utils.resolveConfigPath)(storageLocation, _constants2.certPem), '', 'And then add to config file (' + storageLocation + '):', '  https:', `    key: ${(0, _utils.resolveConfigPath)(storageLocation, _constants2.keyPem)}`, `    cert: ${(0, _utils.resolveConfigPath)(storageLocation, _constants2.certPem)}`].join('\n'));
  process.exit(2);
}

function handleHTTPS(app, configPath, config) {
  try {
    let httpsOptions = {
      secureOptions: _constants.default.SSL_OP_NO_SSLv2 | _constants.default.SSL_OP_NO_SSLv3 // disable insecure SSLv2 and SSLv3

    };
    const keyCertConfig = config.https;
    const pfxConfig = config.https; // https must either have key and cert or a pfx and (optionally) a passphrase

    if (!(keyCertConfig.key && keyCertConfig.cert || pfxConfig.pfx)) {
      logHTTPSWarning(configPath);
    }

    if (pfxConfig.pfx) {
      const {
        pfx,
        passphrase
      } = pfxConfig;
      httpsOptions = (0, _lodash.assign)(httpsOptions, {
        pfx: _fs.default.readFileSync(pfx),
        passphrase: passphrase || ''
      });
    } else {
      const {
        key,
        cert,
        ca
      } = keyCertConfig;
      httpsOptions = (0, _lodash.assign)(httpsOptions, _objectSpread({
        key: _fs.default.readFileSync(key),
        cert: _fs.default.readFileSync(cert)
      }, ca && {
        ca: _fs.default.readFileSync(ca)
      }));
    }

    return _https.default.createServer(httpsOptions, app);
  } catch (err) {
    // catch errors related to certificate loading
    logger.logger.fatal({
      err: err
    }, 'cannot create server: @{err.message}');
    process.exit(2);
  }
}

function listenDefaultCallback(webServer, addr, pkgName, pkgVersion) {
  const server = webServer.listen(addr.port || addr.path, addr.host, () => {
    // send a message for tests
    if ((0, _lodash.isFunction)(process.send)) {
      process.send({
        verdaccio_started: true
      });
    }
  }).on('error', function (err) {
    logger.logger.fatal({
      err: err
    }, 'cannot create server: @{err.message}');
    process.exit(2);
  });

  function handleShutdownGracefully() {
    logger.logger.fatal('received shutdown signal - closing server gracefully...');
    server.close(() => {
      logger.logger.info('server closed.');
      process.exit(0);
    });
  } // handle shutdown signals nicely when environment says so


  if (process.env.VERDACCIO_HANDLE_KILL_SIGNALS === 'true') {
    process.on('SIGINT', handleShutdownGracefully);
    process.on('SIGTERM', handleShutdownGracefully);
    process.on('SIGHUP', handleShutdownGracefully);
  }

  logger.logger.warn({
    addr: addr.path ? _url.default.format({
      protocol: 'unix',
      pathname: addr.path
    }) : _url.default.format({
      protocol: addr.proto,
      hostname: addr.host,
      port: addr.port,
      pathname: '/'
    }),
    version: pkgName + '/' + pkgVersion
  }, 'http address - @{addr} - @{version}');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYm9vdHN0cmFwLnRzIl0sIm5hbWVzIjpbImxvZ2dlciIsInJlcXVpcmUiLCJkaXNwbGF5RXhwZXJpbWVudHNJbmZvQm94IiwiZXhwZXJpbWVudHMiLCJleHBlcmltZW50TGlzdCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ3YXJuIiwiZm9yRWFjaCIsImV4cGVyaW1lbnQiLCJzdGFydFZlcmRhY2NpbyIsImNvbmZpZyIsImNsaUxpc3RlbiIsImNvbmZpZ1BhdGgiLCJwa2dWZXJzaW9uIiwicGtnTmFtZSIsImNhbGxiYWNrIiwiRXJyb3IiLCJBUElfRVJST1IiLCJDT05GSUdfQkFEX0ZPUk1BVCIsInRoZW4iLCJhcHAiLCJhZGRyZXNzZXMiLCJsaXN0ZW4iLCJhZGRyIiwid2ViU2VydmVyIiwicHJvdG8iLCJoYW5kbGVIVFRQUyIsImh0dHAiLCJjcmVhdGVTZXJ2ZXIiLCJzZXJ2ZXIiLCJrZWVwQWxpdmVUaW1lb3V0IiwidW5saW5rQWRkcmVzc1BhdGgiLCJwYXRoIiwiZnMiLCJleGlzdHNTeW5jIiwidW5saW5rU3luYyIsImxvZ0hUVFBTV2FybmluZyIsInN0b3JhZ2VMb2NhdGlvbiIsImZhdGFsIiwia2V5UGVtIiwiY3NyUGVtIiwiY2VydFBlbSIsImpvaW4iLCJwcm9jZXNzIiwiZXhpdCIsImh0dHBzT3B0aW9ucyIsInNlY3VyZU9wdGlvbnMiLCJjb25zdGFudHMiLCJTU0xfT1BfTk9fU1NMdjIiLCJTU0xfT1BfTk9fU1NMdjMiLCJrZXlDZXJ0Q29uZmlnIiwiaHR0cHMiLCJwZnhDb25maWciLCJrZXkiLCJjZXJ0IiwicGZ4IiwicGFzc3BocmFzZSIsInJlYWRGaWxlU3luYyIsImNhIiwiZXJyIiwibGlzdGVuRGVmYXVsdENhbGxiYWNrIiwicG9ydCIsImhvc3QiLCJzZW5kIiwidmVyZGFjY2lvX3N0YXJ0ZWQiLCJvbiIsImhhbmRsZVNodXRkb3duR3JhY2VmdWxseSIsImNsb3NlIiwiaW5mbyIsImVudiIsIlZFUkRBQ0NJT19IQU5ETEVfS0lMTF9TSUdOQUxTIiwiVVJMIiwiZm9ybWF0IiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhvc3RuYW1lIiwidmVyc2lvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFJQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztBQUVBLE1BQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDLFVBQUQsQ0FBdEI7O0FBRUEsU0FBU0MseUJBQVQsQ0FBbUNDLFdBQW5DLEVBQWdEO0FBQzlDLFFBQU1DLGNBQWMsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlILFdBQVosQ0FBdkI7O0FBQ0EsTUFBSUMsY0FBYyxDQUFDRyxNQUFmLElBQXlCLENBQTdCLEVBQWdDO0FBQzlCUCxJQUFBQSxNQUFNLENBQUNBLE1BQVAsQ0FBY1EsSUFBZCxDQUFtQix3SEFBbkI7QUFDQUosSUFBQUEsY0FBYyxDQUFDSyxPQUFmLENBQXdCQyxVQUFELElBQWdCO0FBQ3JDVixNQUFBQSxNQUFNLENBQUNBLE1BQVAsQ0FBY1EsSUFBZCxDQUFvQixrQkFBaUJFLFVBQVcsSUFBR1AsV0FBVyxDQUFDTyxVQUFELENBQVgsR0FBMEIsWUFBMUIsR0FBeUMsY0FBZSxFQUEzRztBQUNELEtBRkQ7QUFHRDtBQUNGO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsY0FBVCxDQUF3QkMsTUFBeEIsRUFBcUNDLFNBQXJDLEVBQXdEQyxVQUF4RCxFQUE0RUMsVUFBNUUsRUFBZ0dDLE9BQWhHLEVBQWlIQyxRQUFqSCxFQUEySTtBQUN6SSxNQUFJLHNCQUFTTCxNQUFULE1BQXFCLEtBQXpCLEVBQWdDO0FBQzlCLFVBQU0sSUFBSU0sS0FBSixDQUFVQyxzQkFBVUMsaUJBQXBCLENBQU47QUFDRDs7QUFFRCxNQUFJLGlCQUFpQlIsTUFBckIsRUFBNkI7QUFDM0JWLElBQUFBLHlCQUF5QixDQUFDVSxNQUFNLENBQUNULFdBQVIsQ0FBekI7QUFDRDs7QUFFRCxzQkFBWVMsTUFBWixFQUFvQlMsSUFBcEIsQ0FBMEJDLEdBQUQsSUFBZTtBQUN0QyxVQUFNQyxTQUFTLEdBQUcsbUNBQXVCVixTQUF2QixFQUFrQ0QsTUFBTSxDQUFDWSxNQUF6QyxDQUFsQjtBQUVBRCxJQUFBQSxTQUFTLENBQUNkLE9BQVYsQ0FBa0IsVUFBVWdCLElBQVYsRUFBc0I7QUFDdEMsVUFBSUMsU0FBSjs7QUFDQSxVQUFJRCxJQUFJLENBQUNFLEtBQUwsS0FBZSxPQUFuQixFQUE0QjtBQUMxQkQsUUFBQUEsU0FBUyxHQUFHRSxXQUFXLENBQUNOLEdBQUQsRUFBTVIsVUFBTixFQUFrQkYsTUFBbEIsQ0FBdkI7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBYyxRQUFBQSxTQUFTLEdBQUdHLGNBQUtDLFlBQUwsQ0FBa0JSLEdBQWxCLENBQVo7QUFDRDs7QUFDRCxVQUFJVixNQUFNLENBQUNtQixNQUFQLElBQWlCLE9BQU9uQixNQUFNLENBQUNtQixNQUFQLENBQWNDLGdCQUFyQixLQUEwQyxXQUEzRCxJQUEwRXBCLE1BQU0sQ0FBQ21CLE1BQVAsQ0FBY0MsZ0JBQWQsS0FBbUMsTUFBakgsRUFBeUg7QUFDdkg7QUFDQU4sUUFBQUEsU0FBUyxDQUFDTSxnQkFBVixHQUE2QnBCLE1BQU0sQ0FBQ21CLE1BQVAsQ0FBY0MsZ0JBQWQsR0FBaUMsSUFBOUQ7QUFDRDs7QUFDREMsTUFBQUEsaUJBQWlCLENBQUNSLElBQUQsQ0FBakI7QUFFQVIsTUFBQUEsUUFBUSxDQUFDUyxTQUFELEVBQVlELElBQVosRUFBa0JULE9BQWxCLEVBQTJCRCxVQUEzQixDQUFSO0FBQ0QsS0FmRDtBQWdCRCxHQW5CRDtBQW9CRDs7QUFFRCxTQUFTa0IsaUJBQVQsQ0FBMkJSLElBQTNCLEVBQWlDO0FBQy9CLE1BQUlBLElBQUksQ0FBQ1MsSUFBTCxJQUFhQyxZQUFHQyxVQUFILENBQWNYLElBQUksQ0FBQ1MsSUFBbkIsQ0FBakIsRUFBMkM7QUFDekNDLGdCQUFHRSxVQUFILENBQWNaLElBQUksQ0FBQ1MsSUFBbkI7QUFDRDtBQUNGOztBQUVELFNBQVNJLGVBQVQsQ0FBeUJDLGVBQXpCLEVBQTBDO0FBQ3hDdkMsRUFBQUEsTUFBTSxDQUFDQSxNQUFQLENBQWN3QyxLQUFkLENBQ0UsQ0FDRSxvREFERixFQUVFLHNDQUZGLEVBR0Usb0RBSEYsRUFJRSxxQkFKRixFQUtFLEVBTEYsRUFNRTtBQUNBLG1EQVBGLEVBUUUsNEJBQTRCLDhCQUFrQkQsZUFBbEIsRUFBbUNFLGtCQUFuQyxDQUE1QixHQUF5RSxPQVIzRSxFQVNFLHNDQUFzQyw4QkFBa0JGLGVBQWxCLEVBQW1DRSxrQkFBbkMsQ0FBdEMsR0FBbUYsUUFBbkYsR0FBOEYsOEJBQWtCRixlQUFsQixFQUFtQ0csa0JBQW5DLENBVGhHLEVBVUUsOEJBQ0UsOEJBQWtCSCxlQUFsQixFQUFtQ0csa0JBQW5DLENBREYsR0FFRSxZQUZGLEdBR0UsOEJBQWtCSCxlQUFsQixFQUFtQ0Usa0JBQW5DLENBSEYsR0FJRSxRQUpGLEdBS0UsOEJBQWtCRixlQUFsQixFQUFtQ0ksbUJBQW5DLENBZkosRUFnQkUsRUFoQkYsRUFpQkUsa0NBQWtDSixlQUFsQyxHQUFvRCxJQWpCdEQsRUFrQkUsVUFsQkYsRUFtQkcsWUFBVyw4QkFBa0JBLGVBQWxCLEVBQW1DRSxrQkFBbkMsQ0FBMkMsRUFuQnpELEVBb0JHLGFBQVksOEJBQWtCRixlQUFsQixFQUFtQ0ksbUJBQW5DLENBQTRDLEVBcEIzRCxFQXFCRUMsSUFyQkYsQ0FxQk8sSUFyQlAsQ0FERjtBQXdCQUMsRUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsQ0FBYjtBQUNEOztBQUVELFNBQVNsQixXQUFULENBQXFCTixHQUFyQixFQUErQ1IsVUFBL0MsRUFBbUVGLE1BQW5FLEVBQTBHO0FBQ3hHLE1BQUk7QUFDRixRQUFJbUMsWUFBWSxHQUFHO0FBQ2pCQyxNQUFBQSxhQUFhLEVBQUVDLG1CQUFVQyxlQUFWLEdBQTRCRCxtQkFBVUUsZUFEcEMsQ0FDcUQ7O0FBRHJELEtBQW5CO0FBSUEsVUFBTUMsYUFBYSxHQUFHeEMsTUFBTSxDQUFDeUMsS0FBN0I7QUFDQSxVQUFNQyxTQUFTLEdBQUcxQyxNQUFNLENBQUN5QyxLQUF6QixDQU5FLENBUUY7O0FBQ0EsUUFBSSxFQUFHRCxhQUFhLENBQUNHLEdBQWQsSUFBcUJILGFBQWEsQ0FBQ0ksSUFBcEMsSUFBNkNGLFNBQVMsQ0FBQ0csR0FBekQsQ0FBSixFQUFtRTtBQUNqRW5CLE1BQUFBLGVBQWUsQ0FBQ3hCLFVBQUQsQ0FBZjtBQUNEOztBQUVELFFBQUl3QyxTQUFTLENBQUNHLEdBQWQsRUFBbUI7QUFDakIsWUFBTTtBQUFFQSxRQUFBQSxHQUFGO0FBQU9DLFFBQUFBO0FBQVAsVUFBc0JKLFNBQTVCO0FBQ0FQLE1BQUFBLFlBQVksR0FBRyxvQkFBT0EsWUFBUCxFQUFxQjtBQUNsQ1UsUUFBQUEsR0FBRyxFQUFFdEIsWUFBR3dCLFlBQUgsQ0FBZ0JGLEdBQWhCLENBRDZCO0FBRWxDQyxRQUFBQSxVQUFVLEVBQUVBLFVBQVUsSUFBSTtBQUZRLE9BQXJCLENBQWY7QUFJRCxLQU5ELE1BTU87QUFDTCxZQUFNO0FBQUVILFFBQUFBLEdBQUY7QUFBT0MsUUFBQUEsSUFBUDtBQUFhSSxRQUFBQTtBQUFiLFVBQW9CUixhQUExQjtBQUNBTCxNQUFBQSxZQUFZLEdBQUcsb0JBQU9BLFlBQVA7QUFDYlEsUUFBQUEsR0FBRyxFQUFFcEIsWUFBR3dCLFlBQUgsQ0FBZ0JKLEdBQWhCLENBRFE7QUFFYkMsUUFBQUEsSUFBSSxFQUFFckIsWUFBR3dCLFlBQUgsQ0FBZ0JILElBQWhCO0FBRk8sU0FHVEksRUFBRSxJQUFJO0FBQ1JBLFFBQUFBLEVBQUUsRUFBRXpCLFlBQUd3QixZQUFILENBQWdCQyxFQUFoQjtBQURJLE9BSEcsRUFBZjtBQU9EOztBQUNELFdBQU9QLGVBQU12QixZQUFOLENBQW1CaUIsWUFBbkIsRUFBaUN6QixHQUFqQyxDQUFQO0FBQ0QsR0E5QkQsQ0E4QkUsT0FBT3VDLEdBQVAsRUFBWTtBQUNaO0FBQ0E3RCxJQUFBQSxNQUFNLENBQUNBLE1BQVAsQ0FBY3dDLEtBQWQsQ0FBb0I7QUFBRXFCLE1BQUFBLEdBQUcsRUFBRUE7QUFBUCxLQUFwQixFQUFrQyxzQ0FBbEM7QUFDQWhCLElBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLENBQWI7QUFDRDtBQUNGOztBQUVELFNBQVNnQixxQkFBVCxDQUErQnBDLFNBQS9CLEVBQXVERCxJQUF2RCxFQUFrRVQsT0FBbEUsRUFBbUZELFVBQW5GLEVBQTZHO0FBQzNHLFFBQU1nQixNQUFNLEdBQUdMLFNBQVMsQ0FDckJGLE1BRFksQ0FDTEMsSUFBSSxDQUFDc0MsSUFBTCxJQUFhdEMsSUFBSSxDQUFDUyxJQURiLEVBQ21CVCxJQUFJLENBQUN1QyxJQUR4QixFQUM4QixNQUFZO0FBQ3JEO0FBQ0EsUUFBSSx3QkFBV25CLE9BQU8sQ0FBQ29CLElBQW5CLENBQUosRUFBOEI7QUFDNUJwQixNQUFBQSxPQUFPLENBQUNvQixJQUFSLENBQWE7QUFDWEMsUUFBQUEsaUJBQWlCLEVBQUU7QUFEUixPQUFiO0FBR0Q7QUFDRixHQVJZLEVBU1pDLEVBVFksQ0FTVCxPQVRTLEVBU0EsVUFBVU4sR0FBVixFQUFxQjtBQUNoQzdELElBQUFBLE1BQU0sQ0FBQ0EsTUFBUCxDQUFjd0MsS0FBZCxDQUFvQjtBQUFFcUIsTUFBQUEsR0FBRyxFQUFFQTtBQUFQLEtBQXBCLEVBQWtDLHNDQUFsQztBQUNBaEIsSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsQ0FBYjtBQUNELEdBWlksQ0FBZjs7QUFjQSxXQUFTc0Isd0JBQVQsR0FBb0M7QUFDbENwRSxJQUFBQSxNQUFNLENBQUNBLE1BQVAsQ0FBY3dDLEtBQWQsQ0FBb0IseURBQXBCO0FBQ0FULElBQUFBLE1BQU0sQ0FBQ3NDLEtBQVAsQ0FBYSxNQUFNO0FBQ2pCckUsTUFBQUEsTUFBTSxDQUFDQSxNQUFQLENBQWNzRSxJQUFkLENBQW1CLGdCQUFuQjtBQUNBekIsTUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsQ0FBYjtBQUNELEtBSEQ7QUFJRCxHQXJCMEcsQ0F1QjNHOzs7QUFDQSxNQUFJRCxPQUFPLENBQUMwQixHQUFSLENBQVlDLDZCQUFaLEtBQThDLE1BQWxELEVBQTBEO0FBQ3hEM0IsSUFBQUEsT0FBTyxDQUFDc0IsRUFBUixDQUFXLFFBQVgsRUFBcUJDLHdCQUFyQjtBQUNBdkIsSUFBQUEsT0FBTyxDQUFDc0IsRUFBUixDQUFXLFNBQVgsRUFBc0JDLHdCQUF0QjtBQUNBdkIsSUFBQUEsT0FBTyxDQUFDc0IsRUFBUixDQUFXLFFBQVgsRUFBcUJDLHdCQUFyQjtBQUNEOztBQUVEcEUsRUFBQUEsTUFBTSxDQUFDQSxNQUFQLENBQWNRLElBQWQsQ0FDRTtBQUNFaUIsSUFBQUEsSUFBSSxFQUFFQSxJQUFJLENBQUNTLElBQUwsR0FDRnVDLGFBQUlDLE1BQUosQ0FBVztBQUNUQyxNQUFBQSxRQUFRLEVBQUUsTUFERDtBQUVUQyxNQUFBQSxRQUFRLEVBQUVuRCxJQUFJLENBQUNTO0FBRk4sS0FBWCxDQURFLEdBS0Z1QyxhQUFJQyxNQUFKLENBQVc7QUFDVEMsTUFBQUEsUUFBUSxFQUFFbEQsSUFBSSxDQUFDRSxLQUROO0FBRVRrRCxNQUFBQSxRQUFRLEVBQUVwRCxJQUFJLENBQUN1QyxJQUZOO0FBR1RELE1BQUFBLElBQUksRUFBRXRDLElBQUksQ0FBQ3NDLElBSEY7QUFJVGEsTUFBQUEsUUFBUSxFQUFFO0FBSkQsS0FBWCxDQU5OO0FBWUVFLElBQUFBLE9BQU8sRUFBRTlELE9BQU8sR0FBRyxHQUFWLEdBQWdCRDtBQVozQixHQURGLEVBZUUscUNBZkY7QUFpQkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVVJMIGZyb20gJ3VybCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0IGNvbnN0YW50cyBmcm9tICdjb25zdGFudHMnO1xuaW1wb3J0IGV4cHJlc3MgZnJvbSAnZXhwcmVzcyc7XG5pbXBvcnQgeyBhc3NpZ24sIGlzT2JqZWN0LCBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHsgQ2FsbGJhY2ssIENvbmZpZ1dpdGhIdHRwcywgSHR0cHNDb25mS2V5Q2VydCwgSHR0cHNDb25mUGZ4IH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvbiB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IGVuZFBvaW50QVBJIGZyb20gJy4uL2FwaS9pbmRleCc7XG5pbXBvcnQgeyBBUElfRVJST1IsIGNlcnRQZW0sIGNzclBlbSwga2V5UGVtIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0TGlzdExpc3RlbkFkZHJlc3NlcywgcmVzb2x2ZUNvbmZpZ1BhdGggfSBmcm9tICcuL2NsaS91dGlscyc7XG5cbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIGRpc3BsYXlFeHBlcmltZW50c0luZm9Cb3goZXhwZXJpbWVudHMpIHtcbiAgY29uc3QgZXhwZXJpbWVudExpc3QgPSBPYmplY3Qua2V5cyhleHBlcmltZW50cyk7XG4gIGlmIChleHBlcmltZW50TGlzdC5sZW5ndGggPj0gMSkge1xuICAgIGxvZ2dlci5sb2dnZXIud2Fybign4pqg77iPICBleHBlcmltZW50cyBhcmUgZW5hYmxlZCwgd2UgcmVjb21tZW5kIGRvIG5vdCB1c2UgZXhwZXJpbWVudHMgaW4gcHJvZHVjdGlvbiwgY29tbWVudCBvdXQgdGhpcyBzZWN0aW9uIHRvIGRpc2FibGUgaXQnKTtcbiAgICBleHBlcmltZW50TGlzdC5mb3JFYWNoKChleHBlcmltZW50KSA9PiB7XG4gICAgICBsb2dnZXIubG9nZ2VyLndhcm4oYCAtIHN1cHBvcnQgZm9yICR7ZXhwZXJpbWVudH0gJHtleHBlcmltZW50c1tleHBlcmltZW50XSA/ICdpcyBlbmFibGVkJyA6ICcgaXMgZGlzYWJsZWQnfWApO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVHJpZ2dlciB0aGUgc2VydmVyIGFmdGVyIGNvbmZpZ3VyYXRpb24gaGFzIGJlZW4gbG9hZGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IGNsaUFyZ3VtZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZ1BhdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwa2dWZXJzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGtnTmFtZVxuICovXG5mdW5jdGlvbiBzdGFydFZlcmRhY2Npbyhjb25maWc6IGFueSwgY2xpTGlzdGVuOiBzdHJpbmcsIGNvbmZpZ1BhdGg6IHN0cmluZywgcGtnVmVyc2lvbjogc3RyaW5nLCBwa2dOYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICBpZiAoaXNPYmplY3QoY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoQVBJX0VSUk9SLkNPTkZJR19CQURfRk9STUFUKTtcbiAgfVxuXG4gIGlmICgnZXhwZXJpbWVudHMnIGluIGNvbmZpZykge1xuICAgIGRpc3BsYXlFeHBlcmltZW50c0luZm9Cb3goY29uZmlnLmV4cGVyaW1lbnRzKTtcbiAgfVxuXG4gIGVuZFBvaW50QVBJKGNvbmZpZykudGhlbigoYXBwKTogdm9pZCA9PiB7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gZ2V0TGlzdExpc3RlbkFkZHJlc3NlcyhjbGlMaXN0ZW4sIGNvbmZpZy5saXN0ZW4pO1xuXG4gICAgYWRkcmVzc2VzLmZvckVhY2goZnVuY3Rpb24gKGFkZHIpOiB2b2lkIHtcbiAgICAgIGxldCB3ZWJTZXJ2ZXI7XG4gICAgICBpZiAoYWRkci5wcm90byA9PT0gJ2h0dHBzJykge1xuICAgICAgICB3ZWJTZXJ2ZXIgPSBoYW5kbGVIVFRQUyhhcHAsIGNvbmZpZ1BhdGgsIGNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBodHRwXG4gICAgICAgIHdlYlNlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKGFwcCk7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnNlcnZlciAmJiB0eXBlb2YgY29uZmlnLnNlcnZlci5rZWVwQWxpdmVUaW1lb3V0ICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuc2VydmVyLmtlZXBBbGl2ZVRpbWVvdXQgIT09ICdudWxsJykge1xuICAgICAgICAvLyBsaWJyYXJ5IGRlZmluaXRpb24gZm9yIG5vZGUgaXMgbm90IHVwIHRvIGRhdGUgKGRvZXNuJ3QgY29udGFpbiByZWNlbnQgOC4wIGNoYW5nZXMpXG4gICAgICAgIHdlYlNlcnZlci5rZWVwQWxpdmVUaW1lb3V0ID0gY29uZmlnLnNlcnZlci5rZWVwQWxpdmVUaW1lb3V0ICogMTAwMDtcbiAgICAgIH1cbiAgICAgIHVubGlua0FkZHJlc3NQYXRoKGFkZHIpO1xuXG4gICAgICBjYWxsYmFjayh3ZWJTZXJ2ZXIsIGFkZHIsIHBrZ05hbWUsIHBrZ1ZlcnNpb24pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5saW5rQWRkcmVzc1BhdGgoYWRkcikge1xuICBpZiAoYWRkci5wYXRoICYmIGZzLmV4aXN0c1N5bmMoYWRkci5wYXRoKSkge1xuICAgIGZzLnVubGlua1N5bmMoYWRkci5wYXRoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2dIVFRQU1dhcm5pbmcoc3RvcmFnZUxvY2F0aW9uKSB7XG4gIGxvZ2dlci5sb2dnZXIuZmF0YWwoXG4gICAgW1xuICAgICAgJ1lvdSBoYXZlIGVuYWJsZWQgSFRUUFMgYW5kIG5lZWQgdG8gc3BlY2lmeSBlaXRoZXIgJyxcbiAgICAgICcgICAgXCJodHRwcy5rZXlcIiBhbmQgXCJodHRwcy5jZXJ0XCIgb3IgJyxcbiAgICAgICcgICAgXCJodHRwcy5wZnhcIiBhbmQgb3B0aW9uYWxseSBcImh0dHBzLnBhc3NwaHJhc2VcIiAnLFxuICAgICAgJ3RvIHJ1biBodHRwcyBzZXJ2ZXInLFxuICAgICAgJycsXG4gICAgICAvLyBjb21tYW5kcyBhcmUgYm9ycm93ZWQgZnJvbSBub2RlLmpzIGRvY3NcbiAgICAgICdUbyBxdWlja2x5IGNyZWF0ZSBzZWxmLXNpZ25lZCBjZXJ0aWZpY2F0ZSwgdXNlOicsXG4gICAgICAnICQgb3BlbnNzbCBnZW5yc2EgLW91dCAnICsgcmVzb2x2ZUNvbmZpZ1BhdGgoc3RvcmFnZUxvY2F0aW9uLCBrZXlQZW0pICsgJyAyMDQ4JyxcbiAgICAgICcgJCBvcGVuc3NsIHJlcSAtbmV3IC1zaGEyNTYgLWtleSAnICsgcmVzb2x2ZUNvbmZpZ1BhdGgoc3RvcmFnZUxvY2F0aW9uLCBrZXlQZW0pICsgJyAtb3V0ICcgKyByZXNvbHZlQ29uZmlnUGF0aChzdG9yYWdlTG9jYXRpb24sIGNzclBlbSksXG4gICAgICAnICQgb3BlbnNzbCB4NTA5IC1yZXEgLWluICcgK1xuICAgICAgICByZXNvbHZlQ29uZmlnUGF0aChzdG9yYWdlTG9jYXRpb24sIGNzclBlbSkgK1xuICAgICAgICAnIC1zaWdua2V5ICcgK1xuICAgICAgICByZXNvbHZlQ29uZmlnUGF0aChzdG9yYWdlTG9jYXRpb24sIGtleVBlbSkgK1xuICAgICAgICAnIC1vdXQgJyArXG4gICAgICAgIHJlc29sdmVDb25maWdQYXRoKHN0b3JhZ2VMb2NhdGlvbiwgY2VydFBlbSksXG4gICAgICAnJyxcbiAgICAgICdBbmQgdGhlbiBhZGQgdG8gY29uZmlnIGZpbGUgKCcgKyBzdG9yYWdlTG9jYXRpb24gKyAnKTonLFxuICAgICAgJyAgaHR0cHM6JyxcbiAgICAgIGAgICAga2V5OiAke3Jlc29sdmVDb25maWdQYXRoKHN0b3JhZ2VMb2NhdGlvbiwga2V5UGVtKX1gLFxuICAgICAgYCAgICBjZXJ0OiAke3Jlc29sdmVDb25maWdQYXRoKHN0b3JhZ2VMb2NhdGlvbiwgY2VydFBlbSl9YCxcbiAgICBdLmpvaW4oJ1xcbicpXG4gICk7XG4gIHByb2Nlc3MuZXhpdCgyKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlSFRUUFMoYXBwOiBleHByZXNzLkFwcGxpY2F0aW9uLCBjb25maWdQYXRoOiBzdHJpbmcsIGNvbmZpZzogQ29uZmlnV2l0aEh0dHBzKTogaHR0cHMuU2VydmVyIHtcbiAgdHJ5IHtcbiAgICBsZXQgaHR0cHNPcHRpb25zID0ge1xuICAgICAgc2VjdXJlT3B0aW9uczogY29uc3RhbnRzLlNTTF9PUF9OT19TU0x2MiB8IGNvbnN0YW50cy5TU0xfT1BfTk9fU1NMdjMsIC8vIGRpc2FibGUgaW5zZWN1cmUgU1NMdjIgYW5kIFNTTHYzXG4gICAgfTtcblxuICAgIGNvbnN0IGtleUNlcnRDb25maWcgPSBjb25maWcuaHR0cHMgYXMgSHR0cHNDb25mS2V5Q2VydDtcbiAgICBjb25zdCBwZnhDb25maWcgPSBjb25maWcuaHR0cHMgYXMgSHR0cHNDb25mUGZ4O1xuXG4gICAgLy8gaHR0cHMgbXVzdCBlaXRoZXIgaGF2ZSBrZXkgYW5kIGNlcnQgb3IgYSBwZnggYW5kIChvcHRpb25hbGx5KSBhIHBhc3NwaHJhc2VcbiAgICBpZiAoISgoa2V5Q2VydENvbmZpZy5rZXkgJiYga2V5Q2VydENvbmZpZy5jZXJ0KSB8fCBwZnhDb25maWcucGZ4KSkge1xuICAgICAgbG9nSFRUUFNXYXJuaW5nKGNvbmZpZ1BhdGgpO1xuICAgIH1cblxuICAgIGlmIChwZnhDb25maWcucGZ4KSB7XG4gICAgICBjb25zdCB7IHBmeCwgcGFzc3BocmFzZSB9ID0gcGZ4Q29uZmlnO1xuICAgICAgaHR0cHNPcHRpb25zID0gYXNzaWduKGh0dHBzT3B0aW9ucywge1xuICAgICAgICBwZng6IGZzLnJlYWRGaWxlU3luYyhwZngpLFxuICAgICAgICBwYXNzcGhyYXNlOiBwYXNzcGhyYXNlIHx8ICcnLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsga2V5LCBjZXJ0LCBjYSB9ID0ga2V5Q2VydENvbmZpZztcbiAgICAgIGh0dHBzT3B0aW9ucyA9IGFzc2lnbihodHRwc09wdGlvbnMsIHtcbiAgICAgICAga2V5OiBmcy5yZWFkRmlsZVN5bmMoa2V5KSxcbiAgICAgICAgY2VydDogZnMucmVhZEZpbGVTeW5jKGNlcnQpLFxuICAgICAgICAuLi4oY2EgJiYge1xuICAgICAgICAgIGNhOiBmcy5yZWFkRmlsZVN5bmMoY2EpLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaHR0cHMuY3JlYXRlU2VydmVyKGh0dHBzT3B0aW9ucywgYXBwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gY2F0Y2ggZXJyb3JzIHJlbGF0ZWQgdG8gY2VydGlmaWNhdGUgbG9hZGluZ1xuICAgIGxvZ2dlci5sb2dnZXIuZmF0YWwoeyBlcnI6IGVyciB9LCAnY2Fubm90IGNyZWF0ZSBzZXJ2ZXI6IEB7ZXJyLm1lc3NhZ2V9Jyk7XG4gICAgcHJvY2Vzcy5leGl0KDIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpc3RlbkRlZmF1bHRDYWxsYmFjayh3ZWJTZXJ2ZXI6IEFwcGxpY2F0aW9uLCBhZGRyOiBhbnksIHBrZ05hbWU6IHN0cmluZywgcGtnVmVyc2lvbjogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IHNlcnZlciA9IHdlYlNlcnZlclxuICAgIC5saXN0ZW4oYWRkci5wb3J0IHx8IGFkZHIucGF0aCwgYWRkci5ob3N0LCAoKTogdm9pZCA9PiB7XG4gICAgICAvLyBzZW5kIGEgbWVzc2FnZSBmb3IgdGVzdHNcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHByb2Nlc3Muc2VuZCkpIHtcbiAgICAgICAgcHJvY2Vzcy5zZW5kKHtcbiAgICAgICAgICB2ZXJkYWNjaW9fc3RhcnRlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycik6IHZvaWQge1xuICAgICAgbG9nZ2VyLmxvZ2dlci5mYXRhbCh7IGVycjogZXJyIH0sICdjYW5ub3QgY3JlYXRlIHNlcnZlcjogQHtlcnIubWVzc2FnZX0nKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgyKTtcbiAgICB9KTtcblxuICBmdW5jdGlvbiBoYW5kbGVTaHV0ZG93bkdyYWNlZnVsbHkoKSB7XG4gICAgbG9nZ2VyLmxvZ2dlci5mYXRhbCgncmVjZWl2ZWQgc2h1dGRvd24gc2lnbmFsIC0gY2xvc2luZyBzZXJ2ZXIgZ3JhY2VmdWxseS4uLicpO1xuICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICBsb2dnZXIubG9nZ2VyLmluZm8oJ3NlcnZlciBjbG9zZWQuJyk7XG4gICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBoYW5kbGUgc2h1dGRvd24gc2lnbmFscyBuaWNlbHkgd2hlbiBlbnZpcm9ubWVudCBzYXlzIHNvXG4gIGlmIChwcm9jZXNzLmVudi5WRVJEQUNDSU9fSEFORExFX0tJTExfU0lHTkFMUyA9PT0gJ3RydWUnKSB7XG4gICAgcHJvY2Vzcy5vbignU0lHSU5UJywgaGFuZGxlU2h1dGRvd25HcmFjZWZ1bGx5KTtcbiAgICBwcm9jZXNzLm9uKCdTSUdURVJNJywgaGFuZGxlU2h1dGRvd25HcmFjZWZ1bGx5KTtcbiAgICBwcm9jZXNzLm9uKCdTSUdIVVAnLCBoYW5kbGVTaHV0ZG93bkdyYWNlZnVsbHkpO1xuICB9XG5cbiAgbG9nZ2VyLmxvZ2dlci53YXJuKFxuICAgIHtcbiAgICAgIGFkZHI6IGFkZHIucGF0aFxuICAgICAgICA/IFVSTC5mb3JtYXQoe1xuICAgICAgICAgICAgcHJvdG9jb2w6ICd1bml4JyxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRyLnBhdGgsXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBVUkwuZm9ybWF0KHtcbiAgICAgICAgICAgIHByb3RvY29sOiBhZGRyLnByb3RvLFxuICAgICAgICAgICAgaG9zdG5hbWU6IGFkZHIuaG9zdCxcbiAgICAgICAgICAgIHBvcnQ6IGFkZHIucG9ydCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiAnLycsXG4gICAgICAgICAgfSksXG4gICAgICB2ZXJzaW9uOiBwa2dOYW1lICsgJy8nICsgcGtnVmVyc2lvbixcbiAgICB9LFxuICAgICdodHRwIGFkZHJlc3MgLSBAe2FkZHJ9IC0gQHt2ZXJzaW9ufSdcbiAgKTtcbn1cblxuZXhwb3J0IHsgc3RhcnRWZXJkYWNjaW8sIGxpc3RlbkRlZmF1bHRDYWxsYmFjayB9O1xuIl19