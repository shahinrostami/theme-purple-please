"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _lodash = _interopRequireDefault(require("lodash"));

var _debug = _interopRequireDefault(require("debug"));

var _constants = require("../../../../lib/constants");

var _utils = require("../../../../lib/utils");

var _authUtils = require("../../../../lib/auth-utils");

var _cryptoUtils = require("../../../../lib/crypto-utils");

var _logger = require("../../../../lib/logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('verdaccio:token');

function normalizeToken(token) {
  return _objectSpread(_objectSpread({}, token), {}, {
    created: new Date(token.created).toISOString()
  });
} // https://github.com/npm/npm-profile/blob/latest/lib/index.js


function _default(route, auth, storage, config) {
  route.get('/-/npm/v1/tokens', async function (req, res, next) {
    const {
      name
    } = req.remote_user;

    if (_lodash.default.isNil(name) === false) {
      try {
        const tokens = await storage.readTokens({
          user: name
        });
        const totalTokens = tokens.length;
        debug('token list retrieved: %o', totalTokens);
        res.status(_constants.HTTP_STATUS.OK);
        return next({
          objects: tokens.map(normalizeToken),
          urls: {
            next: '' // TODO: pagination?

          }
        });
      } catch (error) {
        _logger.logger.error({
          error: error.msg
        }, 'token list has failed: @{error}');

        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.INTERNAL_ERROR, error.message));
      }
    }

    return next(_utils.ErrorCode.getUnauthorized());
  });
  route.post('/-/npm/v1/tokens', function (req, res, next) {
    const {
      password,
      readonly,
      cidr_whitelist
    } = req.body;
    const {
      name
    } = req.remote_user;

    if (!_lodash.default.isBoolean(readonly) || !_lodash.default.isArray(cidr_whitelist)) {
      return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.BAD_DATA, _constants.SUPPORT_ERRORS.PARAMETERS_NOT_VALID));
    }

    auth.authenticate(name, password, async (err, user) => {
      if (err) {
        const errorCode = err.message ? _constants.HTTP_STATUS.UNAUTHORIZED : _constants.HTTP_STATUS.INTERNAL_ERROR;
        return next(_utils.ErrorCode.getCode(errorCode, err.message));
      }

      req.remote_user = user;

      if (!_lodash.default.isFunction(storage.saveToken)) {
        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.NOT_IMPLEMENTED, _constants.SUPPORT_ERRORS.STORAGE_NOT_IMPLEMENT));
      }

      try {
        const token = await (0, _authUtils.getApiToken)(auth, config, user, password);
        const key = (0, _cryptoUtils.stringToMD5)(token); // TODO: use a utility here

        const maskedToken = (0, _utils.mask)(token, 5);
        const created = new Date().getTime();
        /**
         * cidr_whitelist: is not being used, we pass it through
         * token: we do not store the real token (it is generated once and retrieved to the user), just a mask of it.
         */

        const saveToken = {
          user: name,
          token: maskedToken,
          key,
          cidr: cidr_whitelist,
          readonly,
          created
        };
        await storage.saveToken(saveToken);
        debug('token %o was created for user %o', key, name);
        return next(normalizeToken({
          token,
          user: name,
          key: saveToken.key,
          cidr: cidr_whitelist,
          readonly,
          created: saveToken.created
        }));
      } catch (error) {
        _logger.logger.error({
          error: error.msg
        }, 'token creation has failed: @{error}');

        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.INTERNAL_ERROR, error.message));
      }
    });
  });
  route.delete('/-/npm/v1/tokens/token/:tokenKey', async (req, res, next) => {
    const {
      params: {
        tokenKey
      }
    } = req;
    const {
      name
    } = req.remote_user;

    if (_lodash.default.isNil(name) === false) {
      debug('%o has requested remove a token', name);

      try {
        await storage.deleteToken(name, tokenKey);

        _logger.logger.info({
          tokenKey,
          name
        }, 'token id @{tokenKey} was revoked for user @{name}');

        return next({});
      } catch (error) {
        _logger.logger.error({
          error: error.msg
        }, 'token creation has failed: @{error}');

        return next(_utils.ErrorCode.getCode(_constants.HTTP_STATUS.INTERNAL_ERROR, error.message));
      }
    }

    return next(_utils.ErrorCode.getUnauthorized());
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hcGkvZW5kcG9pbnQvYXBpL3YxL3Rva2VuLnRzIl0sIm5hbWVzIjpbImRlYnVnIiwibm9ybWFsaXplVG9rZW4iLCJ0b2tlbiIsImNyZWF0ZWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyb3V0ZSIsImF1dGgiLCJzdG9yYWdlIiwiY29uZmlnIiwiZ2V0IiwicmVxIiwicmVzIiwibmV4dCIsIm5hbWUiLCJyZW1vdGVfdXNlciIsIl8iLCJpc05pbCIsInRva2VucyIsInJlYWRUb2tlbnMiLCJ1c2VyIiwidG90YWxUb2tlbnMiLCJsZW5ndGgiLCJzdGF0dXMiLCJIVFRQX1NUQVRVUyIsIk9LIiwib2JqZWN0cyIsIm1hcCIsInVybHMiLCJlcnJvciIsImxvZ2dlciIsIm1zZyIsIkVycm9yQ29kZSIsImdldENvZGUiLCJJTlRFUk5BTF9FUlJPUiIsIm1lc3NhZ2UiLCJnZXRVbmF1dGhvcml6ZWQiLCJwb3N0IiwicGFzc3dvcmQiLCJyZWFkb25seSIsImNpZHJfd2hpdGVsaXN0IiwiYm9keSIsImlzQm9vbGVhbiIsImlzQXJyYXkiLCJCQURfREFUQSIsIlNVUFBPUlRfRVJST1JTIiwiUEFSQU1FVEVSU19OT1RfVkFMSUQiLCJhdXRoZW50aWNhdGUiLCJlcnIiLCJlcnJvckNvZGUiLCJVTkFVVEhPUklaRUQiLCJpc0Z1bmN0aW9uIiwic2F2ZVRva2VuIiwiTk9UX0lNUExFTUVOVEVEIiwiU1RPUkFHRV9OT1RfSU1QTEVNRU5UIiwia2V5IiwibWFza2VkVG9rZW4iLCJnZXRUaW1lIiwiY2lkciIsImRlbGV0ZSIsInBhcmFtcyIsInRva2VuS2V5IiwiZGVsZXRlVG9rZW4iLCJpbmZvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFJQSxNQUFNQSxLQUFLLEdBQUcsb0JBQVcsaUJBQVgsQ0FBZDs7QUFLQSxTQUFTQyxjQUFULENBQXdCQyxLQUF4QixF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WVUsY0FBOUIsRUFBOENMLEtBQUssQ0FBQ00sT0FBcEQsQ0FBRCxDQUFYO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPdEIsSUFBSSxDQUFDbUIsaUJBQVVJLGVBQVYsRUFBRCxDQUFYO0FBQ0QsR0FsQkQ7QUFtQkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGJ1aWxkRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgUmVzcG9uc2UsIFJvdXRlciB9IGZyb20gJ2V4cHJlc3MnO1xuaW1wb3J0IHsgQ29uZmlnLCBSZW1vdGVVc2VyLCBUb2tlbiB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgSFRUUF9TVEFUVVMsIFNVUFBPUlRfRVJST1JTIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFcnJvckNvZGUsIG1hc2sgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0QXBpVG9rZW4gfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvYXV0aC11dGlscyc7XG5pbXBvcnQgeyBzdHJpbmdUb01ENSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9jcnlwdG8tdXRpbHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGliL2xvZ2dlcic7XG5cbmltcG9ydCB7ICROZXh0RnVuY3Rpb25WZXIsICRSZXF1ZXN0RXh0ZW5kLCBJQXV0aCwgSVN0b3JhZ2VIYW5kbGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdHlwZXMnO1xuXG5jb25zdCBkZWJ1ZyA9IGJ1aWxkRGVidWcoJ3ZlcmRhY2Npbzp0b2tlbicpO1xuZXhwb3J0IHR5cGUgTm9ybWFsaXplVG9rZW4gPSBUb2tlbiAmIHtcbiAgY3JlYXRlZDogc3RyaW5nO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplVG9rZW4odG9rZW46IFRva2VuKTogTm9ybWFsaXplVG9rZW4ge1xuICByZXR1cm4ge1xuICAgIC4uLnRva2VuLFxuICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKHRva2VuLmNyZWF0ZWQpLnRvSVNPU3RyaW5nKCksXG4gIH07XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucG0vbnBtLXByb2ZpbGUvYmxvYi9sYXRlc3QvbGliL2luZGV4LmpzXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAocm91dGU6IFJvdXRlciwgYXV0aDogSUF1dGgsIHN0b3JhZ2U6IElTdG9yYWdlSGFuZGxlciwgY29uZmlnOiBDb25maWcpOiB2b2lkIHtcbiAgcm91dGUuZ2V0KCcvLS9ucG0vdjEvdG9rZW5zJywgYXN5bmMgZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogUmVzcG9uc2UsIG5leHQ6ICROZXh0RnVuY3Rpb25WZXIpIHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IHJlcS5yZW1vdGVfdXNlcjtcblxuICAgIGlmIChfLmlzTmlsKG5hbWUpID09PSBmYWxzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgc3RvcmFnZS5yZWFkVG9rZW5zKHsgdXNlcjogbmFtZSB9KTtcbiAgICAgICAgY29uc3QgdG90YWxUb2tlbnMgPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICBkZWJ1ZygndG9rZW4gbGlzdCByZXRyaWV2ZWQ6ICVvJywgdG90YWxUb2tlbnMpO1xuICAgICAgICByZXMuc3RhdHVzKEhUVFBfU1RBVFVTLk9LKTtcbiAgICAgICAgcmV0dXJuIG5leHQoe1xuICAgICAgICAgIG9iamVjdHM6IHRva2Vucy5tYXAobm9ybWFsaXplVG9rZW4pLFxuICAgICAgICAgIHVybHM6IHtcbiAgICAgICAgICAgIG5leHQ6ICcnLCAvLyBUT0RPOiBwYWdpbmF0aW9uP1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKHsgZXJyb3I6IGVycm9yLm1zZyB9LCAndG9rZW4gbGlzdCBoYXMgZmFpbGVkOiBAe2Vycm9yfScpO1xuICAgICAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0Q29kZShIVFRQX1NUQVRVUy5JTlRFUk5BTF9FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0VW5hdXRob3JpemVkKCkpO1xuICB9KTtcblxuICByb3V0ZS5wb3N0KCcvLS9ucG0vdjEvdG9rZW5zJywgZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogUmVzcG9uc2UsIG5leHQ6ICROZXh0RnVuY3Rpb25WZXIpIHtcbiAgICBjb25zdCB7IHBhc3N3b3JkLCByZWFkb25seSwgY2lkcl93aGl0ZWxpc3QgfSA9IHJlcS5ib2R5O1xuICAgIGNvbnN0IHsgbmFtZSB9ID0gcmVxLnJlbW90ZV91c2VyO1xuXG4gICAgaWYgKCFfLmlzQm9vbGVhbihyZWFkb25seSkgfHwgIV8uaXNBcnJheShjaWRyX3doaXRlbGlzdCkpIHtcbiAgICAgIHJldHVybiBuZXh0KEVycm9yQ29kZS5nZXRDb2RlKEhUVFBfU1RBVFVTLkJBRF9EQVRBLCBTVVBQT1JUX0VSUk9SUy5QQVJBTUVURVJTX05PVF9WQUxJRCkpO1xuICAgIH1cblxuICAgIGF1dGguYXV0aGVudGljYXRlKG5hbWUsIHBhc3N3b3JkLCBhc3luYyAoZXJyLCB1c2VyOiBSZW1vdGVVc2VyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGVyci5tZXNzYWdlID8gSFRUUF9TVEFUVVMuVU5BVVRIT1JJWkVEIDogSFRUUF9TVEFUVVMuSU5URVJOQUxfRVJST1I7XG4gICAgICAgIHJldHVybiBuZXh0KEVycm9yQ29kZS5nZXRDb2RlKGVycm9yQ29kZSwgZXJyLm1lc3NhZ2UpKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnJlbW90ZV91c2VyID0gdXNlcjtcblxuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24oc3RvcmFnZS5zYXZlVG9rZW4pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KEVycm9yQ29kZS5nZXRDb2RlKEhUVFBfU1RBVFVTLk5PVF9JTVBMRU1FTlRFRCwgU1VQUE9SVF9FUlJPUlMuU1RPUkFHRV9OT1RfSU1QTEVNRU5UKSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0QXBpVG9rZW4oYXV0aCwgY29uZmlnLCB1c2VyLCBwYXNzd29yZCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHN0cmluZ1RvTUQ1KHRva2VuKTtcbiAgICAgICAgLy8gVE9ETzogdXNlIGEgdXRpbGl0eSBoZXJlXG4gICAgICAgIGNvbnN0IG1hc2tlZFRva2VuID0gbWFzayh0b2tlbiwgNSk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2lkcl93aGl0ZWxpc3Q6IGlzIG5vdCBiZWluZyB1c2VkLCB3ZSBwYXNzIGl0IHRocm91Z2hcbiAgICAgICAgICogdG9rZW46IHdlIGRvIG5vdCBzdG9yZSB0aGUgcmVhbCB0b2tlbiAoaXQgaXMgZ2VuZXJhdGVkIG9uY2UgYW5kIHJldHJpZXZlZCB0byB0aGUgdXNlciksIGp1c3QgYSBtYXNrIG9mIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc2F2ZVRva2VuOiBUb2tlbiA9IHtcbiAgICAgICAgICB1c2VyOiBuYW1lLFxuICAgICAgICAgIHRva2VuOiBtYXNrZWRUb2tlbixcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgY2lkcjogY2lkcl93aGl0ZWxpc3QsXG4gICAgICAgICAgcmVhZG9ubHksXG4gICAgICAgICAgY3JlYXRlZCxcbiAgICAgICAgfTtcblxuICAgICAgICBhd2FpdCBzdG9yYWdlLnNhdmVUb2tlbihzYXZlVG9rZW4pO1xuICAgICAgICBkZWJ1ZygndG9rZW4gJW8gd2FzIGNyZWF0ZWQgZm9yIHVzZXIgJW8nLCBrZXksIG5hbWUpO1xuICAgICAgICByZXR1cm4gbmV4dChcbiAgICAgICAgICBub3JtYWxpemVUb2tlbih7XG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHVzZXI6IG5hbWUsXG4gICAgICAgICAgICBrZXk6IHNhdmVUb2tlbi5rZXksXG4gICAgICAgICAgICBjaWRyOiBjaWRyX3doaXRlbGlzdCxcbiAgICAgICAgICAgIHJlYWRvbmx5LFxuICAgICAgICAgICAgY3JlYXRlZDogc2F2ZVRva2VuLmNyZWF0ZWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcih7IGVycm9yOiBlcnJvci5tc2cgfSwgJ3Rva2VuIGNyZWF0aW9uIGhhcyBmYWlsZWQ6IEB7ZXJyb3J9Jyk7XG4gICAgICAgIHJldHVybiBuZXh0KEVycm9yQ29kZS5nZXRDb2RlKEhUVFBfU1RBVFVTLklOVEVSTkFMX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJvdXRlLmRlbGV0ZSgnLy0vbnBtL3YxL3Rva2Vucy90b2tlbi86dG9rZW5LZXknLCBhc3luYyAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiBSZXNwb25zZSwgbmV4dDogJE5leHRGdW5jdGlvblZlcikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmFtczogeyB0b2tlbktleSB9LFxuICAgIH0gPSByZXE7XG4gICAgY29uc3QgeyBuYW1lIH0gPSByZXEucmVtb3RlX3VzZXI7XG5cbiAgICBpZiAoXy5pc05pbChuYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgIGRlYnVnKCclbyBoYXMgcmVxdWVzdGVkIHJlbW92ZSBhIHRva2VuJywgbmFtZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzdG9yYWdlLmRlbGV0ZVRva2VuKG5hbWUsIHRva2VuS2V5KTtcbiAgICAgICAgbG9nZ2VyLmluZm8oeyB0b2tlbktleSwgbmFtZSB9LCAndG9rZW4gaWQgQHt0b2tlbktleX0gd2FzIHJldm9rZWQgZm9yIHVzZXIgQHtuYW1lfScpO1xuICAgICAgICByZXR1cm4gbmV4dCh7fSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoeyBlcnJvcjogZXJyb3IubXNnIH0sICd0b2tlbiBjcmVhdGlvbiBoYXMgZmFpbGVkOiBAe2Vycm9yfScpO1xuICAgICAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0Q29kZShIVFRQX1NUQVRVUy5JTlRFUk5BTF9FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0VW5hdXRob3JpemVkKCkpO1xuICB9KTtcbn1cbiJdfQ==