{"version":3,"sources":["../src/index.ts"],"names":["Private","CommandRegistry","this","_timerID","_replaying","_keystrokes","_keydownEvents","_keyBindings","_exactKeyMatch","_commands","Object","create","_commandChanged","Signal","_commandExecuted","_keyBindingChanged","defineProperty","prototype","listCommands","keys","hasCommand","id","addCommand","options","_this","Error","createCommand","emit","type","DisposableDelegate","notifyCommandChanged","undefined","label","args","JSONExt","emptyObject","cmd","call","mnemonic","icon","iconClass","iconLabel","caption","usage","className","dataset","isEnabled","isToggled","isToggleable","isVisible","execute","value","Promise","reject","err","result","resolve","addKeyBinding","binding","createKeyBinding","push","ArrayExt","removeFirstOf","processKeydownEvent","event","keystroke","keystrokeForKeydownEvent","_replayKeydownEvents","_clearPendingState","_a","matchKeyBinding","exact","partial","preventDefault","stopPropagation","_executeKeyBinding","_startTimer","_clearTimer","window","setTimeout","_onPendingTimeout","CHORD_TIMEOUT","clearTimeout","length","forEach","replayKeyEvent","command","word","msg1","join","msg2","console","warn","parseKeystroke","key","alt","ctrl","shift","_i","split","token","Platform","IS_MAC","normalizeKeystroke","mods","parts","normalizeKeys","IS_WIN","winKeys","macKeys","linuxKeys","map","formatKeystroke","getKeyboardLayout","keyForKeydownEvent","ctrlKey","altKey","shiftKey","metaKey","asFunc","emptyStringFunc","undefinedFunc","negativeOneFunc","emptyDatasetFunc","trueFunc","falseFunc","selector","validateSelector","bindings","distance","Infinity","specificity","i","n","sqm","matchSequence","td","targetDistance","sp","Selector","calculateSpecificity","target","dispatchEvent","clone","document","createEvent","bubbles","cancelable","initEvent","keyCode","which","view","cloneKeyboardEvent","dfault","indexOf","isValid","bindKeys","userKeys","targ","curr","currentTarget","dist","parentElement","hasAttribute","matches"],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ArrayExt\n} from '@lumino/algorithm';\n\nimport {\n  JSONExt, ReadonlyJSONObject, ReadonlyPartialJSONObject\n} from '@lumino/coreutils';\n\nimport {\n  DisposableDelegate, IDisposable\n} from '@lumino/disposable';\n\nimport {\n  Platform, Selector\n} from '@lumino/domutils';\n\nimport {\n  getKeyboardLayout\n} from '@lumino/keyboard';\n\nimport {\n  ISignal, Signal\n} from '@lumino/signaling';\n\nimport {\n  VirtualElement\n} from '@lumino/virtualdom';\n\n/**\n * An object which manages a collection of commands.\n *\n * #### Notes\n * A command registry can be used to populate a variety of action-based\n * widgets, such as command palettes, menus, and toolbars.\n */\nexport\nclass CommandRegistry {\n  /**\n   * Construct a new command registry.\n   */\n  constructor() { }\n\n  /**\n   * A signal emitted when a command has changed.\n   *\n   * #### Notes\n   * This signal is useful for visual representations of commands which\n   * need to refresh when the state of a relevant command has changed.\n   */\n  get commandChanged(): ISignal<this, CommandRegistry.ICommandChangedArgs> {\n    return this._commandChanged;\n  }\n\n  /**\n   * A signal emitted when a command has executed.\n   *\n   * #### Notes\n   * Care should be taken when consuming this signal. The command system is used\n   * by many components for many user actions. Handlers registered with this\n   * signal must return quickly to ensure the overall application remains responsive.\n   */\n  get commandExecuted(): ISignal<this, CommandRegistry.ICommandExecutedArgs> {\n    return this._commandExecuted;\n  }\n\n  /**\n   * A signal emitted when a key binding is changed.\n   */\n  get keyBindingChanged(): ISignal<this, CommandRegistry.IKeyBindingChangedArgs> {\n    return this._keyBindingChanged;\n  }\n\n  /**\n   * A read-only array of the key bindings in the registry.\n   */\n  get keyBindings(): ReadonlyArray<CommandRegistry.IKeyBinding> {\n    return this._keyBindings;\n  }\n\n  /**\n   * List the ids of the registered commands.\n   *\n   * @returns A new array of the registered command ids.\n   */\n  listCommands(): string[] {\n    return Object.keys(this._commands);\n  }\n\n  /**\n   * Test whether a specific command is registered.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @returns `true` if the command is registered, `false` otherwise.\n   */\n  hasCommand(id: string): boolean {\n    return id in this._commands;\n  }\n\n  /**\n   * Add a command to the registry.\n   *\n   * @param id - The unique id of the command.\n   *\n   * @param options - The options for the command.\n   *\n   * @returns A disposable which will remove the command.\n   *\n   * @throws An error if the given `id` is already registered.\n   */\n  addCommand(id: string, options: CommandRegistry.ICommandOptions): IDisposable {\n    // Throw an error if the id is already registered.\n    if (id in this._commands) {\n      throw new Error(`Command '${id}' already registered.`);\n    }\n\n    // Add the command to the registry.\n    this._commands[id] = Private.createCommand(options);\n\n    // Emit the `commandChanged` signal.\n    this._commandChanged.emit({ id, type: 'added' });\n\n    // Return a disposable which will remove the command.\n    return new DisposableDelegate(() => {\n      // Remove the command from the registry.\n      delete this._commands[id];\n\n      // Emit the `commandChanged` signal.\n      this._commandChanged.emit({ id, type: 'removed' });\n    });\n  }\n\n  /**\n   * Notify listeners that the state of a command has changed.\n   *\n   * @param id - The id of the command which has changed. If more than\n   *   one command has changed, this argument should be omitted.\n   *\n   * @throws An error if the given `id` is not registered.\n   *\n   * #### Notes\n   * This method should be called by the command author whenever the\n   * application state changes such that the results of the command\n   * metadata functions may have changed.\n   *\n   * This will cause the `commandChanged` signal to be emitted.\n   */\n  notifyCommandChanged(id?: string): void {\n    if (id !== undefined && !(id in this._commands)) {\n      throw new Error(`Command '${id}' is not registered.`);\n    }\n    this._commandChanged.emit({ id, type: id ? 'changed' : 'many-changed' });\n  }\n\n  /**\n   * Get the display label for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The display label for the command, or an empty string\n   *   if the command is not registered.\n   */\n  label(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.label.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the mnemonic index for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The mnemonic index for the command, or `-1` if the\n   *   command is not registered.\n   */\n  mnemonic(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): number {\n    let cmd = this._commands[id];\n    return cmd ? cmd.mnemonic.call(undefined, args) : -1;\n  }\n\n  /**\n   * Get the icon renderer for a specific command.\n   *\n   * DEPRECATED: if set to a string value, the .icon field will\n   * function as an alias for the .iconClass field, for backwards\n   * compatibility. In the future when this is removed, the default\n   * return type will become undefined.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The icon renderer for the command, or\n   *   an empty string if the command is not registered.\n   */\n  icon(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): VirtualElement.IRenderer | undefined\n  /* <DEPRECATED> */ | string /* </DEPRECATED> */\n  {\n    let cmd = this._commands[id];\n    return cmd ? cmd.icon.call(undefined, args) : /* <DEPRECATED> */ '' /* </DEPRECATED> */ /* <FUTURE> undefined </FUTURE> */;\n  }\n\n  /**\n   * Get the icon class for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The icon class for the command, or an empty string if\n   *   the command is not registered.\n   */\n  iconClass(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.iconClass.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the icon label for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The icon label for the command, or an empty string if\n   *   the command is not registered.\n   */\n  iconLabel(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.iconLabel.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the short form caption for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The caption for the command, or an empty string if the\n   *   command is not registered.\n   */\n  caption(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.caption.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the usage help text for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The usage text for the command, or an empty string if\n   *   the command is not registered.\n   */\n  usage(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.usage.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the extra class name for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The class name for the command, or an empty string if\n   *   the command is not registered.\n   */\n  className(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): string {\n    let cmd = this._commands[id];\n    return cmd ? cmd.className.call(undefined, args) : '';\n  }\n\n  /**\n   * Get the dataset for a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns The dataset for the command, or an empty dataset if\n   *   the command is not registered.\n   */\n  dataset(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): CommandRegistry.Dataset {\n    let cmd = this._commands[id];\n    return cmd ? cmd.dataset.call(undefined, args) : {};\n  }\n\n  /**\n   * Test whether a specific command is enabled.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is enabled,\n   *   or `false` if the command is not registered.\n   */\n  isEnabled(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isEnabled.call(undefined, args) : false;\n  }\n\n  /**\n   * Test whether a specific command is toggled.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is toggled,\n   *   or `false` if the command is not registered.\n   */\n  isToggled(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isToggled.call(undefined, args) : false;\n  }\n\n  /**\n   * Test whether a specific command is toggleable.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is toggleable,\n   *   or `false` if the command is not registered.\n   */\n  isToggleable(id: string, args: ReadonlyJSONObject = JSONExt.emptyObject): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isToggleable : false;\n  }\n\n  /**\n   * Test whether a specific command is visible.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A boolean indicating whether the command is visible,\n   *   or `false` if the command is not registered.\n   */\n  isVisible(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): boolean {\n    let cmd = this._commands[id];\n    return cmd ? cmd.isVisible.call(undefined, args) : false;\n  }\n\n  /**\n   * Execute a specific command.\n   *\n   * @param id - The id of the command of interest.\n   *\n   * @param args - The arguments for the command.\n   *\n   * @returns A promise which resolves with the result of the command.\n   *\n   * #### Notes\n   * The promise will reject if the command throws an exception,\n   * or if the command is not registered.\n   */\n  execute(id: string, args: ReadonlyPartialJSONObject = JSONExt.emptyObject): Promise<any> {\n    // Reject if the command is not registered.\n    let cmd = this._commands[id];\n    if (!cmd) {\n      return Promise.reject(new Error(`Command '${id}' not registered.`));\n    }\n\n    // Execute the command and reject if an exception is thrown.\n    let value: any;\n    try {\n      value = cmd.execute.call(undefined, args);\n    } catch (err) {\n      value = Promise.reject(err);\n    }\n\n    // Create the return promise which resolves the result.\n    let result = Promise.resolve(value);\n\n    // Emit the command executed signal.\n    this._commandExecuted.emit({ id, args, result });\n\n    // Return the result promise to the caller.\n    return result;\n  }\n\n  /**\n   * Add a key binding to the registry.\n   *\n   * @param options - The options for creating the key binding.\n   *\n   * @returns A disposable which removes the added key binding.\n   *\n   * #### Notes\n   * If multiple key bindings are registered for the same sequence, the\n   * binding with the highest selector specificity is executed first. A\n   * tie is broken by using the most recently added key binding.\n   *\n   * Ambiguous key bindings are resolved with a timeout. As an example,\n   * suppose two key bindings are registered: one with the key sequence\n   * `['Ctrl D']`, and another with `['Ctrl D', 'Ctrl W']`. If the user\n   * presses `Ctrl D`, the first binding cannot be immediately executed\n   * since the user may intend to complete the chord with `Ctrl W`. For\n   * such cases, a timer is used to allow the chord to be completed. If\n   * the chord is not completed before the timeout, the first binding\n   * is executed.\n   */\n  addKeyBinding(options: CommandRegistry.IKeyBindingOptions): IDisposable {\n    // Create the binding for the given options.\n    let binding = Private.createKeyBinding(options);\n\n    // Add the key binding to the bindings array.\n    this._keyBindings.push(binding);\n\n    // Emit the `bindingChanged` signal.\n    this._keyBindingChanged.emit({ binding, type: 'added' });\n\n    // Return a disposable which will remove the binding.\n    return new DisposableDelegate(() => {\n      // Remove the binding from the array.\n      ArrayExt.removeFirstOf(this._keyBindings, binding);\n\n      // Emit the `bindingChanged` signal.\n      this._keyBindingChanged.emit({ binding, type: 'removed' });\n    });\n  }\n\n  /**\n   * Process a `'keydown'` event and invoke a matching key binding.\n   *\n   * @param event - The event object for a `'keydown'` event.\n   *\n   * #### Notes\n   * This should be called in response to a `'keydown'` event in order\n   * to invoke the command for the best matching key binding.\n   *\n   * The registry **does not** install its own listener for `'keydown'`\n   * events. This allows the application full control over the nodes\n   * and phase for which the registry processes `'keydown'` events.\n   *\n   * When the keydown event is processed, if the event target or any of its\n   * ancestor nodes has a `data-lm-suppress-shortcuts` attribute, its keydown\n   * events will not invoke commands.\n   */\n  processKeydownEvent(event: KeyboardEvent): void {\n    // Bail immediately if playing back keystrokes.\n    if (this._replaying) {\n      return;\n    }\n\n    // Get the normalized keystroke for the event.\n    let keystroke = CommandRegistry.keystrokeForKeydownEvent(event);\n\n    // If the keystroke is not valid for the keyboard layout, replay\n    // any suppressed events and clear the pending state.\n    if (!keystroke) {\n      this._replayKeydownEvents();\n      this._clearPendingState();\n      return;\n    }\n\n    // Add the keystroke to the current key sequence.\n    this._keystrokes.push(keystroke);\n\n    // Find the exact and partial matches for the key sequence.\n    let { exact, partial } = Private.matchKeyBinding(\n      this._keyBindings, this._keystrokes, event\n    );\n\n    // If there is no exact match and no partial match, replay\n    // any suppressed events and clear the pending state.\n    if (!exact && !partial) {\n      this._replayKeydownEvents();\n      this._clearPendingState();\n      return;\n    }\n\n    // Stop propagation of the event. If there is only a partial match,\n    // the event will be replayed if a final exact match never occurs.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // If there is an exact match but no partial match, the exact match\n    // can be dispatched immediately. The pending state is cleared so\n    // the next key press starts from the default state.\n    if (exact && !partial) {\n      this._executeKeyBinding(exact);\n      this._clearPendingState();\n      return;\n    }\n\n    // If there is both an exact match and a partial match, the exact\n    // match is stored for future dispatch in case the timer expires\n    // before a more specific match is triggered.\n    if (exact) {\n      this._exactKeyMatch = exact;\n    }\n\n    // Store the event for possible playback in the future.\n    this._keydownEvents.push(event);\n\n    // (Re)start the timer to dispatch the most recent exact match\n    // in case the partial match fails to result in an exact match.\n    this._startTimer();\n  }\n\n  /**\n   * Start or restart the pending timeout.\n   */\n  private _startTimer(): void {\n    this._clearTimer();\n    this._timerID = window.setTimeout(() => {\n      this._onPendingTimeout();\n    }, Private.CHORD_TIMEOUT);\n  }\n\n  /**\n   * Clear the pending timeout.\n   */\n  private _clearTimer(): void {\n    if (this._timerID !== 0) {\n      clearTimeout(this._timerID);\n      this._timerID = 0;\n    }\n  }\n\n  /**\n   * Replay the keydown events which were suppressed.\n   */\n  private _replayKeydownEvents(): void {\n    if (this._keydownEvents.length === 0) {\n      return;\n    }\n    this._replaying = true;\n    this._keydownEvents.forEach(Private.replayKeyEvent);\n    this._replaying = false;\n  }\n\n  /**\n   * Execute the command for the given key binding.\n   *\n   * If the command is missing or disabled, a warning will be logged.\n   */\n  private _executeKeyBinding(binding: CommandRegistry.IKeyBinding): void {\n    let { command, args } = binding;\n    if (!this.hasCommand(command) || !this.isEnabled(command, args)) {\n      let word = this.hasCommand(command) ? 'enabled' : 'registered';\n      let keys = binding.keys.join(', ');\n      let msg1 = `Cannot execute key binding '${keys}':`;\n      let msg2 = `command '${command}' is not ${word}.`;\n      console.warn(`${msg1} ${msg2}`);\n      return;\n    }\n    this.execute(command, args);\n  }\n\n  /**\n   * Clear the internal pending state.\n   */\n  private _clearPendingState(): void {\n    this._clearTimer();\n    this._exactKeyMatch = null;\n    this._keystrokes.length = 0;\n    this._keydownEvents.length = 0;\n  }\n\n  /**\n   * Handle the partial match timeout.\n   */\n  private _onPendingTimeout(): void {\n    this._timerID = 0;\n    if (this._exactKeyMatch) {\n      this._executeKeyBinding(this._exactKeyMatch);\n    } else {\n      this._replayKeydownEvents();\n    }\n    this._clearPendingState();\n  }\n\n  private _timerID = 0;\n  private _replaying = false;\n  private _keystrokes: string[] = [];\n  private _keydownEvents: KeyboardEvent[] = [];\n  private _keyBindings: CommandRegistry.IKeyBinding[] = [];\n  private _exactKeyMatch: CommandRegistry.IKeyBinding | null = null;\n  private _commands: { [id: string]: Private.ICommand } = Object.create(null);\n  private _commandChanged = new Signal<this, CommandRegistry.ICommandChangedArgs>(this);\n  private _commandExecuted = new Signal<this, CommandRegistry.ICommandExecutedArgs>(this);\n  private _keyBindingChanged = new Signal<this, CommandRegistry.IKeyBindingChangedArgs>(this);\n}\n\n\n/**\n * The namespace for the `CommandRegistry` class statics.\n */\nexport\nnamespace CommandRegistry {\n  /**\n   * A type alias for a user-defined command function.\n   */\n  export\n  type CommandFunc<T> = (args: ReadonlyPartialJSONObject) => T;\n\n  /**\n   * A type alias for a simple immutable string dataset.\n   */\n  export\n  type Dataset = { readonly [key: string]: string };\n\n  /**\n   * An options object for creating a command.\n   *\n   * #### Notes\n   * A command is an abstract representation of code to be executed along\n   * with metadata for describing how the command should be displayed in\n   * a visual representation.\n   *\n   * A command is a collection of functions, *not* methods. The command\n   * registry will always invoke the command functions with a `thisArg`\n   * which is `undefined`.\n   */\n  export\n  interface ICommandOptions {\n    /**\n     * The function to invoke when the command is executed.\n     *\n     * #### Notes\n     * This should return the result of the command (if applicable) or\n     * a promise which yields the result. The result is resolved as a\n     * promise and that promise is returned to the code which executed\n     * the command.\n     *\n     * This may be invoked even when `isEnabled` returns `false`.\n     */\n    execute: CommandFunc<any | Promise<any>>;\n\n    /**\n     * The label for the command.\n     *\n     * #### Notes\n     * This can be a string literal, or a function which returns the\n     * label based on the provided command arguments.\n     *\n     * The label is often used as the primary text for the command.\n     *\n     * The default value is an empty string.\n     */\n    label?: string | CommandFunc<string>;\n\n    /**\n     * The index of the mnemonic character in the command's label.\n     *\n     * #### Notes\n     * This can be an index literal, or a function which returns the\n     * mnemonic index based on the provided command arguments.\n     *\n     * The mnemonic character is often used by menus to provide easy\n     * single-key keyboard access for triggering a menu item. It is\n     * typically rendered as an underlined character in the label.\n     *\n     * The default value is `-1`.\n     */\n    mnemonic?: number | CommandFunc<number>;\n\n    /**\n     * The icon renderer for the command.\n     *\n     * #### Notes\n     * This can be an IRenderer object, or a function which returns the\n     * renderer based on the provided command arguments.\n     *\n     * The default value is undefined.\n     * \n     * DEPRECATED: if set to a string value, the .icon field will function as\n     * an alias for the .iconClass field, for backwards compatibility\n     */\n    icon?: VirtualElement.IRenderer | undefined\n    /* <DEPRECATED> */ | string /* </DEPRECATED> */\n    | CommandFunc<\n      VirtualElement.IRenderer | undefined\n      /* <DEPRECATED> */ | string /* </DEPRECATED> */\n    >;\n    \n    /**\n     * The icon class for the command.\n     *\n     * #### Notes\n     * This class name will be added to the icon node for the visual\n     * representation of the command.\n     *\n     * Multiple class names can be separated with white space.\n     *\n     * This can be a string literal, or a function which returns the\n     * icon based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    iconClass?: string | CommandFunc<string>;\n\n    /**\n     * The icon label for the command.\n     *\n     * #### Notes\n     * This label will be added as text to the icon node for the visual\n     * representation of the command.\n     *\n     * This can be a string literal, or a function which returns the\n     * label based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    iconLabel?: string | CommandFunc<string>;\n\n    /**\n     * The caption for the command.\n     *\n     * #### Notes\n     * This should be a simple one line description of the command. It\n     * is used by some visual representations to show quick info about\n     * the command.\n     *\n     * This can be a string literal, or a function which returns the\n     * caption based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    caption?: string | CommandFunc<string>;\n\n    /**\n     * The usage text for the command.\n     *\n     * #### Notes\n     * This should be a full description of the command, which includes\n     * information about the structure of the arguments and the type of\n     * the return value. It is used by some visual representations when\n     * displaying complete help info about the command.\n     *\n     * This can be a string literal, or a function which returns the\n     * usage text based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    usage?: string | CommandFunc<string>;\n\n    /**\n     * The general class name for the command.\n     *\n     * #### Notes\n     * This class name will be added to the primary node for the visual\n     * representation of the command.\n     *\n     * Multiple class names can be separated with white space.\n     *\n     * This can be a string literal, or a function which returns the\n     * class name based on the provided command arguments.\n     *\n     * The default value is an empty string.\n     */\n    className?: string | CommandFunc<string>;\n\n    /**\n     * The dataset for the command.\n     *\n     * #### Notes\n     * The dataset values will be added to the primary node for the\n     * visual representation of the command.\n     *\n     * This can be a dataset object, or a function which returns the\n     * dataset object based on the provided command arguments.\n     *\n     * The default value is an empty dataset.\n     */\n    dataset?: Dataset | CommandFunc<Dataset>;\n\n    /**\n     * A function which indicates whether the command is enabled.\n     *\n     * #### Notes\n     * Visual representations may use this value to display a disabled\n     * command as grayed-out or in some other non-interactive fashion.\n     *\n     * The default value is `() => true`.\n     */\n    isEnabled?: CommandFunc<boolean>;\n\n    /**\n     * A function which indicates whether the command is toggled.\n     *\n     * #### Notes\n     * Visual representations may use this value to display a toggled\n     * command in a different form, such as a check mark icon for a\n     * menu item or a depressed state for a toggle button.\n     *\n     * The default value is `() => false`.\n     */\n    isToggled?: CommandFunc<boolean>;\n\n    /**\n     * A function which indicates whether the command is toggleable.\n     *\n     * #### Notes\n     * Visual representations may use this value to display a toggled command in\n     * a different form, such as a check box for a menu item or a depressed\n     * state for a toggle button. This attribute also allows for accessible\n     * interfaces to notify the user that the command corresponds to some state.\n     *\n     * The default value is `true` if an `isToggled` function is given, `false`\n     * otherwise.\n     */\n    isToggleable?: boolean;\n\n    /**\n     * A function which indicates whether the command is visible.\n     *\n     * #### Notes\n     * Visual representations may use this value to hide or otherwise\n     * not display a non-visible command.\n     *\n     * The default value is `() => true`.\n     */\n    isVisible?: CommandFunc<boolean>;\n  }\n\n  /**\n   * An arguments object for the `commandChanged` signal.\n   */\n  export\n  interface ICommandChangedArgs {\n    /**\n     * The id of the associated command.\n     *\n     * This will be `undefined` when the type is `'many-changed'`.\n     */\n    readonly id: string | undefined;\n\n    /**\n     * Whether the command was added, removed, or changed.\n     */\n    readonly type: 'added' | 'removed' | 'changed' | 'many-changed';\n  }\n\n  /**\n   * An arguments object for the `commandExecuted` signal.\n   */\n  export\n  interface ICommandExecutedArgs {\n    /**\n     * The id of the associated command.\n     */\n    readonly id: string;\n\n    /**\n     * The arguments object passed to the command.\n     */\n    readonly args: ReadonlyPartialJSONObject;\n\n    /**\n     * The promise which resolves with the result of the command.\n     */\n    readonly result: Promise<any>;\n  }\n\n  /**\n   * An options object for creating a key binding.\n   */\n  export\n  interface IKeyBindingOptions {\n    /**\n     * The default key sequence for the key binding.\n     *\n     * A key sequence is composed of one or more keystrokes, where each\n     * keystroke is a combination of modifiers and a primary key.\n     *\n     * Most key sequences will contain a single keystroke. Key sequences\n     * with multiple keystrokes are called \"chords\", and are useful for\n     * implementing modal input (ala Vim).\n     *\n     * Each keystroke in the sequence should be of the form:\n     *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`\n     *\n     * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and\n     * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and\n     * `Ctrl` on all other platforms. The `Cmd` modifier is ignored on\n     * non-Mac platforms.\n     *\n     * Keystrokes are case sensitive.\n     *\n     * **Examples:** `['Accel C']`, `['Shift F11']`, `['D', 'D']`\n     */\n    keys: string[];\n\n    /**\n     * The CSS selector for the key binding.\n     *\n     * The key binding will only be invoked when the selector matches a\n     * node on the propagation path of the keydown event. This allows\n     * the key binding to be restricted to user-defined contexts.\n     *\n     * The selector must not contain commas.\n     */\n    selector: string;\n\n    /**\n     * The id of the command to execute when the binding is matched.\n     */\n    command: string;\n\n    /**\n     * The arguments for the command, if necessary.\n     *\n     * The default value is an empty object.\n     */\n    args?: ReadonlyPartialJSONObject;\n\n    /**\n     * The key sequence to use when running on Windows.\n     *\n     * If provided, this will override `keys` on Windows platforms.\n     */\n    winKeys?: string[];\n\n    /**\n     * The key sequence to use when running on Mac.\n     *\n     * If provided, this will override `keys` on Mac platforms.\n     */\n    macKeys?: string[];\n\n    /**\n     * The key sequence to use when running on Linux.\n     *\n     * If provided, this will override `keys` on Linux platforms.\n     */\n    linuxKeys?: string[];\n  }\n\n  /**\n   * An object which represents a key binding.\n   *\n   * #### Notes\n   * A key binding is an immutable object created by a registry.\n   */\n  export\n  interface IKeyBinding {\n    /**\n     * The key sequence for the binding.\n     */\n    readonly keys: ReadonlyArray<string>;\n\n    /**\n     * The CSS selector for the binding.\n     */\n    readonly selector: string;\n\n    /**\n     * The command executed when the binding is matched.\n     */\n    readonly command: string;\n\n    /**\n     * The arguments for the command.\n     */\n    readonly args: ReadonlyPartialJSONObject;\n  }\n\n  /**\n   * An arguments object for the `keyBindingChanged` signal.\n   */\n  export\n  interface IKeyBindingChangedArgs {\n    /**\n     * The key binding which was changed.\n     */\n    readonly binding: IKeyBinding;\n\n    /**\n     * Whether the key binding was added or removed.\n     */\n    readonly type: 'added' | 'removed';\n  }\n\n  /**\n   * An object which holds the results of parsing a keystroke.\n   */\n  export\n  interface IKeystrokeParts {\n    /**\n     * Whether `'Cmd'` appears in the keystroke.\n     */\n    cmd: boolean;\n\n    /**\n     * Whether `'Ctrl'` appears in the keystroke.\n     */\n    ctrl: boolean;\n\n    /**\n     * Whether `'Alt'` appears in the keystroke.\n     */\n    alt: boolean;\n\n    /**\n     * Whether `'Shift'` appears in the keystroke.\n     */\n    shift: boolean;\n\n    /**\n     * The primary key for the keystroke.\n     */\n    key: string;\n  }\n\n  /**\n   * Parse a keystroke into its constituent components.\n   *\n   * @param keystroke - The keystroke of interest.\n   *\n   * @returns The parsed components of the keystroke.\n   *\n   * #### Notes\n   * The keystroke should be of the form:\n   *   `[<modifier 1> [<modifier 2> [<modifier N> ]]]<primary key>`\n   *\n   * The supported modifiers are: `Accel`, `Alt`, `Cmd`, `Ctrl`, and\n   * `Shift`. The `Accel` modifier is translated to `Cmd` on Mac and\n   * `Ctrl` on all other platforms.\n   *\n   * The parsing is tolerant and will not throw exceptions. Notably:\n   *   - Duplicate modifiers are ignored.\n   *   - Extra primary keys are ignored.\n   *   - The order of modifiers and primary key is irrelevant.\n   *   - The keystroke parts should be separated by whitespace.\n   *   - The keystroke is case sensitive.\n   */\n  export\n  function parseKeystroke(keystroke: string): IKeystrokeParts {\n    let key = '';\n    let alt = false;\n    let cmd = false;\n    let ctrl = false;\n    let shift = false;\n    for (let token of keystroke.split(/\\s+/)) {\n      if (token === 'Accel') {\n        if (Platform.IS_MAC) {\n          cmd = true;\n        } else {\n          ctrl = true;\n        }\n      } else if (token === 'Alt') {\n        alt = true;\n      } else if (token === 'Cmd') {\n        cmd = true;\n      } else if (token === 'Ctrl') {\n        ctrl = true;\n      } else if (token === 'Shift') {\n        shift = true;\n      } else if (token.length > 0) {\n        key = token;\n      }\n    }\n    return { cmd, ctrl, alt, shift, key };\n  }\n\n  /**\n   * Normalize a keystroke into a canonical representation.\n   *\n   * @param keystroke - The keystroke of interest.\n   *\n   * @returns The normalized representation of the keystroke.\n   *\n   * #### Notes\n   * This normalizes the keystroke by removing duplicate modifiers and\n   * extra primary keys, and assembling the parts in a canonical order.\n   *\n   * The `Cmd` modifier is ignored on non-Mac platforms.\n   */\n  export\n  function normalizeKeystroke(keystroke: string): string {\n    let mods = '';\n    let parts = parseKeystroke(keystroke);\n    if (parts.ctrl) {\n      mods += 'Ctrl ';\n    }\n    if (parts.alt) {\n      mods += 'Alt ';\n    }\n    if (parts.shift) {\n      mods += 'Shift ';\n    }\n    if (parts.cmd && Platform.IS_MAC) {\n      mods += 'Cmd ';\n    }\n    return mods + parts.key;\n  }\n\n  /**\n   * Get the platform-specific normalized keys for an options object.\n   *\n   * @param options - The options for the key binding.\n   *\n   * @returns Array of combined, normalized keys.\n   */\n  export\n  function normalizeKeys(options: IKeyBindingOptions): string[] {\n    let keys: string[];\n    if (Platform.IS_WIN) {\n      keys = options.winKeys || options.keys;\n    } else if (Platform.IS_MAC) {\n      keys = options.macKeys || options.keys;\n    } else {\n      keys = options.linuxKeys || options.keys;\n    }\n    return keys.map(normalizeKeystroke);\n  }\n\n  /**\n   * Format a keystroke for display on the local system.\n   */\n  export\n  function formatKeystroke(keystroke: string): string {\n    let mods = '';\n    let parts = parseKeystroke(keystroke);\n    if (Platform.IS_MAC) {\n      if (parts.ctrl) {\n        mods += '\\u2303 ';\n      }\n      if (parts.alt) {\n        mods += '\\u2325 ';\n      }\n      if (parts.shift) {\n        mods += '\\u21E7 ';\n      }\n      if (parts.cmd) {\n        mods += '\\u2318 ';\n      }\n    } else {\n      if (parts.ctrl) {\n        mods += 'Ctrl+';\n      }\n      if (parts.alt) {\n        mods += 'Alt+';\n      }\n      if (parts.shift) {\n        mods += 'Shift+';\n      }\n    }\n    return mods + parts.key;\n  }\n\n  /**\n   * Create a normalized keystroke for a `'keydown'` event.\n   *\n   * @param event - The event object for a `'keydown'` event.\n   *\n   * @returns A normalized keystroke, or an empty string if the event\n   *   does not represent a valid keystroke for the given layout.\n   */\n  export\n  function keystrokeForKeydownEvent(event: KeyboardEvent): string {\n    let key = getKeyboardLayout().keyForKeydownEvent(event);\n    if (!key) {\n      return '';\n    }\n    let mods = '';\n    if (event.ctrlKey) {\n      mods += 'Ctrl ';\n    }\n    if (event.altKey) {\n      mods += 'Alt ';\n    }\n    if (event.shiftKey) {\n      mods += 'Shift ';\n    }\n    if (event.metaKey && Platform.IS_MAC) {\n      mods += 'Cmd ';\n    }\n    return mods + key;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The timeout in ms for triggering a key binding chord.\n   */\n  export\n  const CHORD_TIMEOUT = 1000;\n\n  /**\n   * A convenience type alias for a command func.\n   */\n  export\n  type CommandFunc<T> = CommandRegistry.CommandFunc<T>;\n\n  /**\n   * A convenience type alias for a command dataset.\n   */\n  export\n  type Dataset = CommandRegistry.Dataset;\n\n  /**\n   * A normalized command object.\n   */\n  export\n  interface ICommand {\n    readonly execute: CommandFunc<any>;\n    readonly label: CommandFunc<string>;\n    readonly mnemonic: CommandFunc<number>;\n    \n    readonly icon: CommandFunc<\n      VirtualElement.IRenderer | undefined\n      /* <DEPRECATED> */ | string /* </DEPRECATED> */\n    >;\n    \n    readonly iconClass: CommandFunc<string>;\n    readonly iconLabel: CommandFunc<string>;\n    readonly caption: CommandFunc<string>;\n    readonly usage: CommandFunc<string>;\n    readonly className: CommandFunc<string>;\n    readonly dataset: CommandFunc<Dataset>;\n    readonly isEnabled: CommandFunc<boolean>;\n    readonly isToggled: CommandFunc<boolean>;\n    readonly isToggleable: boolean;\n    readonly isVisible: CommandFunc<boolean>;\n  }\n\n  /**\n   * Create a normalized command from an options object.\n   */\n  export\n  function createCommand(options: CommandRegistry.ICommandOptions): ICommand {\n    let icon;\n    let iconClass;\n    \n    /* <DEPRECATED> */\n    if (!(options.icon) || typeof options.icon === 'string') {\n      // alias icon to iconClass\n      iconClass = asFunc(options.iconClass || options.icon, emptyStringFunc);\n      icon = iconClass;\n    } else {\n    /* /<DEPRECATED> */\n\n    iconClass = asFunc(options.iconClass, emptyStringFunc);\n    icon = asFunc(options.icon, undefinedFunc);\n\n    /* <DEPRECATED> */\n    }\n    /* </DEPRECATED> */\n    \n    return {\n      execute: options.execute,\n      label: asFunc(options.label, emptyStringFunc),\n      mnemonic: asFunc(options.mnemonic, negativeOneFunc),\n      icon,\n      iconClass,\n      iconLabel: asFunc(options.iconLabel, emptyStringFunc),\n      caption: asFunc(options.caption, emptyStringFunc),\n      usage: asFunc(options.usage, emptyStringFunc),\n      className: asFunc(options.className, emptyStringFunc),\n      dataset: asFunc(options.dataset, emptyDatasetFunc),\n      isEnabled: options.isEnabled || trueFunc,\n      isToggled: options.isToggled || falseFunc,\n      isToggleable: options.isToggleable || !!options.isToggled,\n      isVisible: options.isVisible || trueFunc\n    };\n  }\n\n  /**\n   * Create a key binding object from key binding options.\n   */\n  export\n  function createKeyBinding(options: CommandRegistry.IKeyBindingOptions): CommandRegistry.IKeyBinding {\n    return {\n      keys: CommandRegistry.normalizeKeys(options),\n      selector: validateSelector(options),\n      command: options.command,\n      args: options.args || JSONExt.emptyObject\n    };\n  }\n\n  /**\n   * An object which holds the results of a key binding match.\n   */\n  export\n  interface IMatchResult {\n    /**\n     * The best key binding which exactly matches the key sequence.\n     */\n    exact: CommandRegistry.IKeyBinding | null;\n\n    /**\n     * Whether there are bindings which partially match the sequence.\n     */\n    partial: boolean;\n  }\n\n  /**\n   * Find the key bindings which match a key sequence.\n   *\n   * This returns a match result which contains the best exact matching\n   * binding, and a flag which indicates if there are partial matches.\n   */\n  export\n  function matchKeyBinding(bindings: ReadonlyArray<CommandRegistry.IKeyBinding>, keys: ReadonlyArray<string>, event: KeyboardEvent): IMatchResult {\n    // The current best exact match.\n    let exact: CommandRegistry.IKeyBinding | null = null;\n\n    // Whether a partial match has been found.\n    let partial = false;\n\n    // The match distance for the exact match.\n    let distance = Infinity;\n\n    // The specificity for the exact match.\n    let specificity = 0;\n\n    // Iterate over the bindings and search for the best match.\n    for (let i = 0, n = bindings.length; i < n; ++i) {\n      // Lookup the current binding.\n      let binding = bindings[i];\n\n      // Check whether the key binding sequence is a match.\n      let sqm = matchSequence(binding.keys, keys);\n\n      // If there is no match, the binding is ignored.\n      if (sqm === SequenceMatch.None) {\n        continue;\n      }\n\n      // If it is a partial match and no other partial match has been\n      // found, ensure the selector matches and set the partial flag.\n      if (sqm === SequenceMatch.Partial) {\n        if (!partial && targetDistance(binding.selector, event) !== -1) {\n          partial = true;\n        }\n        continue;\n      }\n\n      // Ignore the match if the selector doesn't match, or if the\n      // matched node is farther away than the current best match.\n      let td = targetDistance(binding.selector, event);\n      if (td === -1 || td > distance) {\n        continue;\n      }\n\n      // Get the specificity for the selector.\n      let sp = Selector.calculateSpecificity(binding.selector);\n\n      // Update the best match if this match is stronger.\n      if (!exact || td < distance || sp >= specificity) {\n        exact = binding;\n        distance = td;\n        specificity = sp;\n      }\n    }\n\n    // Return the match result.\n    return { exact, partial };\n  }\n\n  /**\n   * Replay a keyboard event.\n   *\n   * This synthetically dispatches a clone of the keyboard event.\n   */\n  export\n  function replayKeyEvent(event: KeyboardEvent): void {\n    event.target!.dispatchEvent(cloneKeyboardEvent(event));\n  }\n\n  /**\n   * A singleton empty string function.\n   */\n  const emptyStringFunc = () => '';\n\n  /**\n   * A singleton `-1` number function\n   */\n  const negativeOneFunc = () => -1;\n\n  /**\n   * A singleton true boolean function.\n   */\n  const trueFunc = () => true;\n\n  /**\n   * A singleton false boolean function.\n   */\n  const falseFunc = () => false;\n\n  /**\n   * A singleton empty dataset function.\n   */\n  const emptyDatasetFunc = () => ({});\n\n  /**\n   * A singleton undefined function\n   */\n  const undefinedFunc = () => undefined;\n\n  /**\n   * Cast a value or command func to a command func.\n   */\n  function asFunc<T>(value: undefined | T | CommandFunc<T>, dfault: CommandFunc<T>): CommandFunc<T> {\n    if (value === undefined) {\n      return dfault;\n    }\n    if (typeof value === 'function') {\n      return value as CommandFunc<T>;\n    }\n    return () => value;\n  }\n\n\n\n  /**\n   * Validate the selector for an options object.\n   *\n   * This returns the validated selector, or throws if the selector is\n   * invalid or contains commas.\n   */\n  function validateSelector(options: CommandRegistry.IKeyBindingOptions): string {\n    if (options.selector.indexOf(',') !== -1) {\n      throw new Error(`Selector cannot contain commas: ${options.selector}`);\n    }\n    if (!Selector.isValid(options.selector)) {\n      throw new Error(`Invalid selector: ${options.selector}`);\n    }\n    return options.selector;\n  }\n\n  /**\n   * An enum which describes the possible sequence matches.\n   */\n  const enum SequenceMatch { None, Exact, Partial };\n\n  /**\n   * Test whether a key binding sequence matches a key sequence.\n   *\n   * Returns a `SequenceMatch` value indicating the type of match.\n   */\n  function matchSequence(bindKeys: ReadonlyArray<string>, userKeys: ReadonlyArray<string>): SequenceMatch {\n    if (bindKeys.length < userKeys.length) {\n      return SequenceMatch.None;\n    }\n    for (let i = 0, n = userKeys.length; i < n; ++i) {\n      if (bindKeys[i] !== userKeys[i]) {\n        return SequenceMatch.None;\n      }\n    }\n    if (bindKeys.length > userKeys.length) {\n      return SequenceMatch.Partial;\n    }\n    return SequenceMatch.Exact;\n  }\n\n  /**\n   * Find the distance from the target node to the first matching node.\n   *\n   * This traverses the event path from `target` to `currentTarget` and\n   * computes the distance from `target` to the first node which matches\n   * the CSS selector. If no match is found, `-1` is returned.\n   */\n  function targetDistance(selector: string, event: KeyboardEvent): number {\n    let targ = event.target as (Element | null);\n    let curr = event.currentTarget as (Element | null);\n    for (let dist = 0; targ !== null; targ = targ.parentElement, ++dist) {\n      if (targ.hasAttribute('data-lm-suppress-shortcuts')) {\n        return -1;\n      }\n      /* <DEPRECATED> */\n      if (targ.hasAttribute('data-p-suppress-shortcuts')) {\n        return -1;\n      }\n      /* </DEPRECATED> */\n      if (Selector.matches(targ, selector)) {\n        return dist;\n      }\n      if (targ === curr) {\n        return -1;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Clone a keyboard event.\n   */\n  function cloneKeyboardEvent(event: KeyboardEvent): KeyboardEvent {\n    // A custom event is required because Chrome nulls out the\n    // `keyCode` field in user-generated `KeyboardEvent` types.\n    let clone = document.createEvent('Event') as any;\n    let bubbles = event.bubbles || true;\n    let cancelable = event.cancelable || true;\n    clone.initEvent(event.type || 'keydown', bubbles, cancelable);\n    clone.key = event.key || '';\n    clone.keyCode = event.keyCode || 0;\n    clone.which = event.keyCode || 0;\n    clone.ctrlKey = event.ctrlKey || false;\n    clone.altKey = event.altKey || false;\n    clone.shiftKey = event.shiftKey || false;\n    clone.metaKey = event.metaKey || false;\n    clone.view = event.view || window;\n    return clone as KeyboardEvent;\n  }\n}\n"]}