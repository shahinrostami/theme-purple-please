"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAndTestFacts = void 0;
const spinner = require("../../lib/spinner");
const polling_1 = require("./polling");
async function resolveAndTestFacts(ecosystem, scans, options) {
    var _a, _b, _c;
    const results = [];
    const errors = [];
    for (const [path, scanResults] of Object.entries(scans)) {
        await spinner(`Resolving and Testing fileSignatures in ${path}`);
        for (const scanResult of scanResults) {
            try {
                const res = await polling_1.requestPollingToken(options, true, scanResult);
                const { maxAttempts, pollInterval } = res.pollingTask;
                const attemptsCount = 0;
                const response = await polling_1.pollingWithTokenUntilDone(res.token, ecosystem, options, pollInterval, attemptsCount, maxAttempts);
                results.push({
                    issues: (_a = response === null || response === void 0 ? void 0 : response.result) === null || _a === void 0 ? void 0 : _a.issues,
                    issuesData: (_b = response === null || response === void 0 ? void 0 : response.result) === null || _b === void 0 ? void 0 : _b.issuesData,
                    depGraphData: (_c = response === null || response === void 0 ? void 0 : response.result) === null || _c === void 0 ? void 0 : _c.depGraphData,
                });
            }
            catch (error) {
                const hasStatusCodeError = error.code >= 400 && error.code <= 500;
                if (hasStatusCodeError) {
                    errors.push(error.message);
                    continue;
                }
                const failedPath = path ? `in ${path}` : '.';
                errors.push(`Could not test dependencies ${failedPath}`);
            }
        }
    }
    spinner.clearAll();
    return [results, errors];
}
exports.resolveAndTestFacts = resolveAndTestFacts;
//# sourceMappingURL=resolve-test-facts.js.map