"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pollingWithTokenUntilDone = exports.requestPollingToken = void 0;
const config = require("../config");
const is_ci_1 = require("../is-ci");
const promise_1 = require("../request/promise");
const common_1 = require("../snyk-test/common");
const api_token_1 = require("../api-token");
const common_2 = require("../common");
async function requestPollingToken(options, isAsync, scanResult) {
    const payload = {
        method: 'POST',
        url: `${config.API}/test-dependencies`,
        json: true,
        headers: {
            'x-is-ci': is_ci_1.isCI(),
            authorization: api_token_1.getAuthHeader(),
        },
        body: {
            isAsync,
            scanResult,
        },
        qs: common_1.assembleQueryString(options),
    };
    const response = await promise_1.makeRequest(payload);
    throwIfRequestPollingTokenFailed(response);
    return response;
}
exports.requestPollingToken = requestPollingToken;
function throwIfRequestPollingTokenFailed(res) {
    const { token, status, pollingTask } = res;
    const { maxAttempts, pollInterval } = pollingTask;
    const isMissingPollingTask = !!maxAttempts && !!pollInterval;
    if (!token && !status && isMissingPollingTask) {
        throw 'Something went wrong, invalid response.';
    }
}
async function pollingWithTokenUntilDone(token, type, options, pollInterval, attemptsCount, maxAttempts = Infinity) {
    const payload = {
        method: 'GET',
        url: `${config.API}/test-dependencies/${token}`,
        json: true,
        headers: {
            'x-is-ci': is_ci_1.isCI(),
            authorization: api_token_1.getAuthHeader(),
        },
        qs: { ...common_1.assembleQueryString(options), type },
    };
    const response = await promise_1.makeRequest(payload);
    if (pollingRequestHasFailed(response)) {
        throw response;
    }
    const taskCompleted = response.result && response.meta;
    if (taskCompleted) {
        return response;
    }
    attemptsCount++;
    checkPollingAttempts(maxAttempts)(attemptsCount);
    await common_2.sleep(pollInterval);
    return await pollingWithTokenUntilDone(token, type, options, pollInterval, attemptsCount, maxAttempts);
}
exports.pollingWithTokenUntilDone = pollingWithTokenUntilDone;
function checkPollingAttempts(maxAttempts) {
    return (attemptsCount) => {
        if (attemptsCount > maxAttempts) {
            throw new Error('Exceeded Polling maxAttempts');
        }
    };
}
function pollingRequestHasFailed(response) {
    const { token, result, meta, status, error, code, message } = response;
    const hasError = !!error && !!code && !!message;
    const pollingContextIsMissing = !token && !result && !meta && !status;
    return !!pollingContextIsMissing || hasError;
}
//# sourceMappingURL=polling.js.map