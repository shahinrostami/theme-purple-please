"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidYamlFileError = exports.InvalidJsonFileError = exports.parseYAMLOrJSON = exports.shouldThrowErrorFor = exports.parseYAMLOrJSONFileData = void 0;
const YAML = require("yaml");
const errors_1 = require("../../../../lib/errors");
const error_utils_1 = require("./error-utils");
const types_1 = require("./types");
function parseYAMLOrJSONFileData(fileData) {
    try {
        return parseYAMLOrJSON(fileData.fileContent);
    }
    catch (e) {
        if (fileData.fileType === 'json') {
            throw new InvalidJsonFileError(fileData.filePath);
        }
        else {
            throw new InvalidYamlFileError(fileData.filePath);
        }
    }
}
exports.parseYAMLOrJSONFileData = parseYAMLOrJSONFileData;
const errorsToSkip = [
    'Insufficient indentation in flow collection',
    'Map keys must be unique',
];
// the YAML Parser is more strict than the Golang one in Policy Engine,
// so we decided to skip specific errors in order to be consistent.
// this function checks if the current error is one them
function shouldThrowErrorFor(doc) {
    return (doc.errors.length !== 0 &&
        !errorsToSkip.some((e) => doc.errors[0].message.includes(e)));
}
exports.shouldThrowErrorFor = shouldThrowErrorFor;
const warningsToInclude = [
    'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.',
];
// The YAML Parser is less strict than the Golang one when it comes to templating directives
// instead it returns them as warnings
// which we now throw on
function shouldThrowWarningFor(doc) {
    return (doc.warnings.length !== 0 &&
        warningsToInclude.some((e) => doc.warnings[0].message.includes(e)));
}
function parseYAMLOrJSON(fileContent) {
    // the YAML library can parse both YAML and JSON content, as well as content with singe/multiple YAMLs
    // by using this library we don't have to disambiguate between these different contents ourselves
    return YAML.parseAllDocuments(fileContent).map((doc) => {
        if (shouldThrowErrorFor(doc)) {
            throw doc.errors[0];
        }
        if (shouldThrowWarningFor(doc)) {
            throw doc.warnings[0];
        }
        return doc.toJSON();
    });
}
exports.parseYAMLOrJSON = parseYAMLOrJSON;
class InvalidJsonFileError extends errors_1.CustomError {
    constructor(filename) {
        super('Failed to parse JSON file');
        this.code = types_1.IaCErrorCodes.InvalidJsonFileError;
        this.strCode = error_utils_1.getErrorStringCode(this.code);
        this.userMessage = `We were unable to parse the JSON file "${filename}". Please ensure that it contains properly structured JSON`;
    }
}
exports.InvalidJsonFileError = InvalidJsonFileError;
class InvalidYamlFileError extends errors_1.CustomError {
    constructor(filename) {
        super('Failed to parse YAML file');
        this.code = types_1.IaCErrorCodes.InvalidYamlFileError;
        this.strCode = error_utils_1.getErrorStringCode(this.code);
        this.userMessage = `We were unable to parse the YAML file "${filename}". Please ensure that it contains properly structured YAML, without any template directives`;
    }
}
exports.InvalidYamlFileError = InvalidYamlFileError;
//# sourceMappingURL=yaml-parser.js.map