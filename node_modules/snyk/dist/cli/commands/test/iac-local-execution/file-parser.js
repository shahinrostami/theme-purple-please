"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnsupportedFileTypeError = exports.tryParseIacFile = exports.parseFiles = void 0;
const k8s_or_cloudformation_parser_1 = require("./parsers/k8s-or-cloudformation-parser");
const terraform_file_parser_1 = require("./parsers/terraform-file-parser");
const file_loader_1 = require("./file-loader");
const terraform_plan_parser_1 = require("./parsers/terraform-plan-parser");
const types_1 = require("./types");
const analytics = require("../../../../lib/analytics");
const errors_1 = require("../../../../lib/errors");
const error_utils_1 = require("./error-utils");
const yaml_parser_1 = require("./yaml-parser");
async function parseFiles(filesData, options = {}) {
    const parsedFiles = [];
    const failedFiles = [];
    for (const fileData of filesData) {
        try {
            parsedFiles.push(...tryParseIacFile(fileData, options));
        }
        catch (err) {
            if (filesData.length === 1) {
                throw err;
            }
            failedFiles.push(generateFailedParsedFile(fileData, err));
        }
    }
    if (parsedFiles.length === 0) {
        throw new file_loader_1.NoFilesToScanError();
    }
    return {
        parsedFiles,
        failedFiles,
    };
}
exports.parseFiles = parseFiles;
function generateFailedParsedFile({ fileType, filePath, fileContent }, err) {
    return {
        err,
        failureReason: err.message,
        fileType,
        filePath,
        fileContent,
        engineType: null,
        jsonContent: null,
    };
}
function tryParseIacFile(fileData, options = {}) {
    analytics.add('iac-terraform-plan', false);
    switch (fileData.fileType) {
        case 'yaml':
        case 'yml': {
            const parsedIacFile = yaml_parser_1.parseYAMLOrJSONFileData(fileData);
            return k8s_or_cloudformation_parser_1.detectConfigType(fileData, parsedIacFile);
        }
        case 'json': {
            const parsedIacFile = yaml_parser_1.parseYAMLOrJSONFileData(fileData);
            // the Kubernetes file can have more than one JSON object in it
            // but the Terraform plan can only have one
            if (parsedIacFile.length === 1 && terraform_plan_parser_1.isTerraformPlan(parsedIacFile[0])) {
                analytics.add('iac-terraform-plan', true);
                return terraform_plan_parser_1.tryParsingTerraformPlan(fileData, parsedIacFile[0], {
                    isFullScan: options.scan === types_1.TerraformPlanScanMode.FullScan,
                });
            }
            else {
                return k8s_or_cloudformation_parser_1.detectConfigType(fileData, parsedIacFile);
            }
        }
        case 'tf':
            return terraform_file_parser_1.tryParsingTerraformFile(fileData);
        default:
            throw new UnsupportedFileTypeError(fileData.fileType);
    }
}
exports.tryParseIacFile = tryParseIacFile;
class UnsupportedFileTypeError extends errors_1.CustomError {
    constructor(fileType) {
        super('Unsupported file extension');
        this.code = types_1.IaCErrorCodes.UnsupportedFileTypeError;
        this.strCode = error_utils_1.getErrorStringCode(this.code);
        this.userMessage = `Unable to process the file with extension ${fileType}. Supported file extensions are tf, yml, yaml & json.\nMore information can be found by running \`snyk iac test --help\` or through our documentation:\nhttps://support.snyk.io/hc/en-us/articles/360012429477-Test-your-Kubernetes-files-with-our-CLI-tool\nhttps://support.snyk.io/hc/en-us/articles/360013723877-Test-your-Terraform-files-with-our-CLI-tool`;
    }
}
exports.UnsupportedFileTypeError = UnsupportedFileTypeError;
//# sourceMappingURL=file-parser.js.map