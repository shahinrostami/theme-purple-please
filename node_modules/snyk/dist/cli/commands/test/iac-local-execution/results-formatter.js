"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FailedToFormatResults = exports.filterPoliciesBySeverity = exports.formatScanResults = void 0;
const types_1 = require("./types");
const path_1 = require("./parsers/path");
const path = require("path");
const common_1 = require("../../../../lib/snyk-test/common");
const constants_1 = require("../../../../lib/iac/constants");
const errors_1 = require("../../../../lib/errors");
const extract_line_number_1 = require("./extract-line-number");
const error_utils_1 = require("./error-utils");
const detect_1 = require("../../../../lib/detect");
const SEVERITIES = [common_1.SEVERITY.LOW, common_1.SEVERITY.MEDIUM, common_1.SEVERITY.HIGH];
function formatScanResults(scanResults, options, meta) {
    try {
        const groupedByFile = scanResults.reduce((memo, scanResult) => {
            const res = formatScanResult(scanResult, meta, options);
            if (memo[scanResult.filePath]) {
                memo[scanResult.filePath].result.cloudConfigResults.push(...res.result.cloudConfigResults);
            }
            else {
                memo[scanResult.filePath] = res;
            }
            return memo;
        }, {});
        return Object.values(groupedByFile);
    }
    catch (e) {
        throw new FailedToFormatResults();
    }
}
exports.formatScanResults = formatScanResults;
const engineTypeToProjectType = {
    [types_1.EngineType.Kubernetes]: constants_1.IacProjectType.K8S,
    [types_1.EngineType.Terraform]: constants_1.IacProjectType.TERRAFORM,
    [types_1.EngineType.CloudFormation]: constants_1.IacProjectType.CLOUDFORMATION,
    [types_1.EngineType.Custom]: constants_1.IacProjectType.CUSTOM,
};
function formatScanResult(scanResult, meta, options) {
    const formattedIssues = scanResult.violatedPolicies.map((policy) => {
        const cloudConfigPath = scanResult.docId !== undefined
            ? [`[DocId: ${scanResult.docId}]`].concat(path_1.parsePath(policy.msg))
            : policy.msg.split('.');
        const flagsRequiringLineNumber = [
            'json',
            'sarif',
            'json-file-output',
            'sarif-file-output',
        ];
        const shouldExtractLineNumber = flagsRequiringLineNumber.some((flag) => options[flag]);
        const lineNumber = shouldExtractLineNumber
            ? extract_line_number_1.extractLineNumber(scanResult.fileContent, scanResult.fileType, cloudConfigPath)
            : -1;
        return {
            ...policy,
            id: policy.publicId,
            name: policy.title,
            cloudConfigPath,
            isIgnored: false,
            iacDescription: {
                issue: policy.issue,
                impact: policy.impact,
                resolve: policy.resolve,
            },
            severity: policy.severity,
            lineNumber,
            documentation: `https://snyk.io/security-rules/${policy.publicId}`,
        };
    });
    const { targetFilePath, projectName, targetFile } = computePaths(scanResult.filePath, options.path);
    return {
        result: {
            cloudConfigResults: filterPoliciesBySeverity(formattedIssues, options.severityThreshold),
            projectType: scanResult.projectType,
        },
        meta: {
            ...meta,
            projectId: '',
            policy: '',
        },
        filesystemPolicy: false,
        vulnerabilities: [],
        dependencyCount: 0,
        licensesPolicy: null,
        ignoreSettings: null,
        targetFile,
        projectName,
        org: meta.org,
        policy: '',
        isPrivate: true,
        targetFilePath,
        packageManager: engineTypeToProjectType[scanResult.engineType],
    };
}
function computePaths(filePath, pathArg = '.') {
    const targetFilePath = path.resolve(filePath, '.');
    // the absolute path is needed to compute the full project path
    const cmdPath = path.resolve(pathArg);
    let projectPath;
    let targetFile;
    if (!detect_1.isLocalFolder(cmdPath)) {
        // if the provided path points to a file, then the project starts at the parent folder of that file
        // and the target file was provided as the path argument
        projectPath = path.dirname(cmdPath);
        targetFile = path.isAbsolute(pathArg)
            ? path.relative(process.cwd(), pathArg)
            : pathArg;
    }
    else {
        // otherwise, the project starts at the provided path
        // and the target file must be the relative path from the project path to the path of the scanned file
        projectPath = cmdPath;
        targetFile = path.relative(projectPath, targetFilePath);
    }
    return {
        targetFilePath,
        projectName: path.basename(projectPath),
        targetFile,
    };
}
function filterPoliciesBySeverity(violatedPolicies, severityThreshold) {
    if (!severityThreshold || severityThreshold === common_1.SEVERITY.LOW) {
        return violatedPolicies.filter((violatedPolicy) => {
            return violatedPolicy.severity !== 'none';
        });
    }
    const severitiesToInclude = SEVERITIES.slice(SEVERITIES.indexOf(severityThreshold));
    return violatedPolicies.filter((policy) => {
        return (policy.severity !== 'none' &&
            severitiesToInclude.includes(policy.severity));
    });
}
exports.filterPoliciesBySeverity = filterPoliciesBySeverity;
class FailedToFormatResults extends errors_1.CustomError {
    constructor(message) {
        super(message || 'Failed to format results');
        this.code = types_1.IaCErrorCodes.FailedToFormatResults;
        this.strCode = error_utils_1.getErrorStringCode(this.code);
        this.userMessage =
            'We failed printing the results, please contact support@snyk.io';
    }
}
exports.FailedToFormatResults = FailedToFormatResults;
//# sourceMappingURL=results-formatter.js.map