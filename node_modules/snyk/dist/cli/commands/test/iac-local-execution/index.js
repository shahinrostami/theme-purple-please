"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeFileContent = exports.test = void 0;
const detect_1 = require("../../../../lib/detect");
const types_1 = require("./types");
const analytics_1 = require("./analytics");
const usage_tracking_1 = require("./usage-tracking");
const policy_1 = require("./policy");
const measurable_methods_1 = require("./measurable-methods");
const feature_flags_1 = require("../../../../lib/feature-flags");
const assert_iac_options_flag_1 = require("./assert-iac-options-flag");
const config = require("../../../../lib/config");
const find_and_load_policy_1 = require("../../../../lib/policy/find-and-load-policy");
// this method executes the local processing engine and then formats the results to adapt with the CLI output.
// this flow is the default GA flow for IAC scanning.
async function test(pathToScan, options) {
    var _a;
    try {
        const org = (_a = options.org) !== null && _a !== void 0 ? _a : config.org;
        const iacOrgSettings = await measurable_methods_1.getIacOrgSettings(org);
        const customRulesPath = await customRulesPathForOrg(options.rules, org);
        await measurable_methods_1.initLocalCache({ customRulesPath });
        const policy = await find_and_load_policy_1.findAndLoadPolicy(pathToScan, 'iac', options);
        const filesToParse = await measurable_methods_1.loadFiles(pathToScan, options);
        const { parsedFiles, failedFiles } = await measurable_methods_1.parseFiles(filesToParse, options);
        // Duplicate all the files and run them through the custom engine.
        if (customRulesPath) {
            parsedFiles.push(...parsedFiles.map((file) => ({
                ...file,
                engineType: types_1.EngineType.Custom,
            })));
        }
        const scannedFiles = await measurable_methods_1.scanFiles(parsedFiles);
        const resultsWithCustomSeverities = await measurable_methods_1.applyCustomSeverities(scannedFiles, iacOrgSettings.customPolicies);
        const formattedResults = measurable_methods_1.formatScanResults(resultsWithCustomSeverities, options, iacOrgSettings.meta);
        const { filteredIssues, ignoreCount } = policy_1.filterIgnoredIssues(policy, formattedResults);
        try {
            await measurable_methods_1.trackUsage(filteredIssues);
        }
        catch (e) {
            if (e instanceof usage_tracking_1.TestLimitReachedError) {
                throw e;
            }
            // If something has gone wrong, err on the side of allowing the user to
            // run their tests by squashing the error.
        }
        analytics_1.addIacAnalytics(filteredIssues, ignoreCount);
        // TODO: add support for proper typing of old TestResult interface.
        return {
            results: filteredIssues,
            // NOTE: No file or parsed file data should leave this function.
            failures: detect_1.isLocalFolder(pathToScan)
                ? failedFiles.map(removeFileContent)
                : undefined,
        };
    }
    finally {
        measurable_methods_1.cleanLocalCache();
    }
}
exports.test = test;
async function customRulesPathForOrg(customRulesPath, publicOrgId) {
    if (!customRulesPath)
        return;
    const isCustomRulesSupported = (await feature_flags_1.isFeatureFlagSupportedForOrg('iacCustomRules', publicOrgId)).ok ===
        true;
    if (isCustomRulesSupported) {
        return customRulesPath;
    }
    throw new assert_iac_options_flag_1.FlagError('rules');
}
function removeFileContent({ filePath, fileType, failureReason, projectType, }) {
    return {
        filePath,
        fileType,
        failureReason,
        projectType,
    };
}
exports.removeFileContent = removeFileContent;
//# sourceMappingURL=index.js.map