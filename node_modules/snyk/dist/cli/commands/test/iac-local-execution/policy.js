"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterIgnoredIssues = void 0;
function filterIgnoredIssues(policy, results) {
    if (!policy) {
        return { filteredIssues: results, ignoreCount: 0 };
    }
    const vulns = results.map((res) => policy.filter(toIaCVulnAdapter(res), undefined, 'exact'));
    const ignoreCount = vulns.reduce((totalIgnored, vuln) => totalIgnored + vuln.filtered.ignore.length, 0);
    const filteredIssues = vulns.map((vuln) => toFormattedResult(vuln));
    return { filteredIssues, ignoreCount };
}
exports.filterIgnoredIssues = filterIgnoredIssues;
function toIaCVulnAdapter(result) {
    return {
        vulnerabilities: result.result.cloudConfigResults.map((cloudConfigResult) => {
            const annotatedResult = cloudConfigResult;
            // Copy the cloudConfigPath array to avoid modifying the original with
            // splice.
            // Insert the targetFile into the path so that it is taken into account
            // when determining whether an ignore rule should be applied.
            const path = [...annotatedResult.cloudConfigPath];
            path.splice(0, 0, result.targetFile);
            return {
                id: cloudConfigResult.id,
                from: path,
            };
        }),
        originalResult: result,
    };
}
function toFormattedResult(adapter) {
    const original = adapter.originalResult;
    const filteredCloudConfigResults = original.result.cloudConfigResults.filter((res) => {
        return adapter.vulnerabilities.some((vuln) => {
            if (vuln.id !== res.id) {
                return false;
            }
            // Unfortunately we are forced to duplicate the logic in
            // toIaCVulnAdapter so that we're comparing path components properly,
            // including target file context. As that logic changes, so must this.
            const annotatedResult = res;
            const significantPath = [...annotatedResult.cloudConfigPath];
            significantPath.splice(0, 0, original.targetFile);
            if (vuln.from.length !== significantPath.length) {
                return false;
            }
            for (let i = 0; i < vuln.from.length; i++) {
                if (vuln.from[i] !== significantPath[i]) {
                    return false;
                }
            }
            return true;
        });
    });
    original.result.cloudConfigResults = filteredCloudConfigResults;
    return original;
}
//# sourceMappingURL=policy.js.map