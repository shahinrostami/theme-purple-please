"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBundleFromFolders = exports.remoteBundleFactory = exports.uploadRemoteBundle = void 0;
/* eslint-disable no-await-in-loop */
const lodash_chunk_1 = __importDefault(require("lodash.chunk"));
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const lodash_omit_1 = __importDefault(require("lodash.omit"));
const files_1 = require("./files");
const http_1 = require("./http");
const constants_1 = require("./constants");
const emitter_1 = __importDefault(require("./emitter"));
async function* prepareRemoteBundle({ maxPayload = constants_1.MAX_PAYLOAD, ...options }) {
    let response;
    let { bundleHash } = options;
    const fileChunks = lodash_chunk_1.default(options.files, maxPayload / 300);
    emitter_1.default.createBundleProgress(0, fileChunks.length);
    for (const [i, chunkedFiles] of fileChunks.entries()) {
        const apiParams = {
            ...lodash_pick_1.default(options, ['baseURL', 'sessionToken', 'source', 'removedFiles']),
            files: chunkedFiles.reduce((d, f) => ({ ...d, [f.bundlePath]: f.hash }), {}),
        };
        if (!bundleHash) {
            // eslint-disable-next-line no-await-in-loop
            response = await http_1.createBundle(apiParams);
        }
        else {
            // eslint-disable-next-line no-await-in-loop
            response = await http_1.extendBundle({ bundleHash, ...apiParams });
        }
        emitter_1.default.createBundleProgress(i + 1, fileChunks.length);
        if (response.type === 'error') {
            // TODO: process Error
            yield response;
            break;
        }
        bundleHash = response.value.bundleHash;
        yield response;
    }
}
/**
 * Splits files in buckets and upload in parallel
 * @param baseURL
 * @param sessionToken
 * @param remoteBundle
 */
async function uploadRemoteBundle({ maxPayload = constants_1.MAX_PAYLOAD, ...options }) {
    let uploadedFiles = 0;
    emitter_1.default.uploadBundleProgress(0, options.files.length);
    const apiParams = lodash_pick_1.default(options, ['baseURL', 'sessionToken', 'source', 'bundleHash']);
    const uploadFileChunks = async (bucketFiles) => {
        const resp = await http_1.extendBundle({
            ...apiParams,
            files: bucketFiles.reduce((d, f) => ({ ...d, [f.bundlePath]: lodash_pick_1.default(f, ['hash', 'content']) }), {}),
        });
        if (resp.type !== 'error') {
            uploadedFiles += bucketFiles.length;
            emitter_1.default.uploadBundleProgress(uploadedFiles, options.files.length);
            return true;
        }
        return false;
    };
    const tasks = [];
    for (const bucketFiles of files_1.composeFilePayloads(options.files, maxPayload)) {
        tasks.push(uploadFileChunks(bucketFiles));
    }
    if (tasks.length) {
        return (await Promise.all(tasks)).some(r => !!r);
    }
    return true;
}
exports.uploadRemoteBundle = uploadRemoteBundle;
async function fullfillRemoteBundle(options) {
    // Fulfill remote bundle by uploading only missing files (splitted in chunks)
    // Check remove bundle to make sure no missing files left
    let attempts = 0;
    let { remoteBundle } = options;
    const connectionOptions = lodash_pick_1.default(options, ['baseURL', 'sessionToken', 'source']);
    while (remoteBundle.missingFiles.length && attempts < (options.maxAttempts || constants_1.MAX_UPLOAD_ATTEMPTS)) {
        const missingFiles = await files_1.resolveBundleFiles(options.baseDir, remoteBundle.missingFiles);
        const isUploaded = await uploadRemoteBundle({
            ...connectionOptions,
            bundleHash: remoteBundle.bundleHash,
            files: missingFiles,
        });
        if (!isUploaded) {
            throw new Error('Failed to upload some files');
        }
        const bundleResponse = await http_1.checkBundle({ ...connectionOptions, bundleHash: remoteBundle.bundleHash });
        if (bundleResponse.type === 'error') {
            throw new Error('Failed to get remote bundle');
        }
        // eslint-disable-next-line no-param-reassign
        remoteBundle = bundleResponse.value;
        attempts += 1;
    }
    return remoteBundle;
}
async function remoteBundleFactory(options) {
    let remoteBundle = null;
    const baseOptions = lodash_pick_1.default(options, ['baseURL', 'sessionToken', 'source', 'baseDir']);
    const bundleFactory = prepareRemoteBundle(lodash_omit_1.default(options, ['baseDir']));
    for await (const response of bundleFactory) {
        if (response.type === 'error') {
            throw response.error;
        }
        remoteBundle = await fullfillRemoteBundle({ ...baseOptions, remoteBundle: response.value });
        if (remoteBundle.missingFiles.length) {
            throw new Error(`Failed to upload # files: ${remoteBundle.missingFiles.length}`);
        }
    }
    return remoteBundle;
}
exports.remoteBundleFactory = remoteBundleFactory;
/**
 * Get supported filters and test baseURL for correctness and availability
 *
 * @param baseURL
 * @param source
 * @returns
 */
async function getSupportedFiles(baseURL, source) {
    emitter_1.default.supportedFilesLoaded(null);
    const resp = await http_1.getFilters(baseURL, source);
    if (resp.type === 'error') {
        throw resp.error;
    }
    const supportedFiles = resp.value;
    emitter_1.default.supportedFilesLoaded(supportedFiles);
    return supportedFiles;
}
/**
 * Creates a remote bundle and returns response from the bundle API
 *
 * @param {CreateBundleFromFoldersOptions} options
 * @returns {Promise<FileBundle | null>}
 */
async function createBundleFromFolders(options) {
    const baseDir = files_1.determineBaseDir(options.paths);
    // Fetch supporte files to save network traffic
    const supportedFiles = await getSupportedFiles(options.baseURL, options.source);
    // Scan for custom ignore rules
    const fileIgnores = await files_1.collectIgnoreRules(options.paths, options.symlinksEnabled, options.defaultFileIgnores);
    emitter_1.default.scanFilesProgress(0);
    const bundleFiles = [];
    let totalFiles = 0;
    const bundleFileCollector = files_1.collectBundleFiles({
        ...lodash_pick_1.default(options, ['paths', 'symlinksEnabled', 'maxPayload']),
        baseDir,
        fileIgnores,
        supportedFiles,
    });
    for await (const f of bundleFileCollector) {
        bundleFiles.push(f);
        totalFiles += 1;
        emitter_1.default.scanFilesProgress(totalFiles);
    }
    const bundleOptions = {
        ...lodash_pick_1.default(options, ['baseURL', 'sessionToken', 'source']),
        baseDir,
        files: bundleFiles,
    };
    // Create remote bundle
    if (!bundleFiles.length)
        return null;
    const remoteBundle = await remoteBundleFactory(bundleOptions);
    if (remoteBundle === null)
        return null;
    return {
        ...remoteBundle,
        baseDir,
        supportedFiles,
        fileIgnores,
    };
}
exports.createBundleFromFolders = createBundleFromFolders;
//# sourceMappingURL=bundles.js.map