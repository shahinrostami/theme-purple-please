"use strict";
/* eslint-disable no-await-in-loop */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendAnalysis = exports.analyzeFolders = exports.analyzeBundle = void 0;
const files_1 = require("./files");
const http_1 = require("./http");
const bundles_1 = require("./bundles");
const emitter_1 = __importDefault(require("./emitter"));
const sleep = (duration) => new Promise(resolve => setTimeout(resolve, duration));
async function pollAnalysis(options) {
    let analysisResponse;
    let analysisData;
    emitter_1.default.analyseProgress({
        status: http_1.AnalysisStatus.waiting,
        progress: 0,
    });
    // eslint-disable-next-line no-constant-condition
    while (true) {
        analysisResponse = await http_1.getAnalysis(options);
        if (analysisResponse.type === 'error') {
            return analysisResponse;
        }
        analysisData = analysisResponse.value;
        if (analysisData.status === http_1.AnalysisStatus.waiting ||
            analysisData.status === http_1.AnalysisStatus.fetching ||
            analysisData.status === http_1.AnalysisStatus.analyzing ||
            analysisData.status === http_1.AnalysisStatus.done) {
            // Report progress of fetching
            emitter_1.default.analyseProgress(analysisData);
        }
        else if (analysisData.status === http_1.AnalysisStatus.complete) {
            // Return data of analysis
            return analysisResponse;
            // deepcode ignore DuplicateIfBody: false positive it seems that interface is not taken into account
        }
        else if (analysisData.status === http_1.AnalysisStatus.failed) {
            // Report failure of analysing
            return analysisResponse;
        }
        await sleep(500);
    }
}
async function analyzeBundle(options) {
    // Call remote bundle for analysis results and emit intermediate progress
    const analysisData = await pollAnalysis(options);
    if (analysisData.type === 'error') {
        throw analysisData.error;
    }
    else if (analysisData.value.status === http_1.AnalysisStatus.failed) {
        throw new Error('Analysis has failed');
    }
    return analysisData.value;
}
exports.analyzeBundle = analyzeBundle;
async function analyzeFolders(options) {
    const fileBundle = await bundles_1.createBundleFromFolders({
        ...options.connection,
        ...options.fileOptions,
    });
    if (fileBundle === null)
        return null;
    // Analyze bundle
    const analysisResults = await analyzeBundle({
        bundleHash: fileBundle.bundleHash,
        ...options.connection,
        ...options.analysisOptions,
    });
    // TODO: expand relative file names to absolute ones
    // analysisResults.files = normalizeResultFiles(analysisData.analysisResults.files, baseDir);
    return { fileBundle, analysisResults, ...options };
}
exports.analyzeFolders = analyzeFolders;
function mergeBundleResults(oldAnalysisResults, newAnalysisResults, limitToFiles, removedFiles = []) {
    // Start from the new analysis results
    // For each finding of the old analysis,
    //  if it's location is not part of the limitToFiles or removedFiles (removedFiles should also be checked against condeFlow),
    //   append the finding to the new analysis and check if the rule must be added as well
    const changedFiles = [...limitToFiles, ...removedFiles];
    const sarifResults = (newAnalysisResults.sarif.runs[0].results || []).filter(res => {
        var _a, _b, _c;
        // TODO: This should not be necessary in theory but, in case of two identical files,
        // Bundle Server returns the finding in both files even if limitToFiles only reports one
        const loc = (_c = (_b = (_a = res.locations) === null || _a === void 0 ? void 0 : _a[0].physicalLocation) === null || _b === void 0 ? void 0 : _b.artifactLocation) === null || _c === void 0 ? void 0 : _c.uri;
        return loc && changedFiles.includes(loc);
    });
    const sarifRules = newAnalysisResults.sarif.runs[0].tool.driver.rules || [];
    const oldResults = oldAnalysisResults.sarif.runs[0].results || [];
    for (const res of oldResults) {
        // NOTE: Node 10 doesn't support the more readable .flatMap, so we need to use .reduce, but the behaviour would be the following:
        // const locations: string[] = (res.locations || []).flatMap(
        //   loc => !!loc.physicalLocation?.artifactLocation?.uri ? [loc.physicalLocation.artifactLocation.uri] : []
        // );
        // const codeFlowLocations: string[] = (res.codeFlows || []).flatMap(
        //   cf => (cf.threadFlows || []).flatMap(
        //     tf => (tf.locations || []).flatMap(
        //       loc => !!loc.location?.physicalLocation?.artifactLocation?.uri ? [loc.location.physicalLocation.artifactLocation.uri] : []
        //     )
        //   )
        // );
        const locations = (res.locations || []).reduce((acc, loc) => {
            var _a, _b;
            if ((_b = (_a = loc.physicalLocation) === null || _a === void 0 ? void 0 : _a.artifactLocation) === null || _b === void 0 ? void 0 : _b.uri) {
                acc.push(loc.physicalLocation.artifactLocation.uri);
            }
            return acc;
        }, []);
        const codeFlowLocations = (res.codeFlows || []).reduce((acc1, cf) => {
            acc1.push(...(cf.threadFlows || []).reduce((acc2, tf) => {
                acc2.push(...(tf.locations || []).reduce((acc3, loc) => {
                    var _a, _b, _c;
                    if ((_c = (_b = (_a = loc.location) === null || _a === void 0 ? void 0 : _a.physicalLocation) === null || _b === void 0 ? void 0 : _b.artifactLocation) === null || _c === void 0 ? void 0 : _c.uri) {
                        acc3.push(loc.location.physicalLocation.artifactLocation.uri);
                    }
                    return acc3;
                }, []));
                return acc2;
            }, []));
            return acc1;
        }, []);
        if (locations.some(loc => changedFiles.includes(loc)) || codeFlowLocations.some(loc => removedFiles.includes(loc)))
            continue;
        let ruleIndex = sarifRules.findIndex(rule => rule.id === res.ruleId);
        if (ruleIndex === -1 &&
            res.ruleIndex &&
            oldAnalysisResults.sarif.runs[0].tool.driver.rules &&
            oldAnalysisResults.sarif.runs[0].tool.driver.rules[res.ruleIndex]) {
            const newLength = sarifRules.push(oldAnalysisResults.sarif.runs[0].tool.driver.rules[res.ruleIndex]);
            ruleIndex = newLength - 1;
        }
        res.ruleIndex = ruleIndex;
        sarifResults.push(res);
    }
    newAnalysisResults.sarif.runs[0].results = sarifResults;
    newAnalysisResults.sarif.runs[0].tool.driver.rules = sarifRules;
    return newAnalysisResults;
}
async function extendAnalysis(options) {
    const { files, removedFiles } = await files_1.prepareExtendingBundle(options.fileBundle.baseDir, options.fileBundle.supportedFiles, options.fileBundle.fileIgnores, options.files, options.fileOptions.maxPayload, options.fileOptions.symlinksEnabled);
    if (!files.length && !removedFiles.length) {
        return null; // nothing to extend, just return null
    }
    // Extend remote bundle
    const remoteBundle = await bundles_1.remoteBundleFactory({
        ...options.connection,
        bundleHash: options.fileBundle.bundleHash,
        baseDir: options.fileBundle.baseDir,
        maxPayload: options.fileOptions.maxPayload,
        files,
        removedFiles,
    });
    if (remoteBundle === null)
        return null;
    const fileBundle = {
        ...options.fileBundle,
        ...remoteBundle,
    };
    const limitToFiles = files.map(f => f.bundlePath);
    let analysisResults = await analyzeBundle({
        bundleHash: remoteBundle.bundleHash,
        ...options.connection,
        ...options.analysisOptions,
        limitToFiles,
    });
    // TODO: Transform relative paths into absolute
    // analysisData.analysisResults.files = normalizeResultFiles(analysisData.analysisResults.files, bundle.baseDir);
    analysisResults = mergeBundleResults(options.analysisResults, analysisResults, limitToFiles, removedFiles);
    return { ...options, fileBundle, analysisResults };
}
exports.extendAnalysis = extendAnalysis;
//# sourceMappingURL=analysis.js.map