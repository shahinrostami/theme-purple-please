import { Cache } from './cache';
import { SupportedFiles, FileInfo } from './interfaces/files.interface';
export declare function notEmpty<T>(value: T | null | undefined): value is T;
export declare function parseFileIgnores(path: string): string[];
export declare function getGlobPatterns(supportedFiles: SupportedFiles): string[];
export declare function collectIgnoreRules(dirs: string[], symlinksEnabled?: boolean, fileIgnores?: string[]): Promise<string[]>;
export declare function determineBaseDir(paths: string[]): string;
export interface AnalyzeFoldersOptions {
    paths: string[];
    symlinksEnabled?: boolean;
    maxPayload?: number;
    defaultFileIgnores?: string[];
}
export interface CollectBundleFilesOptions extends AnalyzeFoldersOptions {
    supportedFiles: SupportedFiles;
    baseDir: string;
    fileIgnores: string[];
}
/**
 * Returns bundle files from requested paths
 * */
export declare function collectBundleFiles({ maxPayload, symlinksEnabled, ...options }: CollectBundleFilesOptions): AsyncGenerator<FileInfo>;
export declare function prepareExtendingBundle(baseDir: string, supportedFiles: SupportedFiles, fileIgnores: string[] | undefined, files: string[], maxFileSize?: number, symlinksEnabled?: boolean): Promise<{
    files: FileInfo[];
    removedFiles: string[];
}>;
export declare function getFileInfo(filePath: string, baseDir: string, withContent?: boolean, cache?: Cache | null): Promise<FileInfo | null>;
export declare function resolveBundleFiles(baseDir: string, bundleMissingFiles: string[]): Promise<FileInfo[]>;
export declare function resolveBundleFilePath(baseDir: string, bundleFilePath: string): string;
export declare function composeFilePayloads(files: FileInfo[], bucketSize?: number): Generator<FileInfo[]>;
export declare function isMatch(filePath: string, rules: string[]): boolean;
