"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAnalysis = exports.AnalysisStatus = exports.extendBundle = exports.checkBundle = exports.createBundle = exports.getFilters = exports.checkSession = exports.getIpFamily = exports.startSession = exports.determineErrorCode = void 0;
const uuid_1 = require("uuid");
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const constants_1 = require("./constants");
const needle_1 = require("./needle");
function determineErrorCode(error) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const { response } = error;
    if (response) {
        return response.statusCode;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const { errno, code } = error;
    if (errno === 'ECONNREFUSED') {
        // set connectionRefused item
        return constants_1.ErrorCodes.connectionRefused;
    }
    if (errno === 'ECONNRESET') {
        // set connectionRefused item
        return constants_1.ErrorCodes.connectionRefused;
    }
    if (code === 'ENOTFOUND') {
        return constants_1.ErrorCodes.dnsNotFound;
    }
    // We must be strict here and if none of our existing logic recognized this error, just throw it up.
    throw error;
}
exports.determineErrorCode = determineErrorCode;
// The trick to typecast union type alias
function isSubsetErrorCode(code, messages) {
    if (code in messages) {
        return true;
    }
    return false;
}
function generateError(error, messages, apiName) {
    const errorCode = determineErrorCode(error);
    if (!isSubsetErrorCode(errorCode, messages)) {
        throw error;
    }
    const statusCode = errorCode;
    const statusText = messages[errorCode];
    return {
        type: 'error',
        error: {
            apiName,
            statusCode,
            statusText,
        },
    };
}
const GENERIC_ERROR_MESSAGES = {
    [constants_1.ErrorCodes.serverError]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.serverError],
    [constants_1.ErrorCodes.badGateway]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.badGateway],
    [constants_1.ErrorCodes.serviceUnavailable]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.serviceUnavailable],
    [constants_1.ErrorCodes.timeout]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.timeout],
    [constants_1.ErrorCodes.dnsNotFound]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.dnsNotFound],
    [constants_1.ErrorCodes.connectionRefused]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.connectionRefused],
};
function startSession(options) {
    const { source, authHost } = options;
    const draftToken = uuid_1.v4();
    return {
        draftToken,
        loginURL: `${authHost}/login?token=${draftToken}&utm_medium=${source}&utm_source=${source}&utm_campaign=${source}&docker=false`,
    };
}
exports.startSession = startSession;
/**
 * Dispatches a FORCED IPv6 request to test client's ISP and network capability.
 *
 * @return {number} IP family number used by the client.
 */
async function getIpFamily(authHost) {
    const family = 6;
    try {
        // Dispatch a FORCED IPv6 request to test client's ISP and network capability
        await needle_1.makeRequest({
            url: `${authHost}/verify/callback`,
            method: 'post',
            family, // family param forces the handler to dispatch a request using IP at "family" version
        });
        return family;
    }
    catch (e) {
        return undefined;
    }
}
exports.getIpFamily = getIpFamily;
const CHECK_SESSION_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.loginInProgress]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.loginInProgress],
};
async function checkSession(options) {
    var _a;
    const defaultValue = {
        type: 'success',
        value: '',
    };
    try {
        const { success, response } = await needle_1.makeRequest({
            url: `${options.authHost}/api/v1/verify/callback`,
            body: {
                token: options.draftToken,
            },
            family: options.ipFamily,
            method: 'post',
        });
        if (success) {
            const responseBody = response.body;
            defaultValue.value = (responseBody.ok && responseBody.api) || '';
        }
        return defaultValue;
    }
    catch (err) {
        if ([constants_1.ErrorCodes.loginInProgress, constants_1.ErrorCodes.badRequest, constants_1.ErrorCodes.unauthorizedUser].includes(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        (_a = err.response) === null || _a === void 0 ? void 0 : _a.status)) {
            return defaultValue;
        }
        return generateError(err, CHECK_SESSION_ERROR_MESSAGES, 'checkSession');
    }
}
exports.checkSession = checkSession;
async function getFilters(baseURL, source) {
    const apiName = 'filters';
    try {
        const { success, response } = await needle_1.makeRequest({
            headers: { source },
            url: `${baseURL}/${apiName}`,
            method: 'get',
        });
        if (success) {
            const responseBody = response.body;
            return { type: 'success', value: responseBody };
        }
        return generateError({ response }, GENERIC_ERROR_MESSAGES, apiName);
    }
    catch (error) {
        return generateError(error, GENERIC_ERROR_MESSAGES, 'filters');
    }
}
exports.getFilters = getFilters;
function prepareTokenHeaders(sessionToken) {
    return {
        'Session-Token': sessionToken,
        // We need to be able to test code-client without deepcode locally
        Authorization: `Bearer ${sessionToken}`,
    };
}
const CREATE_BUNDLE_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedBundleAccess],
    [constants_1.ErrorCodes.bigPayload]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.bigPayload],
    [constants_1.ErrorCodes.badRequest]: `Request payload doesn't match the specifications`,
    [constants_1.ErrorCodes.notFound]: 'Unable to resolve requested oid',
};
async function createBundle(options) {
    try {
        const payload = {
            headers: {
                ...prepareTokenHeaders(options.sessionToken),
                source: options.source,
            },
            url: `${options.baseURL}/bundle`,
            method: 'post',
            body: options.files,
        };
        const { response, success } = await needle_1.makeRequest(payload);
        if (success) {
            return { type: 'success', value: response.body };
        }
        return generateError({ response }, CREATE_BUNDLE_ERROR_MESSAGES, 'createBundle');
    }
    catch (error) {
        return generateError(error, CREATE_BUNDLE_ERROR_MESSAGES, 'createBundle');
    }
}
exports.createBundle = createBundle;
const CHECK_BUNDLE_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedBundleAccess],
    [constants_1.ErrorCodes.notFound]: 'Uploaded bundle has expired',
};
async function checkBundle(options) {
    try {
        const { response, success } = await needle_1.makeRequest({
            headers: {
                ...prepareTokenHeaders(options.sessionToken),
                source: options.source,
            },
            url: `${options.baseURL}/bundle/${options.bundleHash}`,
            method: 'get',
        });
        if (success)
            return { type: 'success', value: response.body };
        return generateError({ response }, CHECK_BUNDLE_ERROR_MESSAGES, 'checkBundle');
    }
    catch (error) {
        return generateError(error, CHECK_BUNDLE_ERROR_MESSAGES, 'checkBundle');
    }
}
exports.checkBundle = checkBundle;
const EXTEND_BUNDLE_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.bigPayload]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.bigPayload],
    [constants_1.ErrorCodes.badRequest]: `Bad request`,
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: 'Unauthorized access to parent bundle',
    [constants_1.ErrorCodes.notFound]: 'Parent bundle has expired',
};
async function extendBundle(options) {
    try {
        const { response, success } = await needle_1.makeRequest({
            headers: {
                ...prepareTokenHeaders(options.sessionToken),
                source: options.source,
            },
            url: `${options.baseURL}/bundle/${options.bundleHash}`,
            method: 'put',
            body: lodash_pick_1.default(options, ['files', 'removedFiles']),
        });
        if (success)
            return { type: 'success', value: response.body };
        return generateError({ response }, EXTEND_BUNDLE_ERROR_MESSAGES, 'extendBundle');
    }
    catch (error) {
        return generateError(error, EXTEND_BUNDLE_ERROR_MESSAGES, 'extendBundle');
    }
}
exports.extendBundle = extendBundle;
// eslint-disable-next-line no-shadow
var AnalysisStatus;
(function (AnalysisStatus) {
    AnalysisStatus["waiting"] = "WAITING";
    AnalysisStatus["fetching"] = "FETCHING";
    AnalysisStatus["analyzing"] = "ANALYZING";
    AnalysisStatus["done"] = "DONE";
    AnalysisStatus["failed"] = "FAILED";
    AnalysisStatus["complete"] = "COMPLETE";
})(AnalysisStatus = exports.AnalysisStatus || (exports.AnalysisStatus = {}));
const GET_ANALYSIS_ERROR_MESSAGES = {
    ...GENERIC_ERROR_MESSAGES,
    [constants_1.ErrorCodes.unauthorizedUser]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedUser],
    [constants_1.ErrorCodes.unauthorizedBundleAccess]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.unauthorizedBundleAccess],
    [constants_1.ErrorCodes.notFound]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.notFound],
    [constants_1.ErrorCodes.badRequest]: constants_1.DEFAULT_ERROR_MESSAGES[constants_1.ErrorCodes.badRequest],
    [constants_1.ErrorCodes.serverError]: 'Getting analysis failed',
};
async function getAnalysis(options) {
    const config = {
        headers: {
            ...prepareTokenHeaders(options.sessionToken),
            source: options.source,
        },
        url: `${options.baseURL}/analysis`,
        method: 'post',
        body: {
            key: {
                type: 'file',
                hash: options.bundleHash,
                limitToFiles: options.limitToFiles || [],
            },
            ...lodash_pick_1.default(options, ['severity', 'prioritized']),
            // severity: options.severity || AnalysisSeverity.info,
        },
    };
    try {
        const { response, success } = await needle_1.makeRequest(config);
        if (success)
            return { type: 'success', value: response.body };
        return generateError({ response }, GET_ANALYSIS_ERROR_MESSAGES, 'getAnalysis');
    }
    catch (error) {
        return generateError(error, GET_ANALYSIS_ERROR_MESSAGES, 'getAnalysis');
    }
}
exports.getAnalysis = getAnalysis;
//# sourceMappingURL=http.js.map