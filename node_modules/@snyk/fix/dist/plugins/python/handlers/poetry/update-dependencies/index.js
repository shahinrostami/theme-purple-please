"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUpgrades = exports.generateSuccessfulChanges = exports.updateDependencies = void 0;
const pathLib = require("path");
const toml = require("toml");
const debugLib = require("debug");
const poetryFix = require("@snyk/fix-poetry");
const no_fixes_applied_1 = require("../../../../../lib/errors/no-fixes-applied");
const command_failed_to_run_error_1 = require("../../../../../lib/errors/command-failed-to-run-error");
const validate_required_data_1 = require("../../validate-required-data");
const standardize_package_name_1 = require("../../../standardize-package-name");
const debug = debugLib('snyk-fix:python:Poetry');
async function updateDependencies(entity, options) {
    var _a, _b;
    const handlerResult = {
        succeeded: [],
        failed: [],
        skipped: [],
    };
    let poetryCommand;
    try {
        const { upgrades, devUpgrades } = await generateUpgrades(entity);
        const { remediation, targetFile } = validate_required_data_1.validateRequiredData(entity);
        const targetFilePath = pathLib.resolve(entity.workspace.path, targetFile);
        const { dir } = pathLib.parse(targetFilePath);
        // TODO: for better support we need to:
        // 1. parse the manifest and extract original requirements, version spec etc
        // 2. swap out only the version and retain original spec
        // 3. re-lock the lockfile
        // update prod dependencies first
        if (!options.dryRun && upgrades.length) {
            const res = await poetryFix.poetryAdd(dir, upgrades, {
                python: (_a = entity.options.command) !== null && _a !== void 0 ? _a : undefined,
            });
            if (res.exitCode !== 0) {
                poetryCommand = res.command;
                throwPoetryError(res.stderr ? res.stderr : res.stdout, res.command);
            }
        }
        // update dev dependencies second
        if (!options.dryRun && devUpgrades.length) {
            const res = await poetryFix.poetryAdd(dir, devUpgrades, {
                dev: true,
                python: (_b = entity.options.command) !== null && _b !== void 0 ? _b : undefined,
            });
            if (res.exitCode !== 0) {
                poetryCommand = res.command;
                throwPoetryError(res.stderr ? res.stderr : res.stdout, res.command);
            }
        }
        const changes = generateSuccessfulChanges(remediation.pin);
        handlerResult.succeeded.push({ original: entity, changes });
    }
    catch (error) {
        debug(`Failed to fix ${entity.scanResult.identity.targetFile}.\nERROR: ${error}`);
        handlerResult.failed.push({
            original: entity,
            error,
            tip: poetryCommand ? `Try running \`${poetryCommand}\`` : undefined,
        });
    }
    return handlerResult;
}
exports.updateDependencies = updateDependencies;
function generateSuccessfulChanges(pins) {
    const changes = [];
    for (const pkgAtVersion of Object.keys(pins)) {
        const pin = pins[pkgAtVersion];
        const updatedMessage = pin.isTransitive ? 'Pinned' : 'Upgraded';
        const newVersion = pin.upgradeTo.split('@')[1];
        const [pkgName, version] = pkgAtVersion.split('@');
        changes.push({
            success: true,
            userMessage: `${updatedMessage} ${pkgName} from ${version} to ${newVersion}`,
            issueIds: pin.vulns,
            from: pkgAtVersion,
            to: `${pkgName}@${newVersion}`,
        });
    }
    return changes;
}
exports.generateSuccessfulChanges = generateSuccessfulChanges;
async function generateUpgrades(entity) {
    var _a, _b;
    const { remediation, targetFile } = validate_required_data_1.validateRequiredData(entity);
    const pins = remediation.pin;
    const targetFilePath = pathLib.resolve(entity.workspace.path, targetFile);
    const { dir } = pathLib.parse(targetFilePath);
    const pyProjectTomlRaw = await entity.workspace.readFile(pathLib.resolve(dir, 'pyproject.toml'));
    const pyProjectToml = toml.parse(pyProjectTomlRaw);
    const prodTopLevelDeps = Object.keys((_a = pyProjectToml.tool.poetry.dependencies) !== null && _a !== void 0 ? _a : {});
    const devTopLevelDeps = Object.keys((_b = pyProjectToml.tool.poetry['dev-dependencies']) !== null && _b !== void 0 ? _b : {});
    const upgrades = [];
    const devUpgrades = [];
    for (const pkgAtVersion of Object.keys(pins)) {
        const pin = pins[pkgAtVersion];
        const newVersion = pin.upgradeTo.split('@')[1];
        const [pkgName] = pkgAtVersion.split('@');
        const upgrade = `${standardize_package_name_1.standardizePackageName(pkgName)}==${newVersion}`;
        if (pin.isTransitive) {
            // transitive and it could have come from a dev or prod dep
            // since we can't tell right now let be pinned into production deps
            upgrades.push(upgrade);
        }
        else if (prodTopLevelDeps.includes(pkgName)) {
            upgrades.push(upgrade);
        }
        else if (entity.options.dev && devTopLevelDeps.includes(pkgName)) {
            devUpgrades.push(upgrade);
        }
        else {
            debug(`Could not determine what type of upgrade ${upgrade} is. When choosing between: transitive upgrade, production or dev direct upgrade. `);
        }
    }
    return { upgrades, devUpgrades };
}
exports.generateUpgrades = generateUpgrades;
function throwPoetryError(stderr, command) {
    const ALREADY_UP_TO_DATE = 'No dependencies to install or update';
    const INCOMPATIBLE_PYTHON = new RegExp(/Python requirement (.*) is not compatible/g, 'gm');
    const match = INCOMPATIBLE_PYTHON.exec(stderr);
    if (match) {
        throw new command_failed_to_run_error_1.CommandFailedError(`The current project's Python requirement ${match[1]} is not compatible with some of the required packages`, command);
    }
    // TODO: test this
    if (stderr.includes(ALREADY_UP_TO_DATE)) {
        throw new command_failed_to_run_error_1.CommandFailedError('No dependencies could be updated as they seem to be at the correct versions. Make sure installed dependencies in the environment match those in the lockfile by running `poetry update`', command);
    }
    throw new no_fixes_applied_1.NoFixesCouldBeAppliedError();
}
//# sourceMappingURL=index.js.map