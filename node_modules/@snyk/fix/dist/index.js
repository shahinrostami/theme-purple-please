"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractMeta = exports.groupEntitiesPerScanType = exports.fix = void 0;
const debugLib = require("debug");
const pMap = require("p-map");
const ora = require("ora");
const chalk = require("chalk");
const outputFormatter = require("./lib/output-formatters/show-results-summary");
const load_plugin_1 = require("./plugins/load-plugin");
const partition_by_vulnerable_1 = require("./partition-by-vulnerable");
const error_to_user_message_1 = require("./lib/errors/error-to-user-message");
const total_issues_count_1 = require("./lib/issues/total-issues-count");
const fixable_issues_1 = require("./lib/issues/fixable-issues");
const debug = debugLib('snyk-fix:main');
async function fix(entities, options = {
    dryRun: false,
    quiet: false,
    stripAnsi: false,
}) {
    const spinner = ora({ isSilent: options.quiet, stream: process.stdout });
    let resultsByPlugin = {};
    const { vulnerable, notVulnerable: nothingToFix, } = await partition_by_vulnerable_1.partitionByVulnerable(entities);
    const entitiesPerType = groupEntitiesPerScanType(vulnerable);
    const exceptions = {};
    await pMap(Object.keys(entitiesPerType), async (scanType) => {
        try {
            const fixPlugin = load_plugin_1.loadPlugin(scanType);
            const results = await fixPlugin(entitiesPerType[scanType], options);
            resultsByPlugin = Object.assign(Object.assign({}, resultsByPlugin), results);
        }
        catch (e) {
            debug(`Failed to processes ${scanType}`, e);
            exceptions[scanType] = {
                originals: entitiesPerType[scanType],
                userMessage: error_to_user_message_1.convertErrorToUserMessage(e),
            };
        }
    }, {
        concurrency: 3,
    });
    const fixSummary = await outputFormatter.showResultsSummary(nothingToFix, resultsByPlugin, exceptions, options, entities.length);
    const meta = extractMeta(resultsByPlugin, exceptions);
    spinner.start();
    if (meta.fixed > 0) {
        spinner.stopAndPersist({
            text: 'Done',
            symbol: chalk.green('âœ”'),
        });
    }
    else {
        spinner.stop();
    }
    return {
        results: resultsByPlugin,
        exceptions,
        fixSummary,
        meta,
    };
}
exports.fix = fix;
function groupEntitiesPerScanType(entities) {
    var _a, _b, _c;
    const entitiesPerType = {};
    for (const entity of entities) {
        // TODO: group all node
        const type = (_c = (_b = (_a = entity.scanResult) === null || _a === void 0 ? void 0 : _a.identity) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : 'missing-type';
        if (entitiesPerType[type]) {
            entitiesPerType[type].push(entity);
            continue;
        }
        entitiesPerType[type] = [entity];
    }
    return entitiesPerType;
}
exports.groupEntitiesPerScanType = groupEntitiesPerScanType;
function extractMeta(resultsByPlugin, exceptions) {
    const testResults = outputFormatter.getTestResults(resultsByPlugin, exceptions);
    const issueData = testResults.map((i) => i.issuesData);
    const failed = outputFormatter.calculateFailed(resultsByPlugin, exceptions);
    const fixed = outputFormatter.calculateFixed(resultsByPlugin);
    const totalIssueCount = total_issues_count_1.getTotalIssueCount(issueData);
    const { count: fixableCount } = fixable_issues_1.hasFixableIssues(testResults);
    const fixedIssueCount = outputFormatter.calculateFixedIssues(resultsByPlugin);
    return {
        fixed,
        failed,
        totalIssues: totalIssueCount,
        fixableIssues: fixableCount,
        fixedIssues: fixedIssueCount,
    };
}
exports.extractMeta = extractMeta;
//# sourceMappingURL=index.js.map