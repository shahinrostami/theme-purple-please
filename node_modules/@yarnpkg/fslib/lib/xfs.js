"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xfs = void 0;
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const NodeFS_1 = require("./NodeFS");
const path_1 = require("./path");
function getTempName(prefix) {
    const tmpdir = path_1.npath.toPortablePath(os_1.default.tmpdir());
    const hash = Math.ceil(Math.random() * 0x100000000).toString(16).padStart(8, `0`);
    return path_1.ppath.join(tmpdir, `${prefix}${hash}`);
}
const tmpdirs = new Set();
let cleanExitRegistered = false;
function registerCleanExit() {
    if (cleanExitRegistered)
        return;
    cleanExitRegistered = true;
    process.once(`exit`, () => {
        exports.xfs.rmtempSync();
    });
}
exports.xfs = Object.assign(new NodeFS_1.NodeFS(), {
    detachTemp(p) {
        tmpdirs.delete(p);
    },
    mktempSync(cb) {
        registerCleanExit();
        while (true) {
            const p = getTempName(`xfs-`);
            try {
                this.mkdirSync(p);
            }
            catch (error) {
                if (error.code === `EEXIST`) {
                    continue;
                }
                else {
                    throw error;
                }
            }
            const realP = this.realpathSync(p);
            tmpdirs.add(realP);
            if (typeof cb !== `undefined`) {
                try {
                    return cb(realP);
                }
                finally {
                    if (tmpdirs.has(realP)) {
                        tmpdirs.delete(realP);
                        try {
                            this.removeSync(realP);
                        }
                        catch (_a) {
                            // Too bad if there's an error
                        }
                    }
                }
            }
            else {
                return realP;
            }
        }
    },
    async mktempPromise(cb) {
        registerCleanExit();
        while (true) {
            const p = getTempName(`xfs-`);
            try {
                await this.mkdirPromise(p);
            }
            catch (error) {
                if (error.code === `EEXIST`) {
                    continue;
                }
                else {
                    throw error;
                }
            }
            const realP = await this.realpathPromise(p);
            tmpdirs.add(realP);
            if (typeof cb !== `undefined`) {
                try {
                    return await cb(realP);
                }
                finally {
                    if (tmpdirs.has(realP)) {
                        tmpdirs.delete(realP);
                        try {
                            await this.removePromise(realP);
                        }
                        catch (_a) {
                            // Too bad if there's an error
                        }
                    }
                }
            }
            else {
                return realP;
            }
        }
    },
    async rmtempPromise() {
        await Promise.all(Array.from(tmpdirs.values()).map(async (p) => {
            try {
                await exports.xfs.removePromise(p, { maxRetries: 0 });
                tmpdirs.delete(p);
            }
            catch (_a) {
                // Too bad if there's an error
            }
        }));
    },
    rmtempSync() {
        for (const p of tmpdirs) {
            try {
                exports.xfs.removeSync(p);
                tmpdirs.delete(p);
            }
            catch (_a) {
                // Too bad if there's an error
            }
        }
    },
});
