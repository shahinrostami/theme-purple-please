"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NoFS_1 = require("./NoFS");
const ProxiedFS_1 = require("./ProxiedFS");
const path_1 = require("./path");
describe(`ProxiedFS`, () => {
    it(`should resolve relative symlinks after remapping`, async () => {
        class SpyFS extends NoFS_1.NoFS {
            constructor() {
                super(...arguments);
                // @ts-expect-error
                this.symlinkPromise = jest.fn(async () => { });
                // @ts-expect-error
                this.symlinkSync = jest.fn(() => { });
            }
        }
        class TestFS extends ProxiedFS_1.ProxiedFS {
            constructor(baseFs) {
                super(path_1.ppath);
                this.baseFs = baseFs;
                this.mapToBase = jest.fn(p => p);
                this.mapFromBase = jest.fn(p => p);
            }
        }
        {
            const spyFs = new SpyFS();
            const testFs = new TestFS(spyFs);
            const basePath = `/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z`;
            const linkPath = basePath.split(`/`).slice(2, -1).map(() => `..`).join(`/`);
            testFs.symlinkSync(linkPath, basePath);
            expect(testFs.mapToBase).toHaveBeenCalledWith(basePath);
            expect(testFs.mapToBase).toHaveBeenCalledWith(`/a`);
            expect(spyFs.symlinkSync).toHaveBeenCalledWith(linkPath, basePath, undefined);
        }
        {
            const spyFs = new SpyFS();
            const testFs = new TestFS(spyFs);
            const basePath = `/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z`;
            const linkPath = basePath.split(`/`).slice(2, -1).map(() => `..`).join(`/`);
            await testFs.symlinkPromise(linkPath, basePath);
            expect(testFs.mapToBase).toHaveBeenCalledWith(basePath);
            expect(testFs.mapToBase).toHaveBeenCalledWith(`/a`);
            expect(spyFs.symlinkPromise).toHaveBeenCalledWith(linkPath, basePath, undefined);
        }
    });
});
