{"version":3,"file":"yjs.mjs","sources":["../src/utils/AbstractConnector.js","../src/utils/DeleteSet.js","../src/utils/Doc.js","../src/utils/UpdateDecoder.js","../src/utils/UpdateEncoder.js","../src/utils/encoding.js","../src/utils/EventHandler.js","../src/utils/ID.js","../src/utils/isParentOf.js","../src/utils/logging.js","../src/utils/PermanentUserData.js","../src/utils/RelativePosition.js","../src/utils/Snapshot.js","../src/utils/StructStore.js","../src/utils/Transaction.js","../src/utils/UndoManager.js","../src/utils/updates.js","../src/utils/YEvent.js","../src/types/AbstractType.js","../src/types/YArray.js","../src/types/YMap.js","../src/types/YText.js","../src/types/YXmlFragment.js","../src/types/YXmlElement.js","../src/types/YXmlEvent.js","../src/types/YXmlHook.js","../src/types/YXmlText.js","../src/structs/AbstractStruct.js","../src/structs/GC.js","../src/structs/ContentBinary.js","../src/structs/ContentDeleted.js","../src/structs/ContentDoc.js","../src/structs/ContentEmbed.js","../src/structs/ContentFormat.js","../src/structs/ContentJSON.js","../src/structs/ContentAny.js","../src/structs/ContentString.js","../src/structs/ContentType.js","../src/structs/Item.js","../src/structs/Skip.js"],"sourcesContent":["\nimport { Observable } from 'lib0/observable'\n\nimport {\n  Doc // eslint-disable-line\n} from '../internals.js'\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */\nexport class AbstractConnector extends Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super()\n    this.doc = ydoc\n    this.awareness = awareness\n  }\n}\n","\nimport {\n  findIndexSS,\n  getState,\n  splitItem,\n  iterateStructs,\n  UpdateEncoderV2,\n  DSDecoderV1, DSEncoderV1, DSDecoderV2, DSEncoderV2, Item, GC, StructStore, Transaction, ID // eslint-disable-line\n} from '../internals.js'\n\nimport * as array from 'lib0/array'\nimport * as math from 'lib0/math'\nimport * as map from 'lib0/map'\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\n\nexport class DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock\n    /**\n     * @type {number}\n     */\n    this.len = len\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nexport class DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map()\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nexport const iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid))\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i]\n      iterateStructs(transaction, structs, del.clock, del.len, f)\n    }\n  })\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nexport const findIndexDS = (dis, clock) => {\n  let left = 0\n  let right = dis.length - 1\n  while (left <= right) {\n    const midindex = math.floor((left + right) / 2)\n    const mid = dis[midindex]\n    const midclock = mid.clock\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1\n    } else {\n      right = midindex - 1\n    }\n  }\n  return null\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nexport const isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client)\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n}\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nexport const sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock)\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1]\n      const right = dels[i]\n      if (left.clock + left.len >= right.clock) {\n        left.len = math.max(left.len, right.clock + right.len - left.clock)\n      } else {\n        if (j < i) {\n          dels[j] = right\n        }\n        j++\n      }\n    }\n    dels.length = j\n  })\n}\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nexport const mergeDeleteSets = dss => {\n  const merged = new DeleteSet()\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice()\n        for (let i = dssI + 1; i < dss.length; i++) {\n          array.appendTo(dels, dss[i].clients.get(client) || [])\n        }\n        merged.clients.set(client, dels)\n      }\n    })\n  }\n  sortAndMergeDeleteSet(merged)\n  return merged\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nexport const addToDeleteSet = (ds, client, clock, length) => {\n  map.setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock, length))\n}\n\nexport const createDeleteSet = () => new DeleteSet()\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nexport const createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet()\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = []\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i]\n      if (struct.deleted) {\n        const clock = struct.id.clock\n        let len = struct.length\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n            len += next.length\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len))\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems)\n    }\n  })\n  return ds\n}\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nexport const writeDeleteSet = (encoder, ds) => {\n  encoding.writeVarUint(encoder.restEncoder, ds.clients.size)\n  ds.clients.forEach((dsitems, client) => {\n    encoder.resetDsCurVal()\n    encoding.writeVarUint(encoder.restEncoder, client)\n    const len = dsitems.length\n    encoding.writeVarUint(encoder.restEncoder, len)\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i]\n      encoder.writeDsClock(item.clock)\n      encoder.writeDsLen(item.len)\n    }\n  })\n}\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nexport const readDeleteSet = decoder => {\n  const ds = new DeleteSet()\n  const numClients = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal()\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder)\n    if (numberOfDeletes > 0) {\n      const dsField = map.setIfUndefined(ds.clients, client, () => [])\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()))\n      }\n    }\n  }\n  return ds\n}\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nexport const readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet()\n  const numClients = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal()\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder)\n    const structs = store.clients.get(client) || []\n    const state = getState(store, client)\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock()\n      const clockEnd = clock + decoder.readDsLen()\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state)\n        }\n        let index = findIndexSS(structs, clock)\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index]\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock))\n          index++ // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++]\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock))\n              }\n              struct.delete(transaction)\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock)\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2()\n    encoding.writeVarUint(ds.restEncoder, 0) // encode 0 structs\n    writeDeleteSet(ds, unappliedDS)\n    return ds.toUint8Array()\n  }\n  return null\n}\n","/**\n * @module Y\n */\n\nimport {\n  StructStore,\n  AbstractType,\n  YArray,\n  YText,\n  YMap,\n  YXmlFragment,\n  transact,\n  ContentDoc, Item, Transaction, YEvent // eslint-disable-line\n} from '../internals.js'\n\nimport { Observable } from 'lib0/observable'\nimport * as random from 'lib0/random'\nimport * as map from 'lib0/map'\nimport * as array from 'lib0/array'\n\nexport const generateNewClientId = random.uint32\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nexport class Doc extends Observable {\n  /**\n   * @param {DocOpts} [opts] configuration\n   */\n  constructor ({ guid = random.uuidv4(), gc = true, gcFilter = () => true, meta = null, autoLoad = false } = {}) {\n    super()\n    this.gc = gc\n    this.gcFilter = gcFilter\n    this.clientID = generateNewClientId()\n    this.guid = guid\n    /**\n     * @type {Map<string, AbstractType<YEvent>>}\n     */\n    this.share = new Map()\n    this.store = new StructStore()\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = []\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set()\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null\n    this.shouldLoad = autoLoad\n    this.autoLoad = autoLoad\n    this.meta = meta\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this)\n      }, null, true)\n    }\n    this.shouldLoad = true\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(Array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @param {function(Transaction):void} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    transact(this, f, origin)\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = map.setIfUndefined(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor()\n      t._integrate(this, null)\n      return t\n    })\n    const Constr = type.constructor\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor()\n        t._map = type._map\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t\n          }\n        })\n        t._start = type._start\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t\n        }\n        t._length = type._length\n        this.share.set(name, t)\n        t._integrate(this, null)\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YMap<any>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {}\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON()\n    })\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    array.from(this.subdocs).forEach(subdoc => subdoc.destroy())\n    const item = this._item\n    if (item !== null) {\n      this._item = null\n      const content = /** @type {ContentDoc} */ (item.content)\n      if (item.deleted) {\n        // @ts-ignore\n        content.doc = null\n      } else {\n        content.doc = new Doc({ guid: this.guid, ...content.opts })\n        content.doc._item = item\n      }\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(content.doc)\n        }\n        transaction.subdocsRemoved.add(this)\n      }, null, true)\n    }\n    this.emit('destroyed', [true])\n    this.emit('destroy', [this])\n    super.destroy()\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f)\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f)\n  }\n}\n","import * as buffer from 'lib0/buffer'\nimport * as decoding from 'lib0/decoding'\nimport {\n  ID, createID\n} from '../internals.js'\n\nexport class DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n}\n\nexport class UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return decoding.readUint8(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return decoding.readVarString(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return decoding.readVarUint(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return buffer.copyUint8Array(decoding.readVarUint8Array(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse(decoding.readVarString(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return decoding.readVarString(this.restDecoder)\n  }\n}\n\nexport class DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0\n    this.restDecoder = decoder\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += decoding.readVarUint(this.restDecoder)\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = decoding.readVarUint(this.restDecoder) + 1\n    this.dsCurrVal += diff\n    return diff\n  }\n}\n\nexport class UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder)\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = []\n    decoding.readVarUint(decoder) // read feature flag - currently unused\n    this.keyClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.clientDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.leftClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.rightClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.infoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8)\n    this.stringDecoder = new decoding.StringDecoder(decoding.readVarUint8Array(decoder))\n    this.parentInfoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8)\n    this.typeRefDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.lenDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return decoding.readVarUint8Array(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read()\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read()\n      this.keys.push(key)\n      return key\n    }\n  }\n}\n","\nimport * as error from 'lib0/error'\nimport * as encoding from 'lib0/encoding'\n\nimport {\n  ID // eslint-disable-line\n} from '../internals.js'\n\nexport class DSEncoderV1 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder()\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    encoding.writeVarUint(this.restEncoder, clock)\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    encoding.writeVarUint(this.restEncoder, len)\n  }\n}\n\nexport class UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client)\n    encoding.writeVarUint(this.restEncoder, id.clock)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client)\n    encoding.writeVarUint(this.restEncoder, id.clock)\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    encoding.writeVarUint(this.restEncoder, client)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    encoding.writeUint8(this.restEncoder, info)\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    encoding.writeVarString(this.restEncoder, s)\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    encoding.writeVarUint(this.restEncoder, info)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    encoding.writeVarUint(this.restEncoder, len)\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any)\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf)\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeVarString(this.restEncoder, JSON.stringify(embed))\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    encoding.writeVarString(this.restEncoder, key)\n  }\n}\n\nexport class DSEncoderV2 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder() // encodes all the rest / non-optimized\n    this.dsCurrVal = 0\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal\n    this.dsCurrVal = clock\n    encoding.writeVarUint(this.restEncoder, diff)\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      error.unexpectedCase()\n    }\n    encoding.writeVarUint(this.restEncoder, len - 1)\n    this.dsCurrVal += len\n  }\n}\n\nexport class UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super()\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map()\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0\n    this.keyClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.clientEncoder = new encoding.UintOptRleEncoder()\n    this.leftClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.rightClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.infoEncoder = new encoding.RleEncoder(encoding.writeUint8)\n    this.stringEncoder = new encoding.StringEncoder()\n    this.parentInfoEncoder = new encoding.RleEncoder(encoding.writeUint8)\n    this.typeRefEncoder = new encoding.UintOptRleEncoder()\n    this.lenEncoder = new encoding.UintOptRleEncoder()\n  }\n\n  toUint8Array () {\n    const encoder = encoding.createEncoder()\n    encoding.writeVarUint(encoder, 0) // this is a feature flag that we might use in the future\n    encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.infoEncoder))\n    encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.parentInfoEncoder))\n    encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array())\n    // @note The rest encoder is appended! (note the missing var)\n    encoding.writeUint8Array(encoder, encoding.toUint8Array(this.restEncoder))\n    return encoding.toUint8Array(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client)\n    this.leftClockEncoder.write(id.clock)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client)\n    this.rightClockEncoder.write(id.clock)\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info)\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s)\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len)\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any)\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeAny(this.restEncoder, embed)\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key)\n    if (clock === undefined) {\n      this.keyClockEncoder.write(this.keyClock++)\n      this.stringEncoder.write(key)\n    } else {\n      this.keyClockEncoder.write(this.keyClock++)\n    }\n  }\n}\n","\n/**\n * @module encoding\n */\n/*\n * We use the first five bits in the info flag for determining the type of the struct.\n *\n * 0: GC\n * 1: Item with Deleted content\n * 2: Item with JSON content\n * 3: Item with Binary content\n * 4: Item with String content\n * 5: Item with Embed content (for richtext content)\n * 6: Item with Format content (a formatting marker for richtext content)\n * 7: Item with Type\n */\n\nimport {\n  findIndexSS,\n  getState,\n  createID,\n  getStateVector,\n  readAndApplyDeleteSet,\n  writeDeleteSet,\n  createDeleteSetFromStructStore,\n  transact,\n  readItemContent,\n  UpdateDecoderV1,\n  UpdateDecoderV2,\n  UpdateEncoderV1,\n  UpdateEncoderV2,\n  DSEncoderV2,\n  DSDecoderV1,\n  DSEncoderV1,\n  mergeUpdates,\n  mergeUpdatesV2,\n  Skip,\n  diffUpdateV2,\n  convertUpdateFormatV2ToV1,\n  DSDecoderV2, Doc, Transaction, GC, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as binary from 'lib0/binary'\nimport * as map from 'lib0/map'\nimport * as math from 'lib0/math'\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = math.max(clock, structs[0].id.clock) // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock)\n  // write # encoded structs\n  encoding.writeVarUint(encoder.restEncoder, structs.length - startNewStructs)\n  encoder.writeClient(client)\n  encoding.writeVarUint(encoder.restEncoder, clock)\n  const firstStruct = structs[startNewStructs]\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock)\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0)\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nexport const writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map()\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock)\n    }\n  })\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0)\n    }\n  })\n  // write # states that were updated\n  encoding.writeVarUint(encoder.restEncoder, sm.size)\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  Array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock)\n  })\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nexport const readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = map.create()\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder)\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs)\n    const client = decoder.readClient()\n    let clock = decoding.readVarUint(decoder.restDecoder)\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs })\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo()\n      switch (binary.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen()\n          refs[i] = new GC(createID(client, clock), len)\n          clock += len\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = decoding.readVarUint(decoder.restDecoder)\n          refs[i] = new Skip(createID(client, clock), len)\n          clock += len\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct\n          clock += struct.length\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n}\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = []\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a, b) => a - b)\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]))\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop()\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]))\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  }\n  let curStructsTarget = getNextStructTarget()\n  if (curStructsTarget === null && stack.length === 0) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore()\n  const missingSV = new Map()\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client)\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock)\n    }\n  }\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++]\n  // caching the state because it is used very often\n  const state = new Map()\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client\n      const unapplicableItems = clientsStructRefs.get(client)\n      if (unapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        unapplicableItems.i--\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i))\n        clientsStructRefs.delete(client)\n        unapplicableItems.i = 0\n        unapplicableItems.refs = []\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item])\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client)\n    }\n    stack.length = 0\n  }\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = map.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client))\n      const offset = localClock - stackHead.id.clock\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead)\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1)\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS()\n      } else {\n        const missing = stackHead.getMissing(transaction, store)\n        if (missing !== null) {\n          stack.push(stackHead)\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 }\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing))\n            addStackToRestSS()\n          } else {\n            stackHead = structRefs.refs[structRefs.i++]\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset)\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length)\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop())\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++])\n    } else {\n      curStructsTarget = getNextStructTarget()\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++])\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2()\n    writeClientsStructs(encoder, restStructs, new Map())\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    encoding.writeVarUint(encoder.restEncoder, 0) // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nexport const writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState)\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nexport const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    // force that transaction.local is set to non-local\n    transaction.local = false\n    let retry = false\n    const doc = transaction.doc\n    const store = doc.store\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc)\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss)\n    const pending = store.pendingStructs\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client)\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock)\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update])\n      }\n    } else {\n      store.pendingStructs = restStructs\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store)\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2(decoding.createDecoder(store.pendingDs))\n      decoding.readVarUint(pendingDSUpdate.restDecoder) // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store)\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2])\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update\n      store.pendingStructs = null\n      applyUpdateV2(transaction.doc, update)\n    }\n  }, transactionOrigin, false)\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nexport const readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder))\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nexport const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = decoding.createDecoder(update)\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder))\n}\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nexport const applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1)\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nexport const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector)\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store))\n}\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector)\n  writeStateAsUpdate(encoder, doc, targetStateVector)\n  const updates = [encoder.toUint8Array()]\n  // also add the pending updates (if there are any)\n  if (doc.store.pendingDs) {\n    updates.push(doc.store.pendingDs)\n  }\n  if (doc.store.pendingStructs) {\n    updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector))\n  }\n  if (updates.length > 1) {\n    if (encoder.constructor === UpdateEncoderV1) {\n      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)))\n    } else if (encoder.constructor === UpdateEncoderV2) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n}\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1())\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nexport const readStateVector = decoder => {\n  const ss = new Map()\n  const ssLength = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < ssLength; i++) {\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const clock = decoding.readVarUint(decoder.restDecoder)\n    ss.set(client, clock)\n  }\n  return ss\n}\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nexport const decodeStateVector = decodedState => readStateVector(new DSDecoderV1(decoding.createDecoder(decodedState)))\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nexport const writeStateVector = (encoder, sv) => {\n  encoding.writeVarUint(encoder.restEncoder, sv.size)\n  sv.forEach((clock, client) => {\n    encoding.writeVarUint(encoder.restEncoder, client) // @todo use a special client decoder that is based on mapping\n    encoding.writeVarUint(encoder.restEncoder, clock)\n  })\n  return encoder\n}\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nexport const writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store))\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc)\n  } else {\n    writeDocumentStateVector(encoder, doc)\n  }\n  return encoder.toUint8Array()\n}\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1())\n","import * as f from 'lib0/function'\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nexport class EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = []\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nexport const createEventHandler = () => new EventHandler()\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nexport const addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f)\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nexport const removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l\n  const len = l.length\n  eventHandler.l = l.filter(g => f !== g)\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.')\n  }\n}\n\n/**\n * Removes all event listeners.\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n *\n * @private\n * @function\n */\nexport const removeAllEventHandlerListeners = eventHandler => {\n  eventHandler.l.length = 0\n}\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nexport const callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  f.callAll(eventHandler.l, [arg0, arg1])\n","\nimport { AbstractType } from '../internals.js' // eslint-disable-line\n\nimport * as decoding from 'lib0/decoding'\nimport * as encoding from 'lib0/encoding'\nimport * as error from 'lib0/error'\n\nexport class ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nexport const compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock)\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nexport const createID = (client, clock) => new ID(client, clock)\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nexport const writeID = (encoder, id) => {\n  encoding.writeVarUint(encoder, id.client)\n  encoding.writeVarUint(encoder, id.clock)\n}\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nexport const readID = decoder =>\n  createID(decoding.readVarUint(decoder), decoding.readVarUint(decoder))\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nexport const findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw error.unexpectedCase()\n}\n","\nimport { AbstractType, Item } from '../internals.js' // eslint-disable-line\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nexport const isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item\n  }\n  return false\n}\n","\nimport {\n  AbstractType // eslint-disable-line\n} from '../internals.js'\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nexport const logType = type => {\n  const res = []\n  let n = type._start\n  while (n) {\n    res.push(n)\n    n = n.right\n  }\n  console.log('Children: ', res)\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content))\n}\n","\nimport {\n  YArray,\n  YMap,\n  readDeleteSet,\n  writeDeleteSet,\n  createDeleteSet,\n  DSEncoderV1, DSDecoderV1, ID, DeleteSet, YArrayEvent, Transaction, Doc // eslint-disable-line\n} from '../internals.js'\n\nimport * as decoding from 'lib0/decoding'\n\nimport { mergeDeleteSets, isDeleted } from './DeleteSet.js'\n\nexport class PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map()\n    this.yusers = storeType\n    this.doc = doc\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map()\n    this.dss = dss\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds')\n      const ids = user.get('ids')\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription)\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(decoding.createDecoder(encodedDs)))]))\n            }\n          })\n        })\n      })\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1(decoding.createDecoder(encodedDs))))))\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      )\n      ids.forEach(addClientId)\n    }\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      )\n    })\n    // add intial data\n    storeType.forEach(initUser)\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} [conf]\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers\n    let user = users.get(userDescription)\n    if (!user) {\n      user = new YMap()\n      user.set('ids', new YArray())\n      user.set('ds', new YArray())\n      users.set(userDescription, user)\n    }\n    user.get('ids').push([clientid])\n    users.observe(event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription)\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid])\n            }\n          })\n          const encoder = new DSEncoderV1()\n          const ds = this.dss.get(userDescription)\n          if (ds) {\n            writeDeleteSet(encoder, ds)\n            user.get('ds').push([encoder.toUint8Array()])\n          }\n        }\n      }, 0)\n    })\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds')\n        const ds = transaction.deleteSet\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1()\n          writeDeleteSet(encoder, ds)\n          yds.push([encoder.toUint8Array()])\n        }\n      })\n    })\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n","\nimport {\n  writeID,\n  readID,\n  compareIDs,\n  getState,\n  findRootTypeKey,\n  Item,\n  createID,\n  ContentType,\n  followRedone,\n  ID, Doc, AbstractType // eslint-disable-line\n} from '../internals.js'\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as error from 'lib0/error'\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nexport class RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname\n    /**\n     * @type {ID | null}\n     */\n    this.item = item\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nexport const relativePositionToJSON = rpos => {\n  const json = {}\n  if (rpos.type) {\n    json.type = rpos.type\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname\n  }\n  if (rpos.item) {\n    json.item = rpos.item\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc\n  }\n  return json\n}\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nexport const createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc)\n\nexport class AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type\n    /**\n     * @type {number}\n     */\n    this.index = index\n    this.assoc = assoc\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nexport const createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc)\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nexport const createRelativePosition = (type, item, assoc) => {\n  let typeid = null\n  let tname = null\n  if (type._item === null) {\n    tname = findRootTypeKey(type)\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock)\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n}\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nexport const createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right\n  }\n  return createRelativePosition(type, null, assoc)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nexport const writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos\n  if (item !== null) {\n    encoding.writeVarUint(encoder, 0)\n    writeID(encoder, item)\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    encoding.writeUint8(encoder, 1)\n    encoding.writeVarString(encoder, tname)\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    encoding.writeUint8(encoder, 2)\n    writeID(encoder, type)\n  } else {\n    throw error.unexpectedCase()\n  }\n  encoding.writeVarInt(encoder, assoc)\n  return encoder\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nexport const encodeRelativePosition = rpos => {\n  const encoder = encoding.createEncoder()\n  writeRelativePosition(encoder, rpos)\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nexport const readRelativePosition = decoder => {\n  let type = null\n  let tname = null\n  let itemID = null\n  switch (decoding.readVarUint(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder)\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = decoding.readVarString(decoder)\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder)\n    }\n  }\n  const assoc = decoding.hasContent(decoder) ? decoding.readVarInt(decoder) : 0\n  return new RelativePosition(type, tname, itemID, assoc)\n}\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nexport const decodeRelativePosition = uint8Array => readRelativePosition(decoding.createDecoder(uint8Array))\n\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nexport const createAbsolutePositionFromRelativePosition = (rpos, doc) => {\n  const store = doc.store\n  const rightID = rpos.item\n  const typeID = rpos.type\n  const tname = rpos.tname\n  const assoc = rpos.assoc\n  let type = null\n  let index = 0\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followRedone(store, rightID)\n    const right = res.item\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent)\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)) // adjust position based on left association if necessary\n      let n = right.left\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length\n        }\n        n = n.left\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname)\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followRedone(store, typeID)\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw error.unexpectedCase()\n    }\n    if (assoc >= 0) {\n      index = type._length\n    } else {\n      index = 0\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n}\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nexport const compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n)\n","\nimport {\n  isDeleted,\n  createDeleteSetFromStructStore,\n  getStateVector,\n  getItemCleanStart,\n  iterateDeletedStructs,\n  writeDeleteSet,\n  writeStateVector,\n  readDeleteSet,\n  readStateVector,\n  createDeleteSet,\n  createID,\n  getState,\n  findIndexSS,\n  UpdateEncoderV2,\n  applyUpdateV2,\n  DSEncoderV1, DSEncoderV2, DSDecoderV1, DSDecoderV2, Transaction, Doc, DeleteSet, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as map from 'lib0/map'\nimport * as set from 'lib0/set'\nimport * as decoding from 'lib0/decoding'\nimport * as encoding from 'lib0/encoding'\n\nexport class Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nexport const equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients\n  const ds2 = snap2.ds.clients\n  const sv1 = snap1.sv\n  const sv2 = snap2.sv\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || []\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i]\n      const dsitem2 = dsitems2[i]\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nexport const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds)\n  writeStateVector(encoder, snapshot.sv)\n  return encoder.toUint8Array()\n}\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nexport const encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1())\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nexport const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(decoding.createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nexport const decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(decoding.createDecoder(buf)))\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nexport const createSnapshot = (ds, sm) => new Snapshot(ds, sm)\n\nexport const emptySnapshot = createSnapshot(createDeleteSet(), new Map())\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nexport const snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store))\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nexport const isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (\n  snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id)\n)\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nexport const splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, set.create)\n  const store = transaction.doc.store\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock))\n      }\n    })\n    iterateDeletedStructs(transaction, snapshot.ds, item => {})\n    meta.add(snapshot)\n  }\n}\n\n/**\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nexport const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('originDoc must not be garbage collected')\n  }\n  const { sv, ds } = snapshot\n\n  const encoder = new UpdateEncoderV2()\n  originDoc.transact(transaction => {\n    let size = 0\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++\n      }\n    })\n    encoding.writeVarUint(encoder.restEncoder, size)\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock))\n      }\n      const structs = originDoc.store.clients.get(client) || []\n      const lastStructIndex = findIndexSS(structs, clock - 1)\n      // write # encoded structs\n      encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1)\n      encoder.writeClient(client)\n      // first clock written is 0\n      encoding.writeVarUint(encoder.restEncoder, 0)\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0)\n      }\n    }\n    writeDeleteSet(encoder, ds)\n  })\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot')\n  return newDoc\n}\n","\nimport {\n  GC,\n  splitItem,\n  Transaction, ID, Item, DSDecoderV2 // eslint-disable-line\n} from '../internals.js'\n\nimport * as math from 'lib0/math'\nimport * as error from 'lib0/error'\n\nexport class StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map()\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nexport const getStateVector = store => {\n  const sm = new Map()\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1]\n    sm.set(client, struct.id.clock + struct.length)\n  })\n  return sm\n}\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nexport const getState = (store, client) => {\n  const structs = store.clients.get(client)\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1]\n  return lastStruct.id.clock + lastStruct.length\n}\n\n/**\n * @param {StructStore} store\n *\n * @private\n * @function\n */\nexport const integretyCheck = store => {\n  store.clients.forEach(structs => {\n    for (let i = 1; i < structs.length; i++) {\n      const l = structs[i - 1]\n      const r = structs[i]\n      if (l.id.clock + l.length !== r.id.clock) {\n        throw new Error('StructStore failed integrety check')\n      }\n    }\n  })\n}\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nexport const addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client)\n  if (structs === undefined) {\n    structs = []\n    store.clients.set(struct.id.client, structs)\n  } else {\n    const lastStruct = structs[structs.length - 1]\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw error.unexpectedCase()\n    }\n  }\n  structs.push(struct)\n}\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nexport const findIndexSS = (structs, clock) => {\n  let left = 0\n  let right = structs.length - 1\n  let mid = structs[right]\n  let midclock = mid.id.clock\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = math.floor((clock / (midclock + mid.length - 1)) * right) // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex]\n    midclock = mid.id.clock\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1\n    } else {\n      right = midindex - 1\n    }\n    midindex = math.floor((left + right) / 2)\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw error.unexpectedCase()\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nexport const find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client)\n  return structs[findIndexSS(structs, id.clock)]\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nexport const getItem = /** @type {function(StructStore,ID):Item} */ (find)\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nexport const findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock)\n  const struct = structs[index]\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock))\n    return index + 1\n  }\n  return index\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nexport const getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client))\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nexport const getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client)\n  const index = findIndexSS(structs, id.clock)\n  const struct = structs[index]\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1))\n  }\n  return struct\n}\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nexport const replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client))\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct\n}\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nexport const iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len\n  let index = findIndexCleanStart(transaction, structs, clockStart)\n  let struct\n  do {\n    struct = structs[index++]\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd)\n    }\n    f(struct)\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n}\n","\nimport {\n  getState,\n  writeStructsFromTransaction,\n  writeDeleteSet,\n  DeleteSet,\n  sortAndMergeDeleteSet,\n  getStateVector,\n  findIndexSS,\n  callEventHandlerListeners,\n  Item,\n  generateNewClientId,\n  createID,\n  UpdateEncoderV1, UpdateEncoderV2, GC, StructStore, AbstractType, AbstractStruct, YEvent, Doc // eslint-disable-line\n} from '../internals.js'\n\nimport * as map from 'lib0/map'\nimport * as math from 'lib0/math'\nimport * as set from 'lib0/set'\nimport * as logging from 'lib0/logging'\nimport { callAll } from 'lib0/function'\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nexport class Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet()\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store)\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map()\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent>,Set<String|null>>}\n     */\n    this.changed = new Map()\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent>,Array<YEvent>>}\n     */\n    this.changedParentTypes = new Map()\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = []\n    /**\n     * @type {any}\n     */\n    this.origin = origin\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map()\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set()\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set()\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set()\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nexport const writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !map.any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet)\n  writeStructsFromTransaction(encoder, transaction)\n  writeDeleteSet(encoder, transaction.deleteSet)\n  return true\n}\n\n/**\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nexport const nextID = transaction => {\n  const y = transaction.doc\n  return createID(y.clientID, getState(y.store, y.clientID))\n}\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent>} type\n * @param {string|null} parentSub\n */\nexport const addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    map.setIfUndefined(transaction.changed, type, set.create).add(parentSub)\n  }\n}\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1]\n  const right = structs[pos]\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1)\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left))\n      }\n    }\n  }\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di]\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si]\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di]\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1))\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si)\n      }\n    }\n  })\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nexport const tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter)\n  tryMergeDeleteSet(ds, store)\n}\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i]\n    const doc = transaction.doc\n    const store = doc.store\n    const ds = transaction.deleteSet\n    const mergeStructs = transaction._mergeStructs\n    try {\n      sortAndMergeDeleteSet(ds)\n      transaction.afterState = getStateVector(transaction.doc.store)\n      doc._transaction = null\n      doc.emit('beforeObserverCalls', [transaction, doc])\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = []\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs)\n          }\n        })\n      )\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                )\n              events\n                .forEach(event => {\n                  event.currentTarget = type\n                })\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length)\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction)\n            }\n          })\n        )\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]))\n      })\n      callAll(fs, [])\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter)\n      }\n      tryMergeDeleteSet(ds, store)\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = math.max(findIndexSS(structs, beforeClock), 1)\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i)\n          }\n        }\n      })\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n        const replacedStructPos = findIndexSS(structs, clock)\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1)\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos)\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        doc.clientID = generateNewClientId()\n        logging.print(logging.ORANGE, logging.BOLD, '[yjs] ', logging.UNBOLD, logging.RED, 'Changed the client-id because another client seems to be using it.')\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc])\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1()\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction)\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction])\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2()\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction)\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction])\n        }\n      }\n      transaction.subdocsAdded.forEach(subdoc => doc.subdocs.add(subdoc))\n      transaction.subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc))\n\n      doc.emit('subdocs', [{ loaded: transaction.subdocsLoaded, added: transaction.subdocsAdded, removed: transaction.subdocsRemoved }])\n      transaction.subdocsRemoved.forEach(subdoc => subdoc.destroy())\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = []\n        doc.emit('afterAllTransactions', [doc, transactionCleanups])\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1)\n      }\n    }\n  }\n}\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @param {Doc} doc\n * @param {function(Transaction):void} f\n * @param {any} [origin=true]\n *\n * @function\n */\nexport const transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups\n  let initialCall = false\n  if (doc._transaction === null) {\n    initialCall = true\n    doc._transaction = new Transaction(doc, origin, local)\n    transactionCleanups.push(doc._transaction)\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc])\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc])\n  }\n  try {\n    f(doc._transaction)\n  } finally {\n    if (initialCall && transactionCleanups[0] === doc._transaction) {\n      // The first transaction ended, now process observer calls.\n      // Observer call may create new transactions for which we need to call the observers and do cleanup.\n      // We don't want to nest these calls, so we execute these calls one after\n      // another.\n      // Also we need to ensure that all cleanups are called, even if the\n      // observes throw errors.\n      // This file is full of hacky try {} finally {} blocks to ensure that an\n      // event can throw errors and also that the cleanup is called.\n      cleanupTransactions(transactionCleanups, 0)\n    }\n  }\n}\n","import {\n  mergeDeleteSets,\n  iterateDeletedStructs,\n  keepItem,\n  transact,\n  createID,\n  redoItem,\n  isParentOf,\n  followRedone,\n  getItemCleanStart,\n  isDeleted,\n  addToDeleteSet,\n  Transaction, Doc, Item, GC, DeleteSet, AbstractType, YEvent // eslint-disable-line\n} from '../internals.js'\n\nimport * as time from 'lib0/time'\nimport { Observable } from 'lib0/observable'\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions\n    this.deletions = deletions\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map()\n  }\n}\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */\n  let result = null\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null\n  const doc = undoManager.doc\n  const scope = undoManager.scope\n  transact(doc, transaction => {\n    while (stack.length > 0 && result === null) {\n      const store = doc.store\n      const stackItem = /** @type {StackItem} */ (stack.pop())\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set()\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = []\n      let performedChange = false\n      iterateDeletedStructs(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id)\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff))\n            }\n            struct = item\n          }\n          if (!struct.deleted && scope.some(type => isParentOf(type, /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct)\n          }\n        }\n      })\n      iterateDeletedStructs(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => isParentOf(type, struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)\n        ) {\n          itemsToRedo.add(struct)\n        }\n      })\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo) !== null || performedChange\n      })\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i]\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction)\n          performedChange = true\n        }\n      }\n      result = performedChange ? stackItem : null\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0\n      }\n    })\n    _tr = transaction\n  }, undoManager)\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes\n    undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType, changedParentTypes }, undoManager])\n  }\n  return result\n}\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter whan an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'>}\n */\nexport class UndoManager extends Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, { captureTimeout = 500, deleteFilter = () => true, trackedOrigins = new Set([null]) } = {}) {\n    super()\n    this.scope = typeScope instanceof Array ? typeScope : [typeScope]\n    this.deleteFilter = deleteFilter\n    trackedOrigins.add(this)\n    this.trackedOrigins = trackedOrigins\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = []\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = []\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false\n    this.redoing = false\n    this.doc = /** @type {Doc} */ (this.scope[0].doc)\n    this.lastChange = 0\n    this.doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      // Only track certain transactions\n      if (!this.scope.some(type => transaction.changedParentTypes.has(type)) || (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))) {\n        return\n      }\n      const undoing = this.undoing\n      const redoing = this.redoing\n      const stack = undoing ? this.redoStack : this.undoStack\n      if (undoing) {\n        this.stopCapturing() // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.redoStack = []\n      }\n      const insertions = new DeleteSet()\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0\n        const len = endClock - startClock\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len)\n        }\n      })\n      const now = time.getUnixTime()\n      if (now - this.lastChange < captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1]\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet])\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions])\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions))\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n          keepItem(item, true)\n        }\n      })\n      this.emit('stack-item-added', [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this])\n    })\n  }\n\n  clear () {\n    this.doc.transact(transaction => {\n      /**\n       * @param {StackItem} stackItem\n       */\n      const clearItem = stackItem => {\n        iterateDeletedStructs(transaction, stackItem.deletions, item => {\n          if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n            keepItem(item, false)\n          }\n        })\n      }\n      this.undoStack.forEach(clearItem)\n      this.redoStack.forEach(clearItem)\n    })\n    this.undoStack = []\n    this.redoStack = []\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true\n    let res\n    try {\n      res = popStackItem(this, this.undoStack, 'undo')\n    } finally {\n      this.undoing = false\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true\n    let res\n    try {\n      res = popStackItem(this, this.redoStack, 'redo')\n    } finally {\n      this.redoing = false\n    }\n    return res\n  }\n}\n","\nimport * as binary from 'lib0/binary'\nimport * as decoding from 'lib0/decoding'\nimport * as encoding from 'lib0/encoding'\nimport * as logging from 'lib0/logging'\nimport * as math from 'lib0/math'\nimport {\n  createID,\n  readItemContent,\n  readDeleteSet,\n  writeDeleteSet,\n  Skip,\n  mergeDeleteSets,\n  DSEncoderV1,\n  DSEncoderV2,\n  decodeStateVector,\n  Item, GC, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2 // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder)\n    const client = decoder.readClient()\n    let clock = decoding.readVarUint(decoder.restDecoder)\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo()\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = decoding.readVarUint(decoder.restDecoder)\n        yield new Skip(createID(client, clock), len)\n        clock += len\n      } else if ((binary.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        )\n        yield struct\n        clock += struct.length\n      } else {\n        const len = decoder.readLen()\n        yield new GC(createID(client, clock), len)\n        clock += len\n      }\n    }\n  }\n}\n\nexport class LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder)\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null\n    this.done = false\n    this.filterSkips = filterSkips\n    this.next()\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nexport const logUpdate = update => logUpdateV2(update, UpdateDecoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nexport const logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = []\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, false)\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr)\n  }\n  logging.print('Structs: ', structs)\n  const ds = readDeleteSet(updateDecoder)\n  logging.print('DeleteSet: ', ds)\n}\n\nexport class LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0\n    this.startClock = 0\n    this.written = 0\n    this.encoder = encoder\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = []\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nexport const mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nexport const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder()\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false)\n  let curr = updateDecoder.curr\n  if (curr !== null) {\n    let size = 0\n    let currClient = curr.id.client\n    let stopCounting = curr.id.clock !== 0 // must start at 0\n    let currClock = stopCounting ? 0 : curr.id.clock + curr.length\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        if (currClock !== 0) {\n          size++\n          // We found a new client\n          // write what we have to the encoder\n          encoding.writeVarUint(encoder.restEncoder, currClient)\n          encoding.writeVarUint(encoder.restEncoder, currClock)\n        }\n        currClient = curr.id.client\n        currClock = 0\n        stopCounting = curr.id.clock !== 0\n      }\n      // we ignore skips\n      if (curr.constructor === Skip) {\n        stopCounting = true\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length\n      }\n    }\n    // write what we have\n    if (currClock !== 0) {\n      size++\n      encoding.writeVarUint(encoder.restEncoder, currClient)\n      encoding.writeVarUint(encoder.restEncoder, currClock)\n    }\n    // prepend the size of the state vector\n    const enc = encoding.createEncoder()\n    encoding.writeVarUint(enc, size)\n    encoding.writeBinaryEncoder(enc, encoder.restEncoder)\n    encoder.restEncoder = enc\n    return encoder.toUint8Array()\n  } else {\n    encoding.writeVarUint(encoder.restEncoder, 0)\n    return encoder.toUint8Array()\n  }\n}\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nexport const encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nexport const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map()\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map()\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false)\n  let curr = updateDecoder.curr\n  if (curr !== null) {\n    let currClient = curr.id.client\n    let currClock = curr.id.clock\n    // write the beginning to `from`\n    from.set(currClient, currClock)\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock)\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock)\n        // update currClient\n        currClient = curr.id.client\n      }\n      currClock = curr.id.clock + curr.length\n    }\n    // write the end to `to`\n    to.set(currClient, currClock)\n  }\n  return { from, to }\n}\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nexport const parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1)\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left)\n    const { client, clock } = leftItem.id\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n}\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nexport const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const updateDecoders = updates.map(update => new YDecoder(decoding.createDecoder(update)))\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true))\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null\n\n  const updateEncoder = new YEncoder()\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder)\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first ⇒ sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null)\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : (\n              dec1.curr.constructor === Skip ? 1 : -1\n            )\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    )\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0]\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr)\n      let iterated = false\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next()\n        iterated = true\n      }\n      if (\n        curr === null || // current decoder is empty\n        curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n        (iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) // the above while loop was used and we are potentially missing updates\n      ) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n        currWrite = { struct: curr, offset: 0 }\n        currDecoder.next()\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff)\n            currWrite = { struct, offset: 0 }\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff\n            } else {\n              curr = sliceStruct(curr, diff)\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n            currWrite = { struct: curr, offset: 0 }\n            currDecoder.next()\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 }\n      currDecoder.next()\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n      currWrite = { struct: next, offset: 0 }\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n    currWrite = null\n  }\n  finishLazyStructWriting(lazyStructEncoder)\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder))\n  const ds = mergeDeleteSets(dss)\n  writeDeleteSet(updateEncoder, ds)\n  return updateEncoder.toUint8Array()\n}\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nexport const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv)\n  const encoder = new YEncoder()\n  const lazyStructWriter = new LazyStructWriter(encoder)\n  const decoder = new YDecoder(decoding.createDecoder(update))\n  const reader = new LazyStructReader(decoder, false)\n  while (reader.curr) {\n    const curr = reader.curr\n    const currClient = curr.id.client\n    const svClock = state.get(currClient) || 0\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next()\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, math.max(svClock - curr.id.clock, 0))\n      reader.next()\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0)\n        reader.next()\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next()\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter)\n  // write ds\n  const ds = readDeleteSet(decoder)\n  writeDeleteSet(encoder, ds)\n  return encoder.toUint8Array()\n}\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nexport const diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1)\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: encoding.toUint8Array(lazyWriter.encoder.restEncoder) })\n    lazyWriter.encoder.restEncoder = encoding.createEncoder()\n    lazyWriter.written = 0\n  }\n}\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter)\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client)\n    // write startClock\n    encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset)\n  }\n  struct.write(lazyWriter.encoder, offset)\n  lazyWriter.written++\n}\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter)\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length)\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i]\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    encoding.writeVarUint(restEncoder, partStructs.written)\n    // write the rest of the fragment\n    encoding.writeUint8Array(restEncoder, partStructs.restEncoder)\n  }\n}\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder\n * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder\n */\nexport const convertUpdateFormat = (update, YDecoder, YEncoder) => {\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, false)\n  const updateEncoder = new YEncoder()\n  const lazyWriter = new LazyStructWriter(updateEncoder)\n\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    writeStructToLazyStructWriter(lazyWriter, curr, 0)\n  }\n  finishLazyStructWriting(lazyWriter)\n  const ds = readDeleteSet(updateDecoder)\n  writeDeleteSet(updateEncoder, ds)\n  return updateEncoder.toUint8Array()\n}\n\n/**\n * @param {Uint8Array} update\n */\nexport const convertUpdateFormatV1ToV2 = update => convertUpdateFormat(update, UpdateDecoderV1, UpdateEncoderV2)\n\n/**\n * @param {Uint8Array} update\n */\nexport const convertUpdateFormatV2ToV1 = update => convertUpdateFormat(update, UpdateDecoderV2, UpdateEncoderV1)\n","\nimport {\n  isDeleted,\n  Item, AbstractType, Transaction, AbstractStruct // eslint-disable-line\n} from '../internals.js'\n\nimport * as set from 'lib0/set'\nimport * as array from 'lib0/array'\n\n/**\n * YEvent describes the changes on a YType.\n */\nexport class YEvent {\n  /**\n   * @param {AbstractType<any>} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {AbstractType<any>}\n     */\n    this.target = target\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    this._keys = null\n    /**\n     * @type {null | Array<{ insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      const keys = new Map()\n      const target = this.target\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target))\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key))\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action\n          let oldValue\n          if (this.adds(item)) {\n            let prev = item.left\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete'\n                oldValue = array.last(prev.content.getContent())\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update'\n                oldValue = array.last(prev.content.getContent())\n              } else {\n                action = 'add'\n                oldValue = undefined\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete'\n              oldValue = array.last(/** @type {Item} */ item.content.getContent())\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue })\n        }\n      })\n      this._keys = keys\n    }\n    return this._keys\n  }\n\n  /**\n   * @type {Array<{insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes\n    if (changes === null) {\n      const target = this.target\n      const added = set.create()\n      const deleted = set.create()\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = []\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      }\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target))\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp)\n          }\n        }\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp()\n                lastOp = { delete: 0 }\n              }\n              lastOp.delete += item.length\n              deleted.add(item)\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp()\n                lastOp = { insert: [] }\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent())\n              added.add(item)\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp()\n                lastOp = { retain: 0 }\n              }\n              lastOp.retain += item.length\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp()\n        }\n      }\n      this._changes = changes\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = []\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub)\n    } else {\n      // parent is array-ish\n      let i = 0\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++\n        }\n        c = c.right\n      }\n      path.unshift(i)\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent)\n  }\n  return path\n}\n","\nimport {\n  removeEventHandlerListener,\n  callEventHandlerListeners,\n  addEventHandlerListener,\n  createEventHandler,\n  getState,\n  isVisible,\n  ContentType,\n  createID,\n  ContentAny,\n  ContentBinary,\n  getItemCleanStart,\n  ContentDoc, YText, YArray, UpdateEncoderV1, UpdateEncoderV2, Doc, Snapshot, Transaction, EventHandler, YEvent, Item, // eslint-disable-line\n} from '../internals.js'\n\nimport * as map from 'lib0/map'\nimport * as iterator from 'lib0/iterator'\nimport * as error from 'lib0/error'\nimport * as math from 'lib0/math'\n\nconst maxSearchMarker = 80\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0\n\nexport class ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true\n    this.p = p\n    this.index = index\n    this.timestamp = globalSearchMarkerTimestamp++\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++ }\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false\n  marker.p = p\n  p.marker = true\n  marker.index = index\n  marker.timestamp = globalSearchMarkerTimestamp++\n}\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b)\n    overwriteMarker(marker, p, index)\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index)\n    searchMarker.push(pm)\n    return pm\n  }\n}\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nexport const findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => math.abs(index - a.index) < math.abs(index - b.index) ? a : b)\n  let p = yarray._start\n  let pindex = 0\n  if (marker !== null) {\n    p = marker.p\n    pindex = marker.index\n    refreshMarkerTimestamp(marker) // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length\n    }\n    p = p.right\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left\n    if (!p.deleted && p.countable) {\n      pindex -= p.length\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left\n    if (!p.deleted && p.countable) {\n      pindex -= p.length\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && math.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex)\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n}\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nexport const updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i]\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p\n      p.marker = false\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1)\n        continue\n      }\n      m.p = p\n      p.marker = true\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = math.max(index, m.index + len)\n    }\n  }\n}\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nexport const getTypeChildren = t => {\n  let s = t._start\n  const arr = []\n  while (s) {\n    arr.push(s)\n    s = s.right\n  }\n  return arr\n}\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nexport const callTypeObservers = (type, transaction, event) => {\n  const changedType = type\n  const changedParentTypes = transaction.changedParentTypes\n  while (true) {\n    // @ts-ignore\n    map.setIfUndefined(changedParentTypes, type, () => []).push(event)\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent)\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction)\n}\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nexport class AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map()\n    /**\n     * @type {Item|null}\n     */\n    this._start = null\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null\n    this._length = 0\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler()\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent>,Transaction>}\n     */\n    this._dEH = createEventHandler()\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y\n    this._item = item\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start\n    while (n !== null && n.deleted) {\n      n = n.right\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f)\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f)\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f)\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f)\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start\n  }\n  if (end < 0) {\n    end = type._length + end\n  }\n  let len = end - start\n  const cs = []\n  let n = type._start\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      if (c.length <= start) {\n        start -= c.length\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i])\n          len--\n        }\n        start = 0\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListToArray = type => {\n  const cs = []\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i])\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListToArraySnapshot = (type, snapshot) => {\n  const cs = []\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i])\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nexport const typeListForEach = (type, f) => {\n  let index = 0\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type)\n      }\n    }\n    n = n.right\n  }\n}\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nexport const typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = []\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type))\n  })\n  return result\n}\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nexport const typeListCreateIterator = type => {\n  let n = type._start\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null\n  let currentContentIndex = 0\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent()\n        currentContentIndex = 0\n        n = n.right // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++]\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n}\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n * Operates on a snapshotted state of the document.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,AbstractType<any>):void} f A function to execute on every element of this YArray.\n * @param {Snapshot} snapshot\n *\n * @private\n * @function\n */\nexport const typeListForEachSnapshot = (type, f, snapshot) => {\n  let index = 0\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type)\n      }\n    }\n    n = n.right\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nexport const typeListGet = (type, index) => {\n  const marker = findMarker(type, index)\n  let n = type._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length\n    }\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nexport const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  const store = doc.store\n  const right = referenceItem === null ? parent._start : referenceItem.right\n  /**\n   * @type {Array<Object|Array<any>|number>}\n   */\n  let jsonContent = []\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent))\n      left.integrate(transaction, 0)\n      jsonContent = []\n    }\n  }\n  content.forEach(c => {\n    switch (c.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        jsonContent.push(c)\n        break\n      default:\n        packJsonContent()\n        switch (c.constructor) {\n          case Uint8Array:\n          case ArrayBuffer:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))))\n            left.integrate(transaction, 0)\n            break\n          case Doc:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)))\n            left.integrate(transaction, 0)\n            break\n          default:\n            if (c instanceof AbstractType) {\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c))\n              left.integrate(transaction, 0)\n            } else {\n              throw new Error('Unexpected content type in insert operation')\n            }\n        }\n    }\n  })\n  packJsonContent()\n}\n\nconst lengthExceeded = error.create('Length exceeded!')\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nexport const typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index > parent._length) {\n    throw lengthExceeded\n  }\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length)\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index\n  const marker = findMarker(parent, index)\n  let n = parent._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index))\n        }\n        break\n      }\n      index -= n.length\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length)\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nexport const typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index\n  const startLength = length\n  const marker = findMarker(parent, index)\n  let n = parent._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index))\n      }\n      index -= n.length\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length))\n      }\n      n.delete(transaction)\n      length -= n.length\n    }\n    n = n.right\n  }\n  if (length > 0) {\n    throw lengthExceeded\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */)\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nexport const typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key)\n  if (c !== undefined) {\n    c.delete(transaction)\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nexport const typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  let content\n  if (value == null) {\n    content = new ContentAny([value])\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value])\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value))\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value))\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value)\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0)\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nexport const typeMapGet = (parent, key) => {\n  const val = parent._map.get(key)\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nexport const typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {}\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1]\n    }\n  })\n  return res\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nexport const typeMapHas = (parent, key) => {\n  const val = parent._map.get(key)\n  return val !== undefined && !val.deleted\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nexport const typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n}\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nexport const createMapIterator = map => iterator.iteratorFilter(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted)\n","/**\n * @module YArray\n */\n\nimport {\n  YEvent,\n  AbstractType,\n  typeListGet,\n  typeListToArray,\n  typeListForEach,\n  typeListCreateIterator,\n  typeListInsertGenerics,\n  typeListDelete,\n  typeListMap,\n  YArrayRefID,\n  callTypeObservers,\n  transact,\n  ArraySearchMarker, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Transaction, Item // eslint-disable-line\n} from '../internals.js'\nimport { typeListSlice } from './AbstractType.js'\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n */\nexport class YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction)\n    this._transaction = transaction\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nexport class YArray extends AbstractType {\n  constructor () {\n    super()\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = []\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = []\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    const a = new YArray()\n    a.push(items)\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent))\n    this._prelimContent = null\n  }\n\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    const arr = new YArray()\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? el.clone() : el\n    ))\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs)\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction))\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content)\n      })\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content)\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content)\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length)\n      })\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length)\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template T,M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function on once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f)\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nexport const readYArray = decoder => new YArray()\n","\n/**\n * @module YMap\n */\n\nimport {\n  YEvent,\n  AbstractType,\n  typeMapDelete,\n  typeMapSet,\n  typeMapGet,\n  typeMapHas,\n  createMapIterator,\n  YMapRefID,\n  callTypeObservers,\n  transact,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Transaction, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as iterator from 'lib0/iterator'\n\n/**\n * @template T\n * Event that describes the changes on a YMap.\n */\nexport class YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction)\n    this.keysChanged = subs\n  }\n}\n\n/**\n * @template T number|string|Object|Array|Uint8Array\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<T>>\n * @implements {Iterable<T>}\n */\nexport class YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super()\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null\n\n    if (entries === undefined) {\n      this._prelimContent = new Map()\n    } else {\n      this._prelimContent = new Map(entries)\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value)\n    })\n    this._prelimContent = null\n  }\n\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<T>}\n   */\n  clone () {\n    const map = new YMap()\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? value.clone() : value)\n    })\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs))\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,T>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {}\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1]\n        map[key] = v instanceof AbstractType ? v.toJSON() : v\n      }\n    })\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(T,string,YMap<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {}\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this)\n      }\n    })\n    return map\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key)\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key)\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {T} value The value of the element to add\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, value)\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value)\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {T|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * Removes all elements from this YMap.\n   */\n  clear () {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        this.forEach(function (value, key, map) {\n          typeMapDelete(transaction, map, key)\n        })\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).clear()\n    }\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nexport const readYMap = decoder => new YMap()\n","\n/**\n * @module YText\n */\n\nimport {\n  YEvent,\n  AbstractType,\n  getItemCleanStart,\n  getState,\n  isVisible,\n  createID,\n  YTextRefID,\n  callTypeObservers,\n  transact,\n  ContentEmbed,\n  GC,\n  ContentFormat,\n  ContentString,\n  splitSnapshotAffectedStructs,\n  iterateDeletedStructs,\n  iterateStructs,\n  findMarker,\n  typeMapDelete,\n  typeMapSet,\n  typeMapGet,\n  typeMapGetAll,\n  updateMarkerChanges,\n  ArraySearchMarker, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, ID, Doc, Item, Snapshot, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as object from 'lib0/object'\nimport * as map from 'lib0/map'\nimport * as error from 'lib0/error'\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && object.equalFlat(a, b))\n\nexport class ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left\n    this.right = right\n    this.index = index\n    this.currentAttributes = currentAttributes\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      error.unexpectedCase()\n    }\n    switch (this.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!this.right.deleted) {\n          this.index += this.right.length\n        }\n        break\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content))\n        }\n        break\n    }\n    this.left = this.right\n    this.right = this.right.right\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count))\n          }\n          pos.index += pos.right.length\n          count -= pos.right.length\n        }\n        break\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content))\n        }\n        break\n    }\n    pos.left = pos.right\n    pos.right = pos.right.right\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map()\n  const marker = findMarker(parent, index)\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes)\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes)\n    return findNextPosition(transaction, pos, index)\n  }\n}\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key)\n    }\n    currPos.forward()\n  }\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  negatedAttributes.forEach((val, key) => {\n    const left = currPos.left\n    const right = currPos.right\n    const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val))\n    nextFormat.integrate(transaction, 0)\n    currPos.right = nextFormat\n    currPos.forward()\n  })\n}\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format\n  if (value === null) {\n    currentAttributes.delete(key)\n  } else {\n    currentAttributes.set(key, value)\n  }\n}\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) {\n      //\n    } else {\n      break\n    }\n    currPos.forward()\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  const negatedAttributes = new Map()\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key]\n    const currentVal = currPos.currentAttributes.get(key) || null\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal)\n      const { left, right } = currPos\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val))\n      currPos.right.integrate(transaction, 0)\n      currPos.forward()\n    }\n  }\n  return negatedAttributes\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null\n    }\n  })\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  minimizeAttributeChanges(currPos, attributes)\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes)\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : new ContentEmbed(text)\n  let { left, right, index } = currPos\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength())\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content)\n  right.integrate(transaction, 0)\n  currPos.right = right\n  currPos.index = index\n  currPos.forward()\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes)\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  minimizeAttributeChanges(currPos, attributes)\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes)\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content)\n          const attr = attributes[key]\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key)\n            } else {\n              negatedAttributes.set(key, value)\n            }\n            currPos.right.delete(transaction)\n          }\n          break\n        }\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length))\n          }\n          length -= currPos.right.length\n          break\n      }\n    }\n    currPos.forward()\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = ''\n    for (; length > 0; length--) {\n      newlines += '\\n'\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines))\n    currPos.right.integrate(transaction, 0)\n    currPos.forward()\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes)\n}\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} end exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} endAttributes This attribute is modified!\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, end, startAttributes, endAttributes) => {\n  while (end && end.content.constructor !== ContentString && end.content.constructor !== ContentEmbed) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      updateCurrentAttributes(endAttributes, /** @type {ContentFormat} */ (end.content))\n    }\n    end = end.right\n  }\n  let cleanups = 0\n  while (start !== end) {\n    if (!start.deleted) {\n      const content = start.content\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content)\n          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction)\n            cleanups++\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right)\n  }\n  return cleanups\n}\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || (item.right.content.constructor !== ContentString && item.right.content.constructor !== ContentEmbed))) {\n    item = item.right\n  }\n  const attrs = new Set()\n  // iterate back until a content item is found\n  while (item && (item.deleted || (item.content.constructor !== ContentString && item.content.constructor !== ContentEmbed))) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key\n      if (attrs.has(key)) {\n        item.delete(transaction)\n      } else {\n        attrs.add(key)\n      }\n    }\n    item = item.left\n  }\n}\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nexport const cleanupYTextFormatting = type => {\n  let res = 0\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start)\n    let end = type._start\n    let startAttributes = map.create()\n    const currentAttributes = map.copy(startAttributes)\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content))\n            break\n          case ContentEmbed:\n          case ContentString:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes)\n            startAttributes = map.copy(currentAttributes)\n            start = end\n            break\n        }\n      }\n      end = end.right\n    }\n  })\n  return res\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length\n  const startAttrs = map.copy(currPos.currentAttributes)\n  const start = currPos.right\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length))\n          }\n          length -= currPos.right.length\n          currPos.right.delete(transaction)\n          break\n      }\n    }\n    currPos.forward()\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, map.copy(currPos.currentAttributes))\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent)\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length)\n  }\n  return currPos\n}\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * Event that describes the changes on a YText type.\n */\nexport class YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction)\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set()\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true\n      } else {\n        this.keysChanged.add(sub)\n      }\n    })\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      }\n      this._changes = changes\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc)\n      /**\n       * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = []\n      transact(y, transaction => {\n        const currentAttributes = new Map() // saves all current attributes for insert\n        const oldAttributes = new Map()\n        let item = this.target._start\n        /**\n         * @type {string?}\n         */\n        let action = null\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {} // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = ''\n        let retain = 0\n        let deleteLen = 0\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op\n            switch (action) {\n              case 'delete':\n                op = { delete: deleteLen }\n                deleteLen = 0\n                break\n              case 'insert':\n                op = { insert }\n                if (currentAttributes.size > 0) {\n                  op.attributes = {}\n                  currentAttributes.forEach((value, key) => {\n                    if (value !== null) {\n                      op.attributes[key] = value\n                    }\n                  })\n                }\n                insert = ''\n                break\n              case 'retain':\n                op = { retain }\n                if (Object.keys(attributes).length > 0) {\n                  op.attributes = {}\n                  for (const key in attributes) {\n                    op.attributes[key] = attributes[key]\n                  }\n                }\n                retain = 0\n                break\n            }\n            delta.push(op)\n            action = null\n          }\n        }\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp()\n                  action = 'insert'\n                  insert = /** @type {ContentEmbed} */ (item.content).embed\n                  addOp()\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp()\n                  action = 'delete'\n                }\n                deleteLen += 1\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp()\n                  action = 'retain'\n                }\n                retain += 1\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp()\n                    action = 'insert'\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp()\n                  action = 'delete'\n                }\n                deleteLen += item.length\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp()\n                  action = 'retain'\n                }\n                retain += item.length\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content)\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp()\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key]\n                    } else {\n                      attributes[key] = value\n                    }\n                  } else {\n                    item.delete(transaction)\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value)\n                const curVal = currentAttributes.get(key) || null\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp()\n                  }\n                  attributes[key] = curVal\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value)\n                const attr = attributes[key]\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp()\n                    }\n                    if (value === null) {\n                      attributes[key] = value\n                    } else {\n                      delete attributes[key]\n                    }\n                  } else {\n                    item.delete(transaction)\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp()\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content))\n              }\n              break\n            }\n          }\n          item = item.right\n        }\n        addOp()\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1]\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop()\n          } else {\n            break\n          }\n        }\n      })\n      this._delta = delta\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nexport class YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super()\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : []\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = []\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f())\n    } catch (e) {\n      console.error(e)\n    }\n    this._pending = null\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText()\n    text.applyDelta(this.toDelta())\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs)\n    const event = new YTextEvent(this, transaction, parentSubs)\n    const doc = transaction.doc\n    callTypeObservers(this, transaction, event)\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true\n          }\n        })\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true\n          }\n        })\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this)\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item)\n            }\n          })\n        }\n      })\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = ''\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str\n      }\n      n = n.right\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  [opts]\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map())\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i]\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {})\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {})\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete)\n          }\n        }\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta))\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = []\n    const currentAttributes = new Map()\n    const doc = /** @type {Doc} */ (this.doc)\n    let str = ''\n    let n = this._start\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}\n        let addAttributes = false\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true\n          attributes[key] = value\n        })\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str }\n        if (addAttributes) {\n          op.attributes = attributes\n        }\n        ops.push(op)\n        str = ''\n      }\n    }\n    // snapshots are merged again after the transaction, so we need to keep the\n    // transalive until we are done\n    transact(doc, transaction => {\n      if (snapshot) {\n        splitSnapshotAffectedStructs(transaction, snapshot)\n      }\n      if (prevSnapshot) {\n        splitSnapshotAffectedStructs(transaction, prevSnapshot)\n      }\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange')\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'removed') {\n                  packStr()\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' })\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'added') {\n                  packStr()\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' })\n                }\n              } else if (cur !== undefined) {\n                packStr()\n                currentAttributes.delete('ychange')\n              }\n              str += /** @type {ContentString} */ (n.content).str\n              break\n            }\n            case ContentEmbed: {\n              packStr()\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: /** @type {ContentEmbed} */ (n.content).embed\n              }\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({})\n                op.attributes = attrs\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value\n                })\n              }\n              ops.push(op)\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr()\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content))\n              }\n              break\n          }\n        }\n        n = n.right\n      }\n      packStr()\n    }, splitSnapshotAffectedStructs)\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index)\n        if (!attributes) {\n          attributes = {}\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v })\n        }\n        insertText(transaction, this, pos, text, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes))\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    if (embed.constructor !== Object) {\n      throw new Error('Embed must be an Object')\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index)\n        insertText(transaction, this, pos, embed, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes))\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length))\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index)\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes))\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName))\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue))\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nexport const readYText = decoder => new YText()\n","/**\n * @module YXml\n */\n\nimport {\n  YXmlEvent,\n  YXmlElement,\n  AbstractType,\n  typeListMap,\n  typeListForEach,\n  typeListInsertGenerics,\n  typeListInsertGenericsAfter,\n  typeListDelete,\n  typeListToArray,\n  YXmlFragmentRefID,\n  callTypeObservers,\n  transact,\n  typeListGet,\n  typeListSlice,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, ContentType, Transaction, Item, YXmlText, YXmlHook, Snapshot // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nexport class YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f\n    this._root = root\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start)\n    this._firstCall = true\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode\n    let type = n && n.content && /** @type {any} */ (n.content).type\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right\n              break\n            } else if (n.parent === this._root) {\n              n = null\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nexport class YXmlFragment extends AbstractType {\n  constructor () {\n    super()\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = []\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent))\n    this._prelimContent = null\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment()\n    // @ts-ignore\n    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item))\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase()\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query)\n    const next = iterator.next()\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase()\n    // @ts-ignore\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction))\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment()\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this)\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null)\n    })\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content)\n      })\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref\n        typeListInsertGenericsAfter(transaction, this, refItem, content)\n      })\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent)\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1\n      if (index === 0 && ref !== null) {\n        throw error.create('Reference item not found')\n      }\n      pc.splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length)\n      })\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length)\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content)\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content)\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nexport const readYXmlFragment = decoder => new YXmlFragment()\n","\nimport {\n  YXmlFragment,\n  transact,\n  typeMapDelete,\n  typeMapHas,\n  typeMapSet,\n  typeMapGet,\n  typeMapGetAll,\n  typeListForEach,\n  YXmlElementRefID,\n  YXmlText, ContentType, AbstractType, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Snapshot, Doc, Item // eslint-disable-line\n} from '../internals.js'\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n */\nexport class YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super()\n    this.nodeName = nodeName\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map()\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value)\n    })\n    this._prelimAttrs = null\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement}\n   */\n  clone () {\n    const el = new YXmlElement(this.nodeName)\n    const attrs = this.getAttributes()\n    for (const key in attrs) {\n      el.setAttribute(key, attrs[key])\n    }\n    // @ts-ignore\n    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item))\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes()\n    const stringBuilder = []\n    const keys = []\n    for (const key in attrs) {\n      keys.push(key)\n    }\n    keys.sort()\n    const keysLen = keys.length\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i]\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"')\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase()\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : ''\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName)\n      })\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName)\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {String} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue)\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue)\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {String} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns whether an attribute exists\n   *\n   * @param {String} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */\n  hasAttribute (attributeName) {\n    return /** @type {any} */ (typeMapHas(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName)\n    const attrs = this.getAttributes()\n    for (const key in attrs) {\n      dom.setAttribute(key, attrs[key])\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding))\n    })\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this)\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID)\n    encoder.writeKey(this.nodeName)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nexport const readYXmlElement = decoder => new YXmlElement(decoder.readKey())\n","\nimport {\n  YEvent,\n  YXmlText, YXmlElement, YXmlFragment, Transaction // eslint-disable-line\n} from '../internals.js'\n\n/**\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nexport class YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction)\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set()\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true\n      } else {\n        this.attributesChanged.add(sub)\n      }\n    })\n  }\n}\n","\nimport {\n  YMap,\n  YXmlHookRefID,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2 // eslint-disable-line\n} from '../internals.js'\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nexport class YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super()\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName)\n    this.forEach((value, key) => {\n      el.set(key, value)\n    })\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName]\n    let dom\n    if (hook !== undefined) {\n      dom = hook.createDom(this)\n    } else {\n      dom = document.createElement(this.hookName)\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName)\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this)\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID)\n    encoder.writeKey(this.hookName)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nexport const readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey())\n","\nimport {\n  YText,\n  YXmlTextRefID,\n  ContentType, YXmlElement, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, // eslint-disable-line\n} from '../internals.js'\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nexport class YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText()\n    text.applyDelta(this.toDelta())\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString())\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this)\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = []\n      for (const nodeName in delta.attributes) {\n        const attrs = []\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] })\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1)\n        nestedNodes.push({ nodeName, attrs })\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1)\n      // now convert to dom string\n      let str = ''\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i]\n        str += `<${node.nodeName}`\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j]\n          str += ` ${attr.key}=\"${attr.value}\"`\n        }\n        str += '>'\n      }\n      str += delta.insert\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nexport const readYXmlText = decoder => new YXmlText()\n","\nimport {\n  UpdateEncoderV1, UpdateEncoderV2, ID, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\nexport class AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id\n    this.length = length\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw error.methodUnimplemented()\n  }\n}\n","\nimport {\n  AbstractStruct,\n  addStruct,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, ID // eslint-disable-line\n} from '../internals.js'\n\nexport const structGCRefNumber = 0\n\n/**\n * @private\n */\nexport class GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset\n      this.length -= offset\n    }\n    addStruct(transaction.doc.store, this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber)\n    encoder.writeLen(this.length - offset)\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\nexport class ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nexport const readContentBinary = decoder => new ContentBinary(decoder.readBuf())\n","\nimport {\n  addToDeleteSet,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nexport class ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset)\n    this.len = offset\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len)\n    item.markDeleted()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nexport const readContentDeleted = decoder => new ContentDeleted(decoder.readLen())\n","\nimport {\n  Doc, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * @private\n */\nexport class ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.')\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc\n    /**\n     * @type {any}\n     */\n    const opts = {}\n    this.opts = opts\n    if (!doc.gc) {\n      opts.gc = false\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(this.doc)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item\n    transaction.subdocsAdded.add(this.doc)\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc)\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc)\n    } else {\n      transaction.subdocsRemoved.add(this.doc)\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid)\n    encoder.writeAny(this.opts)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nexport const readContentDoc = decoder => new ContentDoc(new Doc({ guid: decoder.readString(), ...decoder.readAny() }))\n","\nimport {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * @private\n */\nexport class ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nexport const readContentEmbed = decoder => new ContentEmbed(decoder.readJSON())\n","\nimport {\n  AbstractType, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Item, StructStore, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * @private\n */\nexport class ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key\n    this.value = value\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key)\n    encoder.writeJSON(this.value)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nexport const readContentFormat = decoder => new ContentFormat(decoder.readString(), decoder.readJSON())\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @private\n */\nexport class ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset))\n    this.arr = this.arr.slice(0, offset)\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr)\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length\n    encoder.writeLen(len - offset)\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i]\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c))\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nexport const readContentJSON = decoder => {\n  const len = decoder.readLen()\n  const cs = []\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString()\n    if (c === 'undefined') {\n      cs.push(undefined)\n    } else {\n      cs.push(JSON.parse(c))\n    }\n  }\n  return new ContentJSON(cs)\n}\n","import {\n  UpdateEncoderV1, UpdateEncoderV2, UpdateDecoderV1, UpdateDecoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\nexport class ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset))\n    this.arr = this.arr.slice(0, offset)\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr)\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length\n    encoder.writeLen(len - offset)\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i]\n      encoder.writeAny(c)\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nexport const readContentAny = decoder => {\n  const len = decoder.readLen()\n  const cs = []\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny())\n  }\n  return new ContentAny(cs)\n}\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @private\n */\nexport class ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset))\n    this.str = this.str.slice(0, offset)\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1)\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character (� / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '�'\n      // replace right as well\n      right.str = '�' + right.str.slice(1)\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset))\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nexport const readContentString = decoder => new ContentString(decoder.readString())\n","\nimport {\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, Item, YEvent, AbstractType // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nexport const typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n]\n\nexport const YArrayRefID = 0\nexport const YMapRefID = 1\nexport const YTextRefID = 2\nexport const YXmlElementRefID = 3\nexport const YXmlFragmentRefID = 4\nexport const YXmlHookRefID = 5\nexport const YXmlTextRefID = 6\n\n/**\n * @private\n */\nexport class ContentType {\n  /**\n   * @param {AbstractType<YEvent>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item)\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction)\n      } else {\n        // Whis will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item)\n      }\n      item = item.right\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction)\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item)\n      }\n    })\n    transaction.changed.delete(this.type)\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start\n    while (item !== null) {\n      item.gc(store, true)\n      item = item.right\n    }\n    this.type._start = null\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true)\n        item = item.left\n      }\n    })\n    this.type._map = new Map()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nexport const readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder))\n","\nimport {\n  GC,\n  getState,\n  AbstractStruct,\n  replaceStruct,\n  addStruct,\n  addToDeleteSet,\n  findRootTypeKey,\n  compareIDs,\n  getItem,\n  getItemCleanEnd,\n  getItemCleanStart,\n  readContentDeleted,\n  readContentBinary,\n  readContentJSON,\n  readContentAny,\n  readContentString,\n  readContentEmbed,\n  readContentDoc,\n  createID,\n  readContentFormat,\n  readContentType,\n  addChangedTypeToTransaction,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, ContentType, ContentDeleted, StructStore, ID, AbstractType, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error'\nimport * as binary from 'lib0/binary'\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nexport const followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id\n  let diff = 0\n  let item\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff)\n    }\n    item = getItem(store, nextID)\n    diff = nextID.clock - item.id.clock\n    nextID = item.redone\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n}\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nexport const keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep\n    item = /** @type {AbstractType<any>} */ (item.parent)._item\n  }\n}\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nexport const splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  )\n  if (leftItem.deleted) {\n    rightItem.markDeleted()\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff)\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem)\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem)\n  }\n  leftItem.length = diff\n  return rightItem\n}\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n *\n * @return {Item|null}\n *\n * @private\n */\nexport const redoItem = (transaction, item, redoitems) => {\n  const doc = transaction.doc\n  const store = doc.store\n  const ownClientID = doc.clientID\n  const redone = item.redone\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item\n  /**\n   * @type {Item|null}\n   */\n  let left\n  /**\n   * @type {Item|null}\n   */\n  let right\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left\n    right = item\n  } else {\n    // Is a map item. Insert as current value\n    left = item\n    while (left.right !== null) {\n      left = left.right\n      if (left.id.client !== ownClientID) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    }\n    if (left.right !== null) {\n      left = /** @type {Item} */ (/** @type {AbstractType<any>} */ (item.parent)._map.get(item.parentSub))\n    }\n    right = null\n  }\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {\n    // try to undo parent if it will be undone anyway\n    if (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems) === null) {\n      return null\n    }\n  }\n  if (parentItem !== null && parentItem.redone !== null) {\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone)\n    }\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone)\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace\n        break\n      }\n      left = left.left\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone)\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace\n        break\n      }\n      right = right.right\n    }\n  }\n  const nextClock = getState(store, ownClientID)\n  const nextId = createID(ownClientID, nextClock)\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type,\n    item.parentSub,\n    item.content.copy()\n  )\n  item.redone = nextId\n  keepItem(redoneItem, true)\n  redoneItem.integrate(transaction, 0)\n  return redoneItem\n}\n\n/**\n * Abstract class that represents any content.\n */\nexport class Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength())\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub\n    /**\n     * If this type's effect is reundone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? binary.BIT2 : 0\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & binary.BIT4) > 0) !== isMarked) {\n      this.info ^= binary.BIT4\n    }\n  }\n\n  get marker () {\n    return (this.info & binary.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & binary.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= binary.BIT1\n    }\n  }\n\n  get countable () {\n    return (this.info & binary.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & binary.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= binary.BIT3\n    }\n  }\n\n  markDeleted () {\n    this.info |= binary.BIT3\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin)\n      this.origin = this.left.lastId\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin)\n      this.rightOrigin = this.right.id\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent\n        this.parentSub = this.left.parentSub\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent\n        this.parentSub = this.right.parentSub\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent)\n      if (parentItem.constructor === GC) {\n        this.parent = null\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1))\n      this.origin = this.left.lastId\n      this.content = this.content.splice(offset)\n      this.length -= offset\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left\n\n        /**\n         * @type {Item|null}\n         */\n        let o\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null\n          while (o !== null && o.left !== null) {\n            o = o.left\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set()\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set()\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o)\n          conflictingItems.add(o)\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o\n              conflictingItems.clear()\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o\n              conflictingItems.clear()\n            }\n          } else {\n            break\n          }\n          o = o.right\n        }\n        this.left = left\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right\n        this.right = right\n        this.left.right = this\n      } else {\n        let r\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null\n          while (r !== null && r.left !== null) {\n            r = r.left\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this\n        }\n        this.right = r\n      }\n      if (this.right !== null) {\n        this.right.left = this\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this)\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction)\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length\n      }\n      addStruct(transaction.doc.store, this)\n      this.content.integrate(transaction, this)\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub)\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction)\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0)\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right\n    while (n !== null && n.deleted) {\n      n = n.right\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left\n    while (n !== null && n.deleted) {\n      n = n.left\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      const searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker\n      if (searchMarker) {\n        searchMarker.forEach(marker => {\n          if (marker.p === right) {\n            // right is going to be \"forgotten\" so we need to update the marker\n            marker.p = this\n            // adjust marker index\n            if (!this.deleted && this.countable) {\n              marker.index -= this.length\n            }\n          }\n        })\n      }\n      if (right.keep) {\n        this.keep = true\n      }\n      this.right = right.right\n      if (this.right !== null) {\n        this.right.left = this\n      }\n      this.length += right.length\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent)\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length\n      }\n      this.markDeleted()\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length)\n      addChangedTypeToTransaction(transaction, parent, this.parentSub)\n      this.content.delete(transaction)\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw error.unexpectedCase()\n    }\n    this.content.gc(store)\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length))\n    } else {\n      this.content = new ContentDeleted(this.length)\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin\n    const rightOrigin = this.rightOrigin\n    const parentSub = this.parentSub\n    const info = (this.content.getRef() & binary.BITS5) |\n      (origin === null ? 0 : binary.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : binary.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : binary.BIT6) // parentSub is non-null\n    encoder.writeInfo(info)\n    if (origin !== null) {\n      encoder.writeLeftID(origin)\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin)\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent)\n      if (parent._item !== undefined) {\n        const parentItem = parent._item\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent)\n          encoder.writeParentInfo(true) // write parentYKey\n          encoder.writeString(ykey)\n        } else {\n          encoder.writeParentInfo(false) // write parent id\n          encoder.writeLeftID(parentItem.id)\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true) // write parentYKey\n        encoder.writeString(parent)\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false) // write parent id\n        encoder.writeLeftID(parent)\n      } else {\n        error.unexpectedCase()\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub)\n      }\n    }\n    this.content.write(encoder, offset)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nexport const readItemContent = (decoder, info) => contentRefs[info & binary.BITS5](decoder)\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nexport const contentRefs = [\n  () => { error.unexpectedCase() }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { error.unexpectedCase() } // 10 - Skip is not ItemContent\n]\n\n/**\n * Do not implement this class!\n */\nexport class AbstractContent {\n  /**\n   * @return {number}\n   */\n  getLength () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * Should return false if this Item is some kind of meta information\n   * (e.g. format information).\n   *\n   * * Whether this Item should be addressable via `yarray.get(i)`\n   * * Whether this Item should be counted when computing yarray.length\n   *\n   * @return {boolean}\n   */\n  isCountable () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractContent}\n   */\n  copy () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {number} offset\n   * @return {AbstractContent}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {AbstractContent} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    throw error.methodUnimplemented()\n  }\n}\n","\nimport {\n  AbstractStruct,\n  UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, ID // eslint-disable-line\n} from '../internals.js'\nimport * as error from 'lib0/error'\nimport * as encoding from 'lib0/encoding'\n\nexport const structSkipRefNumber = 10\n\n/**\n * @private\n */\nexport class Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    error.unexpectedCase()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber)\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    encoding.writeVarUint(encoder.restEncoder, this.length - offset)\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n"],"names":[],"mappings":"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"}